/*
This source file is part of Castor3D (http://castor3d.developpez.com/castor3d.html)
Copyright (c) 2016 dragonjoker59@hotmail.com

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/
import "oaidl.idl";
import "ocidl.idl";

// eLOG_TYPE
[
	uuid( EC3C4DA0-439C-4CD0-A879-001377785B0A ),
	helpstring( "Castor Log levels enumeration." )
]
typedef enum
{
	eLOG_TYPE_TRACE,
	eLOG_TYPE_DEBUG,
	eLOG_TYPE_INFO,
	eLOG_TYPE_WARNING,
	eLOG_TYPE_ERROR,
	eLOG_TYPE_COUNT,
}	eLOG_TYPE;

// eINTERSECTION
[
	uuid( 906BC7B0-9600-4A6D-904B-55135066E57B ),
	helpstring( "Castor 2D Rectangle intersection results enumeration." )
]
typedef enum
{
	eINTERSECTION_IN,
	eINTERSECTION_OUT,
	eINTERSECTION_INTERSECT,
	eINTERSECTION_COUNT,
}	eINTERSECTION;

// ePIXEL_FORMAT
[
	uuid( A6264911-DB89-4B0B-902B-69E79A943979 ),
	helpstring( "Castor Pixel formats enumeration." )
]
typedef enum
{
	ePIXEL_FORMAT_L8,
	ePIXEL_FORMAT_L16F,
	ePIXEL_FORMAT_L32F,
	ePIXEL_FORMAT_A8L8,
	ePIXEL_FORMAT_AL16F,
	ePIXEL_FORMAT_AL32F,
	ePIXEL_FORMAT_A1R5G5B5,
	ePIXEL_FORMAT_R5G6B5,
	ePIXEL_FORMAT_R8G8B8,
	ePIXEL_FORMAT_B8G8R8,
	ePIXEL_FORMAT_R8G8B8_SRGB,
	ePIXEL_FORMAT_B8G8R8_SRGB,
	ePIXEL_FORMAT_A8R8G8B8,
	ePIXEL_FORMAT_A8B8G8R8,
	ePIXEL_FORMAT_A8R8G8B8_SRGB,
	ePIXEL_FORMAT_A8B8G8R8_SRGB,
	ePIXEL_FORMAT_RGB16F,
	ePIXEL_FORMAT_RGBA16F,
	ePIXEL_FORMAT_RGB32F,
	ePIXEL_FORMAT_RGBA32F,
	ePIXEL_FORMAT_DXTC1,
	ePIXEL_FORMAT_DXTC3,
	ePIXEL_FORMAT_DXTC5,
	ePIXEL_FORMAT_D16,
	ePIXEL_FORMAT_D24S8,
	ePIXEL_FORMAT_D32,
	ePIXEL_FORMAT_D32F,
	ePIXEL_FORMAT_D32FS8,
	ePIXEL_FORMAT_S8,
	ePIXEL_FORMAT_COUNT,
}	ePIXEL_FORMAT;

// eRENDERER_TYPE
[
	uuid( 30F8D353-04EA-4041-A67C-C421945DF1D2 ),
	helpstring( "Castor3D supported renderer types enumeration." )
]
typedef enum
{
	eRENDERER_TYPE_OPENGL3,
	eRENDERER_TYPE_OPENGL4,
	eRENDERER_TYPE_VULKAN,
}	eRENDERER_TYPE;

// eLIGHT_TYPE
[
	uuid( 084CFBD9-923F-40AD-8008-0BF71D274051 ),
	helpstring( "Castor3D light types enumeration." )
]
typedef enum
{
	eLIGHT_TYPE_DIRECTIONAL,
	eLIGHT_TYPE_POINT,
	eLIGHT_TYPE_SPOT,
}	eLIGHT_TYPE;

// eMOVABLE_TYPE
[
	uuid( 8A15F144-5401-40C1-BF16-126783598F51 ),
	helpstring( "Castor3D movable types enumeration." )
]
typedef enum
{
	eMOVABLE_TYPE_CAMERA,
	eMOVABLE_TYPE_GEOMETRY,
	eMOVABLE_TYPE_LIGHT,
	eMOVABLE_TYPE_BILLBOARD,
	eMOVABLE_TYPE_PARTICLE_EMITTER,
}	eMOVABLE_TYPE;

// eOVERLAY_TYPE
[
	uuid( A6E2293D-371E-4D83-9075-02778A546FA5 ),
	helpstring( "Castor3D overlay types enumeration." )
]
typedef enum
{
	eOVERLAY_TYPE_PANEL,
	eOVERLAY_TYPE_BORDER_PANEL,
	eOVERLAY_TYPE_TEXT,
}	eOVERLAY_TYPE;

// eBORDER_POSITION
[
	uuid( B78BF8F8-8A36-4AB4-B8C8-3AE85D9FD3F0 ),
	helpstring( "Castor3D border positions enumeration." )
]
typedef enum
{
	eBORDER_POSITION_INTERNAL,
	eBORDER_POSITION_MIDDLE,
	eBORDER_POSITION_EXTERNAL,
}	eBORDER_POSITION;

// eTEXT_WRAPPING_MODE
[
	uuid( 41DE0D68-CE43-4601-8B75-63D193E2A74C ),
	helpstring( "Castor3D text wrapping modes enumeration." )
]
typedef enum
{
	eTEXT_WRAPPING_MODE_NONE,
	eTEXT_WRAPPING_MODE_BREAK,
	eTEXT_WRAPPING_MODE_BREAK_WORDS,
}	eTEXT_WRAPPING_MODE;

// eTEXT_LINE_SPACING_MODE
[
	uuid( 7319C53A-C66B-49EE-BFE8-F43D6A824328 ),
	helpstring( "Castor3D line spacing enumeration." )
]
typedef enum
{
	eTEXT_LINE_SPACING_MODE_OWN_HEIGHT,
	eTEXT_LINE_SPACING_MODE_MAX_LINE_HEIGHT,
	ETEXT_LINE_SPACING_MODE_MAX_FONT_HEIGHT,
	eTEXT_LINE_SPACING_MODE_COUNT
}	eTEXT_LINE_SPACING_MODE;

// eHALIGN
[
	uuid( 9E5C0496-1EA0-498D-92E7-C595E6E10B69 ),
	helpstring( "Castor3D text horizontal alignments enumeration." )
]
typedef enum
{
	eHALIGN_LEFT,
	eHALIGN_CENTER,
	eHALIGN_RIGHT,
	eHALIGN_COUNT
}	eHALIGN;

// eVALIGN
[
	uuid( 9666971B-A992-45C8-A9FE-88CD97F878FC ),
	helpstring( "Castor3D text vertical alignments enumeration." )
]
typedef enum
{
	eVALIGN_TOP,
	eVALIGN_CENTER,
	eVALIGN_BOTTOM,
	eVALIGN_COUNT
}	eVALIGN;

// eTEXT_TEXTURING_MODE
[
	uuid( 5C5E8371-D047-4652-95E6-62AF189EF357 ),
	helpstring( "Castor3D text texturing modes enumeration." )
]
typedef enum
{
	eTEXT_TEXTURING_MODE_LETTER,
	eTEXT_TEXTURING_MODE_TEXT,
	eTEXT_TEXTURING_MODE_COUNT
}	eTEXT_TEXTURING_MODE;

// eVIEWPORT_TYPE
[
	uuid( A4D87FE1-238D-4CE5-9458-6923F4196875 )
]
typedef enum
{
	eVIEWPORT_TYPE_ORTHO,
	eVIEWPORT_TYPE_PERSPECTIVE,
	eVIEWPORT_TYPE_FRUSTUM,
	eVIEWPORT_TYPE_COUNT,
}	eVIEWPORT_TYPE;

// eANIMATION_TYPE
[
	uuid( 978995A1-5187-477B-B645-66FC3265DEE5 ),
	helpstring( "Castor3D Animable objects enumeration." )
]
typedef enum
{
	eANIMATION_TYPE_MOVABLE,
	eANIMATION_TYPE_SKELETON,
	eANIMATION_TYPE_MESH,
	eANIMATION_TYPE_COUNT
}	eANIMATION_TYPE;

// eANIMATION_STATE
[
	uuid( 7657DCA9-7009-43A9-949D-4A6CE59682CF ),
	helpstring( "Castor3D Animation states enumeration." )
]
typedef enum
{
	eANIMATION_STATE_PLAYING,
	eANIMATION_STATE_STOPPED,
	eANIMATION_STATE_PAUSED,
	eANIMATION_STATE_COUNT
}	eANIMATION_STATE;

// eSKELETON_ANIMATION_OBJECT_TYPE
[
	uuid( BCBC3FF1-78EE-4147-BC16-CEC568D93E81 ),
	helpstring( "Castor3D Skeleton animation objects enumeration." )
]
typedef enum
{
	eSKELETON_ANIMATION_OBJECT_TYPE_NODE,
	eSKELETON_ANIMATION_OBJECT_TYPE_BONE,
	eSKELETON_ANIMATION_OBJECT_TYPE_COUNT
}	eSKELETON_ANIMATION_OBJECT_TYPE;

// eTEXTURE_CHANNEL
[
	uuid( C0F75923-E03E-49B7-B7C9-EFAC55630B7F ),
	helpstring( "Castor3D Texture channels enumeration." )
]
typedef enum
{
	eTEXTURE_CHANNEL_DIFFUSE = 0x00000001,
	eTEXTURE_CHANNEL_ALBEDO = eTEXTURE_CHANNEL_DIFFUSE,
	eTEXTURE_CHANNEL_NORMAL = 0x00000002,
	eTEXTURE_CHANNEL_OPACITY = 0x00000004,
	eTEXTURE_CHANNEL_SPECULAR = 0x00000008,
	eTEXTURE_CHANNEL_ROUGHNESS = eTEXTURE_CHANNEL_SPECULAR,
	eTEXTURE_CHANNEL_HEIGHT = 0x00000010,
	eTEXTURE_CHANNEL_GLOSS = 0x00000020,
	eTEXTURE_CHANNEL_METALLIC = eTEXTURE_CHANNEL_GLOSS,
	eTEXTURE_CHANNEL_EMISSIVE = 0x00000040,
	eTEXTURE_CHANNEL_REFLECTION = 0x00000080,
	eTEXTURE_CHANNEL_REFRACTION = 0x00000100,
	eTEXTURE_CHANNEL_AMBIENT_OCCLUSION = 0x00000200,
	eTEXTURE_CHANNEL_TRANSMITTANCE = 0x00000400,
	eTEXTURE_CHANNEL_ALL = 0x00000FFF,
}	eTEXTURE_CHANNEL;

// eCOMPARISON_FUNC
[
	uuid( 64B09ACE-F388-40FE-83BE-DB4A85BCB84E ),
	helpstring( "Castor3D Comparison functions enumeration." )
]
typedef enum
{
	eCOMPARISON_FUNC_ALWAYS,
	eCOMPARISON_FUNC_LESS,
	eCOMPARISON_FUNC_LESS_OR_EQUAL,
	eCOMPARISON_FUNC_EQUAL,
	eCOMPARISON_FUNC_NOT_EQUAL,
	eCOMPARISON_FUNC_GREATER_OR_EQUAL,
	eCOMPARISON_FUNC_GREATER,
	eCOMPARISON_FUNC_NEVER,
}	eCOMPARISON_FUNC;

// eTEXTURE_TYPE
[
	uuid( 7B89A147-BC55-40AC-B720-435B74348074 ),
	helpstring( "Castor3D Texture types enumeration." )
]
typedef enum
{
	eTEXTURE_TYPE_BUFFER,
	eTEXTURE_TYPE_1D,
	eTEXTURE_TYPE_1DARRAY,
	eTEXTURE_TYPE_2D,
	eTEXTURE_TYPE_2DARRAY,
	eTEXTURE_TYPE_2DMS,
	eTEXTURE_TYPE_2DMSARRAY,
	eTEXTURE_TYPE_3D,
	eTEXTURE_TYPE_CUBE,
	eTEXTURE_TYPE_CUBEARRAY,
	eTEXTURE_TYPE_COUNT,
}	eTEXTURE_TYPE;

// eBORDER_COLOUR
[
	uuid( B8F60AF7-CDA2-417B-86B0-ADACD30A359E ),
	helpstring( "Castor3D Border colours enumeration." )
]
typedef enum
{
	eBORDER_COLOUR_FLOAT_TRANSPARENT_BLACK,
	eBORDER_COLOUR_INT_TRANSPARENT_BLACK,
	eBORDER_COLOUR_FLOAT_OPAQUE_BLACK,
	eBORDER_COLOUR_INT_OPAQUE_BLACK,
	eBORDER_COLOUR_FLOAT_OPAQUE_WHITE,
	eBORDER_COLOUR_INT_OPAQUE_WHITE,
	eBORDER_COLOUR_COUNT
}	eBORDER_COLOUR;

// eFILTER_MODE
[
	uuid( D569C3E8-B4C6-454C-AB73-836D2D0489C3 ),
	helpstring( "Castor3D Filter modes enumeration." )
]
typedef enum
{
	eFILTER_MODE_UNDEFINED,
	eFILTER_MODE_NEAREST,
	eFILTER_MODE_LINEAR,
	eFILTER_MODE_COUNT,
}	eFILTER_MODE;

// eMIPMAP_MODE
[
	uuid( 3C873590-292E-4229-992A-95EAA46EC353 ),
	helpstring( "Castor3D Mipmap modes enumeration." )
]
typedef enum
{
	eMIPMAP_MODE_UNDEFINED,
	eMIPMAP_MODE_NEAREST,
	eMIPMAP_MODE_LINEAR,
	eMIPMAP_MODE_COUNT,
}	eMIPMAP_MODE;

// eWRAP_MODE
[
	uuid( 7F174FD6-49BC-4430-B8BB-1448FCD393D6 ),
	helpstring( "Castor3D Wrap modes enumeration." )
]
typedef enum
{
	eWRAP_MODE_REPEAT,
	eWRAP_MODE_MIRRORED_REPEAT,
	eWRAP_MODE_CLAMP_TO_BORDER,
	eWRAP_MODE_CLAMP_TO_EDGE,
	eWRAP_MODE_COUNT,
}	eWRAP_MODE;

// eCOMPARE_OP
[
	uuid( 9479E854-B04C-4697-B807-2A9FF48E6F9F ),
	helpstring( "Castor3D Compare operators enumeration." )
]
typedef enum
{
	eCOMPARE_OP_NONE,
	eCOMPARE_OP_REF_TO_TEXTURE,
	eCOMPARE_OP_COUNT
}	eCOMPARE_OP;

// ePASS_TYPE
[
	uuid( F2C5A760-E42D-466D-B6BF-1FF2EEF233B7 ),
	helpstring( "Castor3D Pass types enumeration." )
]
typedef enum
{
	ePASS_TYPE_LEGACY,
	ePASS_TYPE_METALLIC_ROUGHNESS,
	ePASS_TYPE_SPECULAR_GLOSSINESS,
	ePASS_TYPE_COUNT
}	ePASS_TYPE;

// eINDEX_MAPPING_TYPE
[
	uuid( E8CE3C3D-986E-408C-A4A4-558A59588432 ),
	helpstring( "Castor3D IndexMapping types enumeration." )
]
typedef enum
{
	eINDEX_MAPPING_TYPE_FACE,
	eINDEX_MAPPING_TYPE_LINE,
	eINDEX_MAPPING_TYPE_COUNT
}	eINDEX_MAPPING_TYPE;

// eBACKGROUND_TYPE
[
	uuid( BD1DB4CE-093B-4225-9632-F73A4F8F29FD ),
	helpstring( "Castor3D Background types enumeration." )
]
typedef enum
{
	eBACKGROUND_TYPE_COLOUR,
	eBACKGROUND_TYPE_IMAGE,
	eBACKGROUND_TYPE_SKYBOX,
	eBACKGROUND_TYPE_COUNT
}	eBACKGROUND_TYPE;

interface IRgbaColour;
interface IRgbColour;
interface IHdrRgbaColour;
interface IHdrRgbColour;
interface IVector2D;
interface IVector3D;
interface IVector4D;
interface IAngle;
interface IQuaternion;
interface IMatrix4x4;
interface IPosition;
interface ISize;
interface IRect;
interface IGlyph;
interface ICastorFont;
interface IPixelBuffer;
interface IImage;
interface ILogger;

interface ISubmesh;
interface IMesh;
interface IMovableObject;
interface ILightCategory;
interface IDirectionalLight;
interface IPointLight;
interface ISpotLight;
interface ICamera;
interface ILight;
interface IGeometry;
interface ISceneNode;
interface IOverlayCategory;
interface IPanelOverlay;
interface IBorderPanelOverlay;
interface ITextOverlay;
interface IOverlay;
interface IAnimable;
interface IAnimatedObject;
interface IAnimatedObjectGroup;
interface ITextureImage;
interface ITextureLayout;
interface ITextureUnit;
interface IPass;
interface IMaterial;
interface IEngine;
interface IAnimation;
interface IBone;
interface ISkeleton;
interface IScene;

// IRgbaColour
[
	uuid( CC83C7E1-7669-431D-B174-FB224CD9F0D6 ),
	helpstring( "Castor RGBA Colour interface" ),
	dual,
	oleautomation
]
interface IRgbaColour
	: IDispatch
{
	// Properties
	[propget, id( 1 ), helpstring( "The red value" )] HRESULT R( [out, retval] float * pVal );
	[propput, id( 1 ), helpstring( "The red value" )] HRESULT R( [in] float val );
	[propget, id( 2 ), helpstring( "The green value" )] HRESULT G( [out, retval] float * pVal );
	[propput, id( 2 ), helpstring( "The green value" )] HRESULT G( [in] float val );
	[propget, id( 3 ), helpstring( "The blue value" )] HRESULT B( [out, retval] float * pVal );
	[propput, id( 3 ), helpstring( "The blue value" )] HRESULT B( [in] float val );
	[propget, id( 4 ), helpstring( "The alpha value" )] HRESULT A( [out, retval] float * pVal );
	[propput, id( 4 ), helpstring( "The alpha value" )] HRESULT A( [in] float val );
};

// IRgbColour
[
	uuid( E09F9926-CCEC-489E-99D0-1C0880866BA4 ),
	helpstring( "Castor RGB Colour interface" ),
	dual,
	oleautomation
]
interface IRgbColour
	: IDispatch
{
	// Properties
	[propget, id( 1 ), helpstring( "The red value" )] HRESULT R( [out, retval] float * pVal );
	[propput, id( 1 ), helpstring( "The red value" )] HRESULT R( [in] float val );
	[propget, id( 2 ), helpstring( "The green value" )] HRESULT G( [out, retval] float * pVal );
	[propput, id( 2 ), helpstring( "The green value" )] HRESULT G( [in] float val );
	[propget, id( 3 ), helpstring( "The blue value" )] HRESULT B( [out, retval] float * pVal );
	[propput, id( 3 ), helpstring( "The blue value" )] HRESULT B( [in] float val );
};

// IHdrRgbaColour
[
	uuid( 6F382E53-FE95-48F2-869E-29899045C44D ),
	helpstring( "Castor RGBA HDR Colour interface" ),
	dual,
	oleautomation
]
interface IHdrRgbaColour
	: IDispatch
{
	// Properties
	[propget, id( 1 ), helpstring( "The red value" )] HRESULT R( [out, retval] float * pVal );
	[propput, id( 1 ), helpstring( "The red value" )] HRESULT R( [in] float val );
	[propget, id( 2 ), helpstring( "The green value" )] HRESULT G( [out, retval] float * pVal );
	[propput, id( 2 ), helpstring( "The green value" )] HRESULT G( [in] float val );
	[propget, id( 3 ), helpstring( "The blue value" )] HRESULT B( [out, retval] float * pVal );
	[propput, id( 3 ), helpstring( "The blue value" )] HRESULT B( [in] float val );
	[propget, id( 4 ), helpstring( "The alpha value" )] HRESULT A( [out, retval] float * pVal );
	[propput, id( 4 ), helpstring( "The alpha value" )] HRESULT A( [in] float val );
};

// IHdrRgbColour
[
	uuid( 0DB28BF6-1F47-4552-A245-D921FCB86D26 ),
	helpstring( "Castor RGB HDR Colour interface" ),
	dual,
	oleautomation
]
interface IHdrRgbColour
	: IDispatch
{
	// Properties
	[propget, id( 1 ), helpstring( "The red value" )] HRESULT R( [out, retval] float * pVal );
	[propput, id( 1 ), helpstring( "The red value" )] HRESULT R( [in] float val );
	[propget, id( 2 ), helpstring( "The green value" )] HRESULT G( [out, retval] float * pVal );
	[propput, id( 2 ), helpstring( "The green value" )] HRESULT G( [in] float val );
	[propget, id( 3 ), helpstring( "The blue value" )] HRESULT B( [out, retval] float * pVal );
	[propput, id( 3 ), helpstring( "The blue value" )] HRESULT B( [in] float val );
};

// IVector2D
[
	uuid( B068FB7C-535D-4179-8C58-4E900E1D3265 ),
	helpstring( "Castor 2D Vector interface" ),
	dual,
	oleautomation
]
interface IVector2D
	: IDispatch
{
	// Properties
	[propget, id( 1 ), helpstring( "The X coordinate" )] HRESULT X( [out, retval] float * pVal );
	[propput, id( 1 ), helpstring( "The X coordinate" )] HRESULT X( [in] float val );
	[propget, id( 2 ), helpstring( "The Y coordinate" )] HRESULT Y( [out, retval] float * pVal );
	[propput, id( 2 ), helpstring( "The Y coordinate" )] HRESULT Y( [in] float val );
	// Methods
	[id( 3 ), helpstring( "Negates each coordinate" )] HRESULT Negate();
	[id( 4 ), helpstring( "Modifies Vector to make its length equal to 1" )] HRESULT Normalise();
	[id( 5 ), helpstring( "Scalar product" )] HRESULT Dot( [in] IVector2D * val, [out, retval] float * pRet );
	[id( 6 ), helpstring( "The vector length" )] HRESULT Length( [out, retval] float * pVal );
};

// IVector3D
[
	uuid( D57AB8FD-6CD1-4271-AFC8-C687A2208637 ),
	helpstring( "Castor 3D Vector interface" ),
	dual,
	oleautomation
]
interface IVector3D
	: IDispatch
{
	// Properties
	[propget, id( 1 ), helpstring( "The X coordinate" )] HRESULT X( [out, retval] float * pVal );
	[propput, id( 1 ), helpstring( "The X coordinate" )] HRESULT X( [in] float val );
	[propget, id( 2 ), helpstring( "The Y coordinate" )] HRESULT Y( [out, retval] float * pVal );
	[propput, id( 2 ), helpstring( "The Y coordinate" )] HRESULT Y( [in] float val );
	[propget, id( 3 ), helpstring( "The Z coordinate" )] HRESULT Z( [out, retval] float * pVal );
	[propput, id( 3 ), helpstring( "The Z coordinate" )] HRESULT Z( [in] float val );
	// Methods
	[id( 4 ), helpstring( "Negates each coordinate" )] HRESULT Negate();
	[id( 5 ), helpstring( "Modifies Vector to make its length equal to 1" )] HRESULT Normalise();
	[id( 6 ), helpstring( "Scalar product" )] HRESULT Dot( [in] IVector3D * val, [out, retval] float * pRet );
	[id( 7 ), helpstring( "Cross product" )] HRESULT Cross( [in] IVector3D * val, [out, retval] IVector3D ** pRet );
	[id( 8 ), helpstring( "The vector length" )] HRESULT Length( [out, retval] float * pVal );
};

// IVector4D
[
	uuid( 28A891B1-D29C-41F4-9C51-C6B4913DB0B9 ),
	helpstring( "Castor 4D Vector interface" ),
	dual,
	oleautomation
]
interface IVector4D
	: IDispatch
{
	// Properties
	[propget, id( 1 ), helpstring( "The X coordinate" )] HRESULT X( [out, retval] float * pVal );
	[propput, id( 1 ), helpstring( "The X coordinate" )] HRESULT X( [in] float val );
	[propget, id( 2 ), helpstring( "The Y coordinate" )] HRESULT Y( [out, retval] float * pVal );
	[propput, id( 2 ), helpstring( "The Y coordinate" )] HRESULT Y( [in] float val );
	[propget, id( 3 ), helpstring( "The Z coordinate" )] HRESULT Z( [out, retval] float * pVal );
	[propput, id( 3 ), helpstring( "The Z coordinate" )] HRESULT Z( [in] float val );
	[propget, id( 4 ), helpstring( "The W coordinate" )] HRESULT W( [out, retval] float * pVal );
	[propput, id( 4 ), helpstring( "The W coordinate" )] HRESULT W( [in] float val );
	// Methods
	[id( 5 ), helpstring( "Negates each coordinate" )] HRESULT Negate();
	[id( 6 ), helpstring( "Modifies Vector to make its length equal to 1" )] HRESULT Normalise();
	[id( 7 ), helpstring( "Scalar product" )] HRESULT Dot( [in] IVector4D * val, [out, retval] float * pRet );
	[id( 8 ), helpstring( "The vector length" )] HRESULT Length( [out, retval] float * pVal );
};

// IAngle
[
	uuid( 8C61B6CB-616A-4B2F-92BE-5A00511233EF ),
	helpstring( "Castor Angle interface" ),
	dual,
	oleautomation
]
interface IAngle
	: IDispatch
{
	[propget, id( 1 ), helpstring( "The degrees value for the angle" )] HRESULT Degrees( [out, retval] float * pVal );
	[propput, id( 1 ), helpstring( "The degrees value for the angle" )] HRESULT Degrees( [in] float val );
	[propget, id( 2 ), helpstring( "The radians value for the angle" )] HRESULT Radians( [out, retval] float * pVal );
	[propput, id( 2 ), helpstring( "The radians value for the angle" )] HRESULT Radians( [in] float val );
	[propget, id( 3 ), helpstring( "The grads value for the angle" )] HRESULT Grads( [out, retval] float * pVal );
	[propput, id( 3 ), helpstring( "The grads value for the angle" )] HRESULT Grads( [in] float val );
	[id( 4 ), helpstring( "The cosine value for this angle" )] HRESULT Cos( [out, retval] float * pVal );
	[id( 5 ), helpstring( "The sine value for this angle" )] HRESULT Sin( [out, retval] float * pVal );
	[id( 6 ), helpstring( "The tangent value for this angle" )] HRESULT Tan( [out, retval] float * pVal );
	[id( 7 ), helpstring( "Sets this angle value from a cosine" )] HRESULT ACos( [in] float val );
	[id( 8 ), helpstring( "Sets this angle value from a sine" )] HRESULT ASin( [in] float val );
	[id( 9 ), helpstring( "Sets this angle value from a tangent" )] HRESULT ATan( [in] float val );
	[id( 10 ), helpstring( "The hyperbolic cosine value for this angle" )] HRESULT Cosh( [out, retval] float * pVal );
	[id( 11 ), helpstring( "The hyperbolic sine value for this angle" )] HRESULT Sinh( [out, retval] float * pVal );
	[id( 12 ), helpstring( "The hyperbolic tangent value for this angle" )] HRESULT Tanh( [out, retval] float * pVal );
};

// IQuaternion
[
	uuid( B28DD02F-A3D5-48C1-89BB-E5B69B21455D ),
	helpstring( "Castor Quaternion interface" ),
	dual,
	oleautomation
]
interface IQuaternion
	: IDispatch
{
	[propget, id( 1 ), helpstring( "The quaternions's rotation matrix" )] HRESULT RotationMatrix( [out, retval] IMatrix4x4 ** pVal );
	[id( 2 ), helpstring( "Transforms a vector through this quaternion" )] HRESULT Transform( [in] IVector3D * val, [out, retval] IVector3D ** pVal );
	[id( 3 ), helpstring( "Retrieves the quaternion's axis and angle" )] HRESULT ToAxisAngle( [out] IVector3D ** pAxis, [out] IAngle ** pAngle );
	[id( 4 ), helpstring( "Defines this quaternion's axis and angle" )] HRESULT FromAxisAngle( [in] IVector3D * axis, [in] IAngle * angle );
	[id( 5 ), helpstring( "Retrieves the quaternion's axes" )] HRESULT ToAxes( [out] IVector3D ** pX, [out] IVector3D ** pY, [out] IVector3D ** pZ );
	[id( 6 ), helpstring( "Defines this quaternion's axes" )] HRESULT FromAxes( [in] IVector3D * x, [in] IVector3D * y, [in] IVector3D * z );
	[id( 7 ), helpstring( "Retrieves the quaternion's magnitude" )] HRESULT GetMagnitude( [out, retval] float * pVal );
	[id( 8 ), helpstring( "Retrieves the quaternion's conjugate" )] HRESULT Conjugate();
	[id( 9 ), helpstring( "Spherical linear interpolation with another quaternion, takes the shortest path." )] HRESULT Slerp( [in]IQuaternion * quat, [in] float percent, [out, retval] IQuaternion ** pQuat );
	[id( 10 ), helpstring( "Spherical linear interpolation with another quaternion." )] HRESULT Mix( [in]IQuaternion * quat, [in] float percent, [out, retval] IQuaternion ** pQuat );
}

// IMatrix4x4
[
	uuid( 80CF5574-9CE8-4CF8-B402-F013A0A9BD4C ),
	helpstring( "Castor Square 4x4 matrix interface" ),
	dual,
	oleautomation
]
interface IMatrix4x4
	: IDispatch
{
	[id( 1 ), helpstring( "Transposes the matrix" )] HRESULT Transpose();
	[id( 2 ), helpstring( "Inverts the matrix" )] HRESULT Invert();
};

// IPosition
[
	uuid( AFBFFD86-1B3A-4217-900A-97E9B4CEB397 ),
	helpstring( "Castor 2D Position interface" ),
	dual,
	oleautomation
]
interface IPosition
	: IDispatch
{
	// Properties
	[propget, id( 1 ), helpstring( "The X coordinate" )] HRESULT X( [out, retval] int * pVal );
	[propput, id( 1 ), helpstring( "The X coordinate" )] HRESULT X( [in] int val );
	[propget, id( 2 ), helpstring( "The Y coordinate" )] HRESULT Y( [out, retval] int * pVal );
	[propput, id( 2 ), helpstring( "The Y coordinate" )] HRESULT Y( [in] int val );
	// Methods
	[id( 3 ), helpstring( "Sets the position coordinates" )] HRESULT Set( [in] int x, [in] int y );
	[id( 4 ), helpstring( "Moves the position with the given values" )] HRESULT Offset( [in] int x, [in] int y );
};

// ISize
[
	uuid( 8C3BBFE3-6894-4615-B19E-72243E7BF550 ),
	helpstring( "Castor 2D Size interface" ),
	dual,
	oleautomation
]
interface ISize
	: IDispatch
{
	// Properties
	[propget, id( 1 ), helpstring( "The width value" )] HRESULT Width( [out, retval] unsigned int * pVal );
	[propput, id( 1 ), helpstring( "The width value" )] HRESULT Width( [in] unsigned int val );
	[propget, id( 2 ), helpstring( "The height value" )] HRESULT Height( [out, retval] unsigned int * pVal );
	[propput, id( 2 ), helpstring( "The height value" )] HRESULT Height( [in] unsigned int val );
	// Methods
	[id( 3 ), helpstring( "Sets the size value" )] HRESULT Set( [in] unsigned int cx, [in] unsigned int cy );
	[id( 4 ), helpstring( "Adds the parameters to the size ones" )] HRESULT Grow( [in] int cx, [in] int cy );
};

// IRectangle
[
	uuid( 2E2DF1BB-83BE-4AEB-B183-6DEF2B7930B2 ),
	helpstring( "Castor 2D Rectangle interface" ),
	dual,
	oleautomation
]
interface IRect
	: IDispatch
{
	// Properties
	[propget, id( 1 ), helpstring( "The top value" )] HRESULT Top( [out, retval] int * pVal );
	[propput, id( 1 ), helpstring( "The top value" )] HRESULT Top( [in] int val );
	[propget, id( 2 ), helpstring( "The bottom value" )] HRESULT Bottom( [out, retval] int * pVal );
	[propput, id( 2 ), helpstring( "The bottom value" )] HRESULT Bottom( [in] int val );
	[propget, id( 3 ), helpstring( "The left value" )] HRESULT Left( [out, retval] int * pVal );
	[propput, id( 3 ), helpstring( "The left value" )] HRESULT Left( [in] int val );
	[propget, id( 4 ), helpstring( "The right value" )] HRESULT Right( [out, retval] int * pVal );
	[propput, id( 4 ), helpstring( "The right value" )] HRESULT Right( [in] int val );
	[propget, id( 5 ), helpstring( "The width value" )] HRESULT Width( [out, retval] int * pVal );
	[propget, id( 6 ), helpstring( "The height value" )] HRESULT Height( [out, retval] int * pVal );
	// Methods
	[id( 7 ), helpstring( "Sets the rect values" )] HRESULT Set( [in] int top, [in] int left, [in] int right, [in] int bottom );
	[id( 8 ), helpstring( "Checks if the given point is in the rect" )] HRESULT IntersectsPosition( [in] IPosition * pos, [out, retval] eINTERSECTION * pVal );
	[id( 9 ), helpstring( "Checks if the given rectanggle intersects this one" )] HRESULT IntersectsRectangle( [in] IRect * rect, [out, retval] eINTERSECTION * pVal );
};

// IGlyph
[
	uuid( D7252720-F639-4B97-8DF6-EAC59CF8A0B5 ),
	helpstring( "Castor Glyph interface" ),
	dual,
	oleautomation
]
interface IGlyph
	: IDispatch
{
	[propget, id( 1 ), helpstring( "property Size" )] HRESULT Size( [out, retval] ISize ** pVal );
	[propget, id( 2 ), helpstring( "property Bearing" )] HRESULT Bearing( [out, retval] IPosition ** pVal );
	[propget, id( 3 ), helpstring( "property Advance" )] HRESULT Advance( [out, retval] int * pVal );
};

// ICastorFont
[
	uuid( 46E09586-EB07-4759-BAE1-E4BD7109415E ),
	helpstring( "Castor Font interface" ),
	dual,
	oleautomation
]
interface ICastorFont
	: IDispatch
{
	[propget, id( 1 ), helpstring( "property Height" )] HRESULT Height( [out, retval] UINT * pVal );
	[propget, id( 2 ), helpstring( "property MaxHeight" )] HRESULT MaxHeight( [out, retval] INT * pVal );
	[propget, id( 3 ), helpstring( "property MaxWidth" )] HRESULT MaxWidth( [out, retval] INT * pVal );
	[id( 4 ), helpstring( "method LoadFromFile" )] HRESULT LoadFromFile( [in] IEngine * engine, [in] BSTR path, [in] BSTR name, [in] UINT height );
	[id( 5 ), helpstring( "method GetGlyph" )] HRESULT GetGlyph( [in] WORD glyph, [out, retval] IGlyph ** pGlyph );
};

// IPixelBuffer
[
	uuid( A7DBFA7B-DE35-4A97-906B-DCCF59669F68 ),
	helpstring( "Castor PixelBuffer interface" ),
	dual,
	oleautomation
]
interface IPixelBuffer
	: IDispatch
{
	[propget, id( 1 ), helpstring( "property Dimensions" )] HRESULT Dimensions( [out, retval] ISize ** pVal );
	[propget, id( 2 ), helpstring( "property Width" )] HRESULT Width( [out, retval] unsigned int * pVal );
	[propget, id( 3 ), helpstring( "property Height" )] HRESULT Height( [out, retval] unsigned int * pVal );
	[propget, id( 4 ), helpstring( "property PixelFormat" )] HRESULT PixelFormat( [out, retval] ePIXEL_FORMAT * pVal );
	[id( 5 ), helpstring( "method Flip" )] HRESULT Flip();
	[id( 6 ), helpstring( "method Mirror" )] HRESULT Mirror();
	[id( 7 ), helpstring( "Initialises the buffer" )] HRESULT Initialise( ISize * size, ePIXEL_FORMAT pf );
};

// IImage
[
	uuid( 2841C68A-359E-4642-A8C5-43CC5D30F93C ),
	helpstring( "Castor Image interface" ),
	dual,
	oleautomation
]
interface IImage
	: IDispatch
{
	// Properties
	[propget, id( 1 ), helpstring( "The image pixels buffer" )] HRESULT Buffer( [out, retval] IPixelBuffer ** pVal );

	// Methods
	[id( 2 ), helpstring( "method LoadFromFile" )] HRESULT LoadFromFile( [in] IEngine * engine, [in] BSTR name, [in] BSTR val );
	[id( 3 ), helpstring( "method LoadFromFormat" )] HRESULT LoadFromFormat( [in] IEngine * engine, [in] BSTR name, [in] ePIXEL_FORMAT fmt, [in] ISize * size );
	[id( 4 ), helpstring( "method Resample" )] HRESULT Resample( [in] ISize * val );
	[id( 5 ), helpstring( "method Fill" )] HRESULT Fill( [in] IRgbaColour * val );
	[id( 6 ), helpstring( "method CopyImage" )] HRESULT CopyImage( [in] IImage * pVal );
	[id( 7 ), helpstring( "method SubImage" )] HRESULT SubImage( [in] IRect * val, [out, retval] IImage ** pVal );
};

// ILogger
[
	uuid( 7C23A081-332D-40F2-B12E-2CBEDB5FB242 ),
	helpstring( "Castor Logger interface" ),
	dual,
	oleautomation
]
interface ILogger
	: IDispatch
{
	// Methods
	[id( 1 ), helpstring( "method Initialise" )] HRESULT Initialise( [in] eLOG_TYPE level );
	[id( 2 ), helpstring( "method SetFileName" )] HRESULT SetFileName( [in] BSTR name, eLOG_TYPE target );
	[id( 3 ), helpstring( "method Cleanup" )] HRESULT Cleanup();
	[id( 4 ), helpstring( "method LogTrace" )] HRESULT LogTrace( [in] BSTR msg );
	[id( 5 ), helpstring( "method LogDebug" )] HRESULT LogDebug( [in] BSTR msg );
	[id( 6 ), helpstring( "method LogInfo" )] HRESULT LogInfo( [in] BSTR msg );
	[id( 7 ), helpstring( "method LogWarning" )] HRESULT LogWarning( [in] BSTR msg );
	[id( 8 ), helpstring( "method LogError" )] HRESULT LogError( [in] BSTR msg );
};

// IRenderTarget
[
	uuid( EC5787A9-9B4B-4F14-B2FF-2C2FB9E58B90 ),
	helpstring( "Castor3D RenderTarget interface" ),
	dual,
	oleautomation
]
interface IRenderTarget
	: IDispatch
{
	[propget, id( 1 ), helpstring( "The target camera" )] HRESULT Camera( [out, retval] ICamera ** pVal );
	[propput, id( 1 ), helpstring( "The target camera" )] HRESULT Camera( [in] ICamera * camera );
	[propget, id( 2 ), helpstring( "The viewport type" )] HRESULT ViewportType( [out, retval] eVIEWPORT_TYPE * pVal );
	[propput, id( 2 ), helpstring( "The viewport type" )] HRESULT ViewportType( [in] eVIEWPORT_TYPE val );
	[propget, id( 3 ), helpstring( "The rendered scene" )] HRESULT Scene( [out, retval] IScene ** pVal );
	[propput, id( 3 ), helpstring( "The rendered scene" )] HRESULT Scene( [in] IScene * val );
	[propget, id( 4 ), helpstring( "The target pixel format" )] HRESULT PixelFormat( [out, retval] ePIXEL_FORMAT * pVal );
	[propput, id( 4 ), helpstring( "The target pixel format" )] HRESULT PixelFormat( [in] ePIXEL_FORMAT val );
	[propget, id( 5 ), helpstring( "The target size" )] HRESULT Size( [out, retval] ISize ** pVal );
	[id( 6 ), helpstring( "Initialises the render target" ), local] HRESULT Initialise();
	[id( 7 ), helpstring( "Cleans the render target up" )] HRESULT Cleanup();
};

// ISampler
[
	uuid( AE167A91-F79C-42C3-9F07-2491F5FD9931 ),
	helpstring( "Castor3D Sampler interface" ),
	dual,
	oleautomation
]
interface ISampler
	: IDispatch
{
	[propget, id( 1 ), helpstring( "The sampler min filter" )] HRESULT MinFilter( [out, retval] eFILTER_MODE * pVal );
	[propput, id( 1 ), helpstring( "The sampler min filter" )] HRESULT MinFilter( [in] eFILTER_MODE val );
	[propget, id( 2 ), helpstring( "The sampler mag filter" )] HRESULT MagFilter( [out, retval] eFILTER_MODE * pVal );
	[propput, id( 2 ), helpstring( "The sampler mag filter" )] HRESULT MagFilter( [in] eFILTER_MODE val );
	[propget, id( 3 ), helpstring( "The sampler mip filter" )] HRESULT MipmapMode( [out, retval] eMIPMAP_MODE * pVal );
	[propput, id( 3 ), helpstring( "The sampler mip filter" )] HRESULT MipmapMode( [in] eMIPMAP_MODE val );
	[propget, id( 4 ), helpstring( "The sampler U wrap mode" )] HRESULT WrapModeU( [out, retval] eWRAP_MODE * pVal );
	[propput, id( 4 ), helpstring( "The sampler U wrap mode" )] HRESULT WrapModeU( [in] eWRAP_MODE val );
	[propget, id( 5 ), helpstring( "The sampler V wrap mode" )] HRESULT WrapModeV( [out, retval] eWRAP_MODE * pVal );
	[propput, id( 5 ), helpstring( "The sampler V wrap mode" )] HRESULT WrapModeV( [in] eWRAP_MODE val );
	[propget, id( 6 ), helpstring( "The sampler W wrap mode" )] HRESULT WrapModeW( [out, retval] eWRAP_MODE * pVal );
	[propput, id( 6 ), helpstring( "The sampler W wrap mode" )] HRESULT WrapModeW( [in] eWRAP_MODE val );
	[propget, id( 7 ), helpstring( "The sampler max anisotropy" )] HRESULT MaxAnisotropy( [out, retval] float * pVal );
	[propput, id( 7 ), helpstring( "The sampler max anisotropy" )] HRESULT MaxAnisotropy( [in] float val );
	[propget, id( 8 ), helpstring( "The sampler min LOD" )] HRESULT MinLod( [out, retval] float * pVal );
	[propput, id( 8 ), helpstring( "The sampler min LOD" )] HRESULT MinLod( [in] float val );
	[propget, id( 9 ), helpstring( "The sampler max LOD" )] HRESULT MaxLod( [out, retval] float * pVal );
	[propput, id( 9 ), helpstring( "The sampler max LOD" )] HRESULT MaxLod( [in] float val );
	[propget, id( 10 ), helpstring( "The sampler LOD bias" )] HRESULT LodBias( [out, retval] float * pVal );
	[propput, id( 10 ), helpstring( "The sampler LOD bias" )] HRESULT LodBias( [in] float val );
	[propget, id( 11 ), helpstring( "The sampler border colour" )] HRESULT BorderColour( [out, retval] eBORDER_COLOUR * pVal );
	[propput, id( 11 ), helpstring( "The sampler border colour" )] HRESULT BorderColour( [in] eBORDER_COLOUR val );
	[id( 12 ), helpstring( "Initialises the sampler" )] HRESULT Initialise();
	[id( 13 ), helpstring( "Cleans the sampler up" )] HRESULT Cleanup();
};

// ITextureView
[
	uuid( AD4C78E2-277A-4F6E-A1BB-F94FEA78F4A5 ),
	helpstring( "Castor3D TextureImage interface" ),
	dual,
	oleautomation
]
interface ITextureView
	: IDispatch
{
	[propget, id( 1 ), helpstring( "The texture image buffer" )] HRESULT Buffer( [out, retval] IPixelBuffer ** pVal );
	[id( 4 ), helpstring( "Sets the image source" )] HRESULT StaticSource( [in] IPixelBuffer * val );
	[id( 5 ), helpstring( "Sets the image source" )] HRESULT Dynamic2DSource( [in] unsigned int w, [in] unsigned int h, [in] ePIXEL_FORMAT format );
	[id( 6 ), helpstring( "Sets the image source" )] HRESULT Dynamic3DSource( [in] unsigned int w, [in] unsigned int h, [in] unsigned int d, [in] ePIXEL_FORMAT format );
};

// ITextureLayout
[
	uuid( 8985F532-34C0-4996-882C-8850D45C53F1 ),
	helpstring( "Castor3D TextureLayout interface" ),
	dual,
	oleautomation
]
interface ITextureLayout
	: IDispatch
{
	[propget, id( 1 ), helpstring( "The texture type" )] HRESULT Type( [out, retval] eTEXTURE_TYPE * pVal );
	[propget, id( 2 ), helpstring( "The texture image at given index" )] HRESULT Image( [in] unsigned int index, [out, retval] ITextureView ** pVal );
	[id( 3 ), helpstring( "Initialises the texture" )] HRESULT Initialise();
	[id( 4 ), helpstring( "Cleans the texture up" )] HRESULT Cleanup();
};

// ITextureUnit
[
	uuid( 224BAC64-C97E-4CB7-8A77-88284BDC4BA7 ),
	helpstring( "Castor3D TextureUnit interface" ),
	dual,
	oleautomation
]
interface ITextureUnit
	: IDispatch
{
	[propget, id( 1 ), helpstring( "The unit texture" )] HRESULT Texture( [out, retval] ITextureLayout ** pVal );
	[propput, id( 1 ), helpstring( "The unit texture" )] HRESULT Texture( [in] ITextureLayout * val );
	[propget, id( 2 ), helpstring( "The unit sampler" )] HRESULT Sampler( [out, retval] ISampler ** pVal );
	[propput, id( 2 ), helpstring( "The unit sampler" )] HRESULT Sampler( [in] ISampler * val );
	[propget, id( 3 ), helpstring( "The texture channel" )] HRESULT Channel( [out, retval] eTEXTURE_CHANNEL * pVal );
	[propput, id( 3 ), helpstring( "The texture channel" )] HRESULT Channel( [in] eTEXTURE_CHANNEL val );
	[id( 4 ), helpstring( "Loads the texture image from a file" )] HRESULT LoadTexture( [in] BSTR path );
	[id( 5 ), helpstring( "Initialises the texture" )] HRESULT Initialise();
	[id( 6 ), helpstring( "Cleans the texture up" )] HRESULT Cleanup();
};

// IPass
[
	uuid( 4A915888-BC95-4F0C-A544-2AC83363C5AE ),
	helpstring( "Castor3D Pass interface" ),
	dual,
	oleautomation
]
interface IPass
	: IDispatch
{
	[propget, id( 1 ), helpstring( "The pass two sided status" )] HRESULT TwoSided( [out, retval] boolean * pVal );
	[propput, id( 1 ), helpstring( "The pass two sided status" )] HRESULT TwoSided( [in] boolean val );
	[propget, id( 2 ), helpstring( "The pass global opacity value" )] HRESULT Opacity( [out, retval] float * pVal );
	[propput, id( 2 ), helpstring( "The pass global opacity value" )] HRESULT Opacity( [in] float val );
	[propget, id( 3 ), helpstring( "The pass emissive factor" )] HRESULT Emissive( [out, retval] float * pVal );
	[propput, id( 3 ), helpstring( "The pass emissive factor" )] HRESULT Emissive( [in] float val );
	[propget, id( 4 ), helpstring( "The pass refraction ratio" )] HRESULT RefractionRatio( [out, retval] float * pVal );
	[propput, id( 4 ), helpstring( "The pass refraction ratio" )] HRESULT RefractionRatio( [in] float val );
	[propget, id( 5 ), helpstring( "The pass alpha function" )] HRESULT AlphaFunc( [out, retval] eCOMPARISON_FUNC * pVal );
	[propput, id( 5 ), helpstring( "The pass alpha function" )] HRESULT AlphaFunc( [in] eCOMPARISON_FUNC val );
	[propget, id( 6 ), helpstring( "The pass alpha reference value" )] HRESULT AlphaRefValue( [out, retval] float * pVal );
	[propput, id( 6 ), helpstring( "The pass alpha reference value" )] HRESULT AlphaRefValue( [in] float val );
	[propget, id( 7 ), helpstring( "Retrieves the units count" )] HRESULT TextureUnitCount( [out, retval] unsigned int * pVal );
	[propget, id( 8 ), helpstring( "The pass type" )] HRESULT Type( [out, retval] ePASS_TYPE * pVal );
	[id( 9 ), helpstring( "Creates a texture unit" )] HRESULT CreateTextureUnit( [out, retval] ITextureUnit ** pVal );
	[id( 10 ), helpstring( "Retrieves the texture unit at given index" )] HRESULT GetTextureUnitByIndex( [in] unsigned int index, [out, retval] ITextureUnit ** pVal );
	[id( 11 ), helpstring( "Destroys the texture unit" )] HRESULT DestroyTextureUnit( [in] ITextureUnit * val );
	[id( 12 ), helpstring( "Retrieves the texture unit at given channel" )] HRESULT GetTextureUnitByChannel( [in] eTEXTURE_CHANNEL channel, [out, retval] ITextureUnit ** pVal );
};

// ILegacyPass
[
	uuid( A9DD38BB-99D9-4251-B7CB-5148DC766B4F ),
	helpstring( "Castor3D LegacyPass interface" ),
	dual,
	oleautomation
]
interface ILegacyPass
	: IPass
{
	[propget, id( 20 ), helpstring( "The pass diffuse colour" )] HRESULT Diffuse( [out, retval] IRgbColour ** pVal );
	[propput, id( 20 ), helpstring( "The pass diffuse colour" )] HRESULT Diffuse( [in] IRgbColour * val );
	[propget, id( 21 ), helpstring( "The pass specular colour" )] HRESULT Specular( [out, retval] IRgbColour ** pVal );
	[propput, id( 21 ), helpstring( "The pass specular colour" )] HRESULT Specular( [in] IRgbColour * val );
	[propget, id( 22 ), helpstring( "The pass ambient factor" )] HRESULT Ambient( [out, retval] float * pVal );
	[propput, id( 22 ), helpstring( "The pass ambient factor" )] HRESULT Ambient( [in] float val );
	[propget, id( 23 ), helpstring( "The pass shininess value" )] HRESULT Shininess( [out, retval] float * pVal );
	[propput, id( 23 ), helpstring( "The pass shininess value" )] HRESULT Shininess( [in] float val );
};

// IMetallicRoughnessPbrPass
[
	uuid( 976972FC-91B2-4A8D-A1A9-B7F81D96D637 ),
	helpstring( "Castor3D MetallicRoughnessPbrPass interface" ),
	dual,
	oleautomation
]
interface IMetallicRoughnessPbrPass
	: IPass
{
	[propget, id( 20 ), helpstring( "The pass albedo colour" )] HRESULT Albedo( [out, retval] IRgbColour ** pVal );
	[propput, id( 20 ), helpstring( "The pass albedo colour" )] HRESULT Albedo( [in] IRgbColour * val );
	[propget, id( 21 ), helpstring( "The pass metallic value" )] HRESULT Metallic( [out, retval] float * pVal );
	[propput, id( 21 ), helpstring( "The pass metallic value" )] HRESULT Metallic( [in] float val );
	[propget, id( 22 ), helpstring( "The pass roughness value" )] HRESULT Roughness( [out, retval] float * pVal );
	[propput, id( 22 ), helpstring( "The pass roughness value" )] HRESULT Roughness( [in] float val );
};

// ISpecularGlossinessPbrPass
[
	uuid( 30D6118F-EDA3-43DC-8F78-42BD70CEF47E ),
	helpstring( "Castor3D SpecularGlossinessPbrPass interface" ),
	dual,
	oleautomation
]
interface ISpecularGlossinessPbrPass
	: IPass
{
	[propget, id( 20 ), helpstring( "The pass diffuse colour" )] HRESULT Diffuse( [out, retval] IRgbColour ** pVal );
	[propput, id( 20 ), helpstring( "The pass diffuse colour" )] HRESULT Diffuse( [in] IRgbColour * val );
	[propget, id( 21 ), helpstring( "The pass specular colour" )] HRESULT Specular( [out, retval] IRgbColour ** pVal );
	[propput, id( 21 ), helpstring( "The pass specular colour" )] HRESULT Specular( [in] IRgbColour * val );
	[propget, id( 22 ), helpstring( "The pass glossiness value" )] HRESULT Glossiness( [out, retval] float * pVal );
	[propput, id( 22 ), helpstring( "The pass glossiness value" )] HRESULT Glossiness( [in] float val );
};

// IMaterial
[
	uuid( 60CDC28E-625E-4277-BA83-499AC743433D ),
	helpstring( "Castor3D Material interface" ),
	dual,
	oleautomation
]
interface IMaterial
	: IDispatch
{
	[propget, id( 1 ), helpstring( "Retrieves the passes count" )] HRESULT PassCount( [out, retval] unsigned int * pVal );
	[id( 2 ), helpstring( "Initialises the material" )] HRESULT Initialise();
	[id( 3 ), helpstring( "Cleans the material up" )] HRESULT Cleanup();
	[id( 4 ), helpstring( "Creates a pass" )] HRESULT CreatePass( [out, retval] IPass ** pVal );
	[id( 5 ), helpstring( "Retrieves the pass at given index" )] HRESULT GetPass( [in] unsigned int val, [out, retval] IPass ** pVal );
	[id( 6 ), helpstring( "Destroys the given pass" )] HRESULT DestroyPass( [in] unsigned int val );
};

// IIndexMapping
[
	uuid( 3C6916EB-6D7F-489C-A157-248097C35BDB ),
	helpstring( "Castor3D IndexMapping interface" ),
	dual,
	oleautomation
]
interface IIndexMapping
	: IDispatch
{
	[propget, id( 1 ), helpstring( "The mapping type." )] HRESULT Type( [out, retval] eINDEX_MAPPING_TYPE * pVal );
};

// ITriFaceMapping
[
	uuid( B899E644-D40B-4203-89FD-7384D94B40F0 ),
	helpstring( "Castor3D TriFaceMapping interface" ),
	dual,
	oleautomation
]
interface ITriFaceMapping
	: IIndexMapping
{
	[propget, id( 2 ), helpstring( "The faces count" )] HRESULT FacesCount( [out, retval] unsigned int * pVal );
	[id( 3 ), helpstring( "Adds a face to the mapping, defined by its vertex indices" )] HRESULT AddFace( [in] unsigned int x, [in] unsigned int y, [in] unsigned int z );
};

// ILinesMapping
[
	uuid( 17B24F1B-90F1-40FB-8CA4-E97A63642FF1 ),
	helpstring( "Castor3D LinesMapping interface" ),
	dual,
	oleautomation
]
interface ILinesMapping
	: IIndexMapping
{
	[propget, id( 2 ), helpstring( "The lines count" )] HRESULT LinesCount( [out, retval] unsigned int * pVal );
	[id( 3 ), helpstring( "Adds a line to the mapping, defined by its vertex indices" )] HRESULT AddLine( [in] unsigned int x, [in] unsigned int y );
};

// ISubmesh
[
	uuid( 59DAC74D-1B5C-49BE-A404-96A18E117CC0 ),
	helpstring( "Castor3D Submesh interface" ),
	dual,
	oleautomation
]
interface ISubmesh
	: IDispatch
{
	[propget, id( 1 ), helpstring( "The points count" )] HRESULT PointsCount( [out, retval] unsigned int * pVal );
	[propget, id( 2 ), helpstring( "The index mapping" )] HRESULT IndexMapping( [out, retval] IIndexMapping ** pVal );
	[propput, id( 2 ), helpstring( "The index mapping" )] HRESULT IndexMapping( [in] IIndexMapping * pVal );
	[id( 3 ), helpstring( "Adds a point to the submesh" )] HRESULT AddPoint( [in] IVector3D * val );
};

// IMesh
[
	uuid( 2CD94C1A-39A2-4301-B412-04C7E766DF64 ),
	helpstring( "Castor3D Mesh interface" ),
	dual,
	oleautomation
]
interface IMesh
	: IDispatch
{
	[propget, id( 1 ), helpstring( "The total mesh's submeshes count" )] HRESULT SubmeshCount( [out, retval] unsigned int * pVal );
	[id( 2 ), helpstring( "Retrieves the submesh at the given index" )] HRESULT GetSubmesh( [in] unsigned int val, [out, retval] ISubmesh ** pVal );
	[id( 3 ), helpstring( "Creates a new submesh for this mesh" )] HRESULT CreateSubmesh( [out, retval] ISubmesh ** pVal );
	[id( 4 ), helpstring( "Deletes the given submesh" )] HRESULT DeleteSubmesh( [in] ISubmesh * val );
};

// IRenderWindow
[
	uuid( 37C075FA-038D-468B-AFF8-386E852AC5A2 ),
	helpstring( "Castor3D RenderWindow interface" ),
	dual,
	oleautomation
]
interface IRenderWindow
	: IDispatch
{
	[propget, id( 1 ), helpstring( "The render target" )] HRESULT RenderTarget( [out, retval] IRenderTarget ** pVal );
	[propput, id( 1 ), helpstring( "The render target" )] HRESULT RenderTarget( [in] IRenderTarget * camera );
	[propget, id( 2 ), helpstring( "The window name" )] HRESULT Name( [out, retval] BSTR * pVal );
	[id( 3 ), helpstring( "Initialises the render window" ), local] HRESULT Initialise( [in] ISize * size, [in] LPVOID val, [out, retval] VARIANT_BOOL * pVal );
	[id( 4 ), helpstring( "Cleans the render window up" )] HRESULT Cleanup();
	[id( 5 ), helpstring( "Resizes the render window" )] HRESULT Resize( [in] ISize * size );
	[id( 6 ), helpstring( "MouseMove event processing" )] HRESULT OnMouseMove( [in] IPosition * pos );
	[id( 7 ), helpstring( "MouseMouseLButtondown event processing" )] HRESULT OnMouseLButtonDown( [in] IPosition * pos );
	[id( 8 ), helpstring( "MouseMouseLButtonUp event processing" )] HRESULT OnMouseLButtonUp( [in] IPosition * pos );
	[id( 9 ), helpstring( "MouseMouseMButtondown event processing" )] HRESULT OnMouseMButtonDown( [in] IPosition * pos );
	[id( 10 ), helpstring( "MouseMouseLButtonUp event processing" )] HRESULT OnMouseMButtonUp( [in] IPosition * pos );
	[id( 11 ), helpstring( "MouseMouseRButtondown event processing" )] HRESULT OnMouseRButtonDown( [in] IPosition * pos );
	[id( 12 ), helpstring( "MouseMouseRButtonUp event processing" )] HRESULT OnMouseRButtonUp( [in] IPosition * pos );
};

// ISceneBackground
[
	uuid( 6A1CFD87-AD16-4648-B5DD-F72E1D0C8A01 ),
	helpstring( "Castor3D SceneBackground interface" ),
	dual,
	oleautomation
]
interface ISceneBackground
	: IDispatch
{
	[propget, id( 1 ), helpstring( "The background type" )] HRESULT Type( [out, retval] eBACKGROUND_TYPE * pVal );
};

// IColourBackground
[
	uuid( 26BC338E-1C3A-429E-8255-D31918EB5714 ),
	helpstring( "Castor3D ColourBackground interface" ),
	dual,
	oleautomation
]
interface IColourBackground
	: ISceneBackground
{
};

// IImageBackground
[
	uuid( 2131E254-B2E7-483B-9D9A-E9A57B75E908 ),
	helpstring( "Castor3D ImageBackground interface" ),
	dual,
	oleautomation
]
interface IImageBackground
	: ISceneBackground
{
	[propput, id( 2 ), helpstring( "The background image" )] HRESULT Image( [in] BSTR filePath );
};

// ISkyboxBackground
[
	uuid( 543A3315-BE59-4AE8-9DB2-570DC0095983 ),
	helpstring( "Castor3D SkyboxBackground interface" ),
	dual,
	oleautomation
]
interface ISkyboxBackground
	: ISceneBackground
{
	[propput, id( 2 ), helpstring( "The left face image" )] HRESULT LeftImage( [in] BSTR filePath );
	[propput, id( 3 ), helpstring( "The right face image" )] HRESULT RightImage( [in] BSTR filePath );
	[propput, id( 4 ), helpstring( "The top face image" )] HRESULT TopImage( [in] BSTR filePath );
	[propput, id( 5 ), helpstring( "The bottom face image" )] HRESULT BottomImage( [in] BSTR filePath );
	[propput, id( 6 ), helpstring( "The front face image" )] HRESULT FrontImage( [in] BSTR filePath );
	[propput, id( 7 ), helpstring( "The back face image" )] HRESULT BackImage( [in] BSTR filePath );
	[propput, id( 8 ), helpstring( "The cross image" )] HRESULT CrossImage( [in] BSTR filePath );
	[id( 9 ), helpstring( "Loads an HDRi image" )] HRESULT LoadEquirectangularImage( [in] BSTR filePath, [in] unsigned int size );
};

// IScene
[
	uuid( 6684A9C0-CC49-41F3-B78D-9C34F294AF62 ),
	helpstring( "Castor3D Scene interface" ),
	dual,
	oleautomation
]
interface IScene
	: IDispatch
{
	[propget, id( 1 ), helpstring( "The background" )] HRESULT Background( [out, retval] ISceneBackground ** pVal );
	[propput, id( 1 ), helpstring( "The background" )] HRESULT Background( [in] ISceneBackground * val );
	[propget, id( 2 ), helpstring( "The background colour" )] HRESULT BackgroundColour( [out, retval] IRgbColour ** pVal );
	[propput, id( 2 ), helpstring( "The background colour" )] HRESULT BackgroundColour( [in] IRgbColour * val );
	[propget, id( 3 ), helpstring( "The scene name" )] HRESULT Name( [out, retval] BSTR * pVal );
	[propput, id( 3 ), helpstring( "The scene name" )] HRESULT Name( [in] BSTR val );
	[propget, id( 4 ), helpstring( "The ambient light colour" )] HRESULT AmbientLight( [out, retval] IRgbColour ** pVal );
	[propput, id( 4 ), helpstring( "The ambient light colour" )] HRESULT AmbientLight( [in] IRgbColour * val );
	[propget, id( 5 ), helpstring( "The root scene node" )] HRESULT RootNode( [out, retval] ISceneNode ** pVal );
	[propget, id( 6 ), helpstring( "The objects root scene node" )] HRESULT ObjectRootNode( [out, retval] ISceneNode ** pVal );
	[propget, id( 7 ), helpstring( "The cameras root scene node" )] HRESULT CameraRootNode( [out, retval] ISceneNode ** pVal );
	[id( 8 ), helpstring( "Clears the created objects maps" )] HRESULT ClearScene();
	[id( 9 ), helpstring( "Creates a new scene node" )] HRESULT CreateSceneNode( [in] BSTR name, [in] ISceneNode * parent, [out, retval] ISceneNode ** pVal );
	[id( 10 ), helpstring( "Creates a new geometry" )] HRESULT CreateGeometry( [in] BSTR name, [out, retval] IGeometry ** pVal );
	[id( 11 ), helpstring( "Creates a new camera" )] HRESULT CreateCamera( [in] BSTR name, [in] int ww, [in] int wh, [in] ISceneNode * node, [out, retval] ICamera ** pVal );
	[id( 12 ), helpstring( "Creates a new light" )] HRESULT CreateLight( [in] BSTR name, [in] ISceneNode * node, [in] eLIGHT_TYPE type, [out, retval] ILight ** pVal );
	[id( 13 ), helpstring( "Retrieves the scene node with the given name" )] HRESULT GetNode( [in] BSTR name, [out, retval] ISceneNode ** pVal );
	[id( 14 ), helpstring( "Retrieves the geometry with the given name" )] HRESULT GetGeometry( [in] BSTR name, [out, retval] IGeometry ** pVal );
	[id( 15 ), helpstring( "Retrieves the light with the given name" )] HRESULT GetLight( [in] BSTR name, [out, retval] ILight ** pVal );
	[id( 16 ), helpstring( "Retrieves the camera with the given name" )] HRESULT GetCamera( [in] BSTR name, [out, retval] ICamera ** pVal );
	[id( 17 ), helpstring( "Removes the light with the given name" )] HRESULT RemoveLight( [in] ILight * light );
	[id( 18 ), helpstring( "Removes the scene node with the given name" )] HRESULT RemoveNode( [in] ISceneNode * node );
	[id( 19 ), helpstring( "Removes the geometry with the given name" )] HRESULT RemoveGeometry( [in] IGeometry * geometry );
	[id( 20 ), helpstring( "Removes the camera with the given name" )] HRESULT RemoveCamera( [in] ICamera * camera );
	[id( 21 ), helpstring( "Creates a mesh" )] HRESULT CreateMesh( [in] BSTR type, [in] BSTR name, [out, retval] IMesh ** pVal );
};

// IAnimation
[
	uuid( 242D6D0F-1470-4F0A-A7D0-9288E1D8856C ),
	helpstring( "Castor3D Animation interface" ),
	dual,
	oleautomation
]
interface IAnimation
	: IDispatch
{
};

// ISkeleton
[
	uuid( B9815090-EE8B-4FEB-91EE-B7D29C963B38 ),
	helpstring( "Castor3D Skeleton interface" ),
	dual,
	oleautomation
]
interface ISkeleton
	: IDispatch
{
};

// IMovableObject
[
	uuid( C0B3C2C4-365F-4E66-9520-FD95D45CA96C ),
	helpstring( "Castor3D MovableObject interface" ),
	dual,
	oleautomation
]
interface IMovableObject
	: IDispatch
{
	[propget, id( 1 ), helpstring( "The object name" )] HRESULT Name( [out, retval] BSTR * pVal );
	[propget, id( 2 ), helpstring( "The movable object type" )] HRESULT Type( [out, retval] eMOVABLE_TYPE * pVal );
	[propget, id( 3 ), helpstring( "The object's parent scene" )] HRESULT Scene( [out, retval] IScene ** pVal );
	[id( 4 ), helpstring( "Attaches the movable object to the given node" )] HRESULT AttachTo( [in] ISceneNode * val );
	[id( 5 ), helpstring( "Detaches the movable object from its parent node" )] HRESULT Detach();
};

// ILightCategory
[
	uuid( 65C7028B-1B92-4504-A5D8-909C28CC6C47 ),
	helpstring( "Castor3D LightCategory interface" ),
	dual,
	oleautomation
]
interface ILightCategory
	: IDispatch
{
	[propget, id( 1 ), helpstring( "The light colour" )] HRESULT Colour( [out, retval] IVector3D ** pVal );
	[propput, id( 1 ), helpstring( "The light colour" )] HRESULT Colour( [in] IVector3D * val );
	[propget, id( 3 ), helpstring( "The light diffuse intensity" )] HRESULT DiffuseIntensity( [out, retval] float * pVal );
	[propput, id( 3 ), helpstring( "The light diffuse intensity" )] HRESULT DiffuseIntensity( [in] float val );
	[propget, id( 4 ), helpstring( "The light specular intensity" )] HRESULT SpecularIntensity( [out, retval] float * pVal );
	[propput, id( 4 ), helpstring( "The light specular intensity" )] HRESULT SpecularIntensity( [in] float val );
};

// IDirectionalLight
[
	uuid( 96333EBA-90E9-4884-A56C-C65E60BF0C21 ),
	helpstring( "Castor3D DirectionalLight interface" ),
	dual,
	oleautomation
]
interface IDirectionalLight
	: IDispatch
{
};

// IPointLight
[
	uuid( D0DD3B04-6638-4B5C-991C-BB16447C2149 ),
	helpstring( "Castor3D PointLight interface" ),
	dual,
	oleautomation
]
interface IPointLight
	: IDispatch
{
	[propget, id( 2 ), helpstring( "The light attenuation values (constant, linear and quadratic)" )] HRESULT Attenuation( [out, retval] IVector3D ** pVal );
	[propput, id( 2 ), helpstring( "The light attenuation values (constant, linear and quadratic)" )] HRESULT Attenuation( [in] IVector3D * val );
};

// ISpotLight
[
	uuid( 08B2CE8A-04A2-4F35-AFA3-B96809F8685E ),
	helpstring( "Castor3D SpotLight interface" ),
	dual,
	oleautomation
]
interface ISpotLight
	: IDispatch
{
	[propget, id( 2 ), helpstring( "The light attenuation values (constant, linear and quadratic)" )] HRESULT Attenuation( [out, retval] IVector3D ** pVal );
	[propput, id( 2 ), helpstring( "The light attenuation values (constant, linear and quadratic)" )] HRESULT Attenuation( [in] IVector3D * val );
	[propget, id( 3 ), helpstring( "The light exponent value" )] HRESULT Exponent( [out, retval] float * pVal );
	[propput, id( 3 ), helpstring( "The light exponent value" )] HRESULT Exponent( [in] float val );
	[propget, id( 4 ), helpstring( "The light cut off value" )] HRESULT CutOff( [out, retval] IAngle ** pVal );
	[propput, id( 4 ), helpstring( "The light cut off value" )] HRESULT CutOff( [in] IAngle * val );
};

// ICamera
[
	uuid( 6E91B5E9-E5F9-4C04-8518-54F48DC39470 ),
	helpstring( "Castor3D Camera interface" ),
	dual,
	oleautomation
]
interface ICamera
	: IMovableObject
{
	[propget, id( 12 ), helpstring( "The camera viewport type" )] HRESULT ViewportType( [out, retval] eVIEWPORT_TYPE * pVal );
	[propput, id( 12 ), helpstring( "The camera viewport type" )] HRESULT ViewportType( [in] eVIEWPORT_TYPE val );
	[propget, id( 13 ), helpstring( "The camera horizontal resolution" )] HRESULT Width( [out, retval] unsigned int * pVal );
	[propget, id( 14 ), helpstring( "The camera vertical resolution" )] HRESULT Height( [out, retval] unsigned int * pVal );
	[id( 15 ), helpstring( "Changes the camera resolution" )] HRESULT Resize( [in] unsigned int width, [in] unsigned int height );
};

// ILight
[
	uuid( 9C79BC67-7FEC-4758-83C7-53F95B203878 ),
	helpstring( "Castor3D Light interface" ),
	dual,
	oleautomation
]
interface ILight
	: IMovableObject
{
	[propget, id( 11 ), helpstring( "The light type" )] HRESULT LightType( [out, retval] eLIGHT_TYPE * pVal );
	[propget, id( 12 ), helpstring( "The directional light category" )] HRESULT DirectionalLight( [out, retval] IDirectionalLight ** pVal );
	[propget, id( 13 ), helpstring( "The point light category" )] HRESULT PointLight( [out, retval] IPointLight ** pVal );
	[propget, id( 14 ), helpstring( "The spot light category" )] HRESULT SpotLight( [out, retval] ISpotLight ** pVal );
};

// IGeometry
[
	uuid( E1C7D856-CEBD-45BB-80DA-A6B50D4906CA ),
	helpstring( "Castor3D Geometry interface" ),
	dual,
	oleautomation
]
interface IGeometry
	: IMovableObject
{
	[propget, id( 11 ), helpstring( "The geometry's mesh" )] HRESULT Mesh( [out, retval] IMesh ** pVal );
	[propput, id( 11 ), helpstring( "The geometry's mesh" )] HRESULT Mesh( [in] IMesh * val );
	[id( 12 ), helpstring( "Retrieves the given submesh's material" )] HRESULT GetMaterial( [in] ISubmesh * submesh, [out, retval] IMaterial ** pVal );
	[id( 13 ), helpstring( "Defines the given submesh's material" )] HRESULT SetMaterial( [in] ISubmesh * submesh, [in] IMaterial * val );
};

// ISceneNode
[
	uuid( 6BDE5A33-7ACA-4CBA-BA25-795F9003F9A5 ),
	helpstring( "Castor3D SceneNode interface" ),
	dual,
	oleautomation
]
interface ISceneNode
	: IDispatch
{
	[propget, id( 1 ), helpstring( "The node position" )] HRESULT Position( [out, retval] IVector3D ** pVal );
	[propput, id( 1 ), helpstring( "The node position" )] HRESULT Position( [in] IVector3D * val );
	[propget, id( 2 ), helpstring( "The node orientation" )] HRESULT Orientation( [out, retval] IQuaternion ** pVal );
	[propput, id( 2 ), helpstring( "The node orientation" )] HRESULT Orientation( [in] IQuaternion * val );
	[propget, id( 3 ), helpstring( "The node scale" )] HRESULT Scaling( [out, retval] IVector3D ** pVal );
	[propput, id( 3 ), helpstring( "The node scale" )] HRESULT Scaling( [in] IVector3D * val );
	[id( 4 ), helpstring( "Attaches an object to the node" )] HRESULT AttachObject( [in] IMovableObject * val );
	[id( 5 ), helpstring( "Detaches an object from the node" )] HRESULT DetachObject( [in] IMovableObject * val );
	[id( 6 ), helpstring( "Attaches this node to another one" )] HRESULT AttachTo( [in] ISceneNode * val );
	[id( 7 ), helpstring( "Detaches this node from its parent" )] HRESULT Detach();
	[id( 8 ), helpstring( "Retrieves Y axis orientation" )] HRESULT Yaw( [in] IAngle * val );
	[id( 9 ), helpstring( "Retrieves X axis orientation" )] HRESULT Pitch( [in] IAngle * val );
	[id( 10 ), helpstring( "Retrieves Z axis orientation" )] HRESULT Roll( [in] IAngle * val );
	[id( 11 ), helpstring( "Rotates the node" )] HRESULT Rotate( [in] IQuaternion * val );
	[id( 12 ), helpstring( "Translates the node" )] HRESULT Translate( [in] IVector3D * val );
	[id( 13 ), helpstring( "Scales the node" )] HRESULT Scale( [in] IVector3D * val );
};

// IOverlayCategory
[
	uuid( 4AAADEFD-6698-45E4-BD2D-EEE7C43A1F65 ),
	helpstring( "Castor3D OverlayCategory interface" ),
	dual,
	oleautomation
]
interface IOverlayCategory
	: IDispatch
{
	[propget, id( 1 ), helpstring( "The overlay type" )] HRESULT Type( [out, retval] eOVERLAY_TYPE * pVal );
	[propget, id( 2 ), helpstring( "The overlay position, relative to its parent" )] HRESULT Position( [out, retval] IVector2D ** pVal );
	[propput, id( 2 ), helpstring( "The overlay position, relative to its parent" )] HRESULT Position( [in] IVector2D * val );
	[propget, id( 3 ), helpstring( "The overlay size, relative to its parent" )] HRESULT Size( [out, retval] IVector2D ** pVal );
	[propput, id( 3 ), helpstring( "The overlay size, relative to its parent" )] HRESULT Size( [in] IVector2D * val );
	[propget, id( 4 ), helpstring( "The overlay visibility" )] HRESULT Visible( [out, retval] boolean * pVal );
	[propput, id( 4 ), helpstring( "The overlay visibility" )] HRESULT Visible( [in] boolean * val );
	[propget, id( 5 ), helpstring( "The overlay z-index" )] HRESULT ZIndex( [out, retval] int * pVal );
	[propput, id( 5 ), helpstring( "The overlay z-index" )] HRESULT ZIndex( [in] int val );
	[propget, id( 6 ), helpstring( "The overlay material" )] HRESULT Material( [out, retval] IMaterial ** pVal );
	[propput, id( 6 ), helpstring( "The overlay material" )] HRESULT Material( [in] IMaterial * val );
};

// IPanelOverlay
[
	uuid( 0C35C9BA-56BE-4CB0-AEEC-6A337046B385 ),
	helpstring( "Castor3D PanelOverlay interface" ),
	dual,
	oleautomation
]
interface IPanelOverlay
	: IOverlayCategory
{
};

// IBorderPanelOverlay
[
	uuid( B5FC19FF-70E4-400E-8E2B-24339F0AEF71 ),
	helpstring( "Castor3D BorderPanelOverlay interface" ),
	dual,
	oleautomation
]
interface IBorderPanelOverlay
	: IOverlayCategory
{
	[propget, id( 11 ), helpstring( "The bottom border width" )] HRESULT LeftBorderSize( [out, retval] float * pVal );
	[propput, id( 11 ), helpstring( "The bottom border width" )] HRESULT LeftBorderSize( [in] float val );
	[propget, id( 12 ), helpstring( "The right border width" )] HRESULT RightBorderSize( [out, retval] float * pVal );
	[propput, id( 12 ), helpstring( "The right border width" )] HRESULT RightBorderSize( [in] float val );
	[propget, id( 13 ), helpstring( "The top border width" )] HRESULT TopBorderSize( [out, retval] float * pVal );
	[propput, id( 13 ), helpstring( "The top border width" )] HRESULT TopBorderSize( [in] float val );
	[propget, id( 14 ), helpstring( "The bottom border width" )] HRESULT BottomBorderSize( [out, retval] float * pVal );
	[propput, id( 14 ), helpstring( "The bottom border width" )] HRESULT BottomBorderSize( [in] float val );
	[propget, id( 15 ), helpstring( "The border material" )] HRESULT BorderMaterial( [out, retval] IMaterial ** pVal );
	[propput, id( 15 ), helpstring( "The border material" )] HRESULT BorderMaterial( [in] IMaterial * val );
};

// ITextOverlay
[
	uuid( 3B011483-3744-4B48-9363-BDD52A5F5D44 ),
	helpstring( "Castor3D TextOverlay interface" ),
	dual,
	oleautomation
]
interface ITextOverlay
	: IOverlayCategory
{
	[propget, id( 11 ), helpstring( "The text font" )] HRESULT Font( [out, retval] BSTR * pVal );
	[propput, id( 11 ), helpstring( "The text font" )] HRESULT Font( [in] BSTR val );
	[propget, id( 12 ), helpstring( "The text caption" )] HRESULT Caption( [out, retval] BSTR * pVal );
	[propput, id( 12 ), helpstring( "The text caption" )] HRESULT Caption( [in] BSTR val );
};

// IOverlay
[
	uuid( C29F0735-AC5D-4C68-A189-81FAA0AD0405 ),
	helpstring( "Castor3D Overlay interface" ),
	dual,
	oleautomation
]
interface IOverlay
	: IDispatch
{
	[propget, id( 1 ), helpstring( "The overlay name" )] HRESULT Name( [out, retval] BSTR * pVal );
	[propput, id( 1 ), helpstring( "The overlay name" )] HRESULT Name( [in] BSTR val );
	[propget, id( 2 ), helpstring( "The panel overlay category" )] HRESULT PanelOverlay( [out, retval] IPanelOverlay ** pVal );
	[propget, id( 3 ), helpstring( "The border panel overlay category" )] HRESULT BorderPanelOverlay( [out, retval] IBorderPanelOverlay ** pVal );
	[propget, id( 4 ), helpstring( "The text overlay category" )] HRESULT TextOverlay( [out, retval] ITextOverlay ** pVal );
	[id( 5 ), helpstring( "Retrieves the childs count" )] HRESULT GetChildsCount( [in] unsigned int * pVal );
	[id( 6 ), helpstring( "Adds a child" )] HRESULT AddChild( [in] IOverlay * overlay, [in] int zindex );
};

// IAnimable
[
	uuid( 18CB2526-98C6-4E19-932C-25264D419FFA ),
	helpstring( "Castor3D Animable interface" ),
	dual,
	oleautomation
]
interface IAnimable
	: IDispatch
{
	[id( 1 ), helpstring( "Retrieves the animation with the given name" )] HRESULT GetAnimation( [in] BSTR name, [out, retval] IAnimation ** anim );
	[id( 2 ), helpstring( "Creates an animation" )] HRESULT CreateAnimation( [in] BSTR name, [out, retval] IAnimation ** anim );
};

// IAnimatedObject
[
	uuid( 6F5C61B7-507C-4C5C-9463-368776C647D1 ),
	helpstring( "Castor3D AnimatedObject interface" ),
	dual,
	oleautomation
]
interface IAnimatedObject
	: IDispatch
{
	[propget, id( 1 ), helpstring( "The animable geometry" )] HRESULT Geometry( [out, retval] IGeometry ** pVal );
	[propput, id( 1 ), helpstring( "The animable geometry" )] HRESULT Geometry( [in] IGeometry * val );
	[propget, id( 2 ), helpstring( "The animable mesh" )] HRESULT Mesh( [out, retval] IMesh ** pVal );
	[propput, id( 2 ), helpstring( "The animable mesh" )] HRESULT Mesh( [in] IMesh * val );
	[propget, id( 3 ), helpstring( "The animable skeleton" )] HRESULT Skeleton( [out, retval] ISkeleton ** pVal );
	[propput, id( 3 ), helpstring( "The animable skeleton" )] HRESULT Skeleton( [in] ISkeleton * val );
	[id( 4 ), helpstring( "Retrieves the animation with given name" )] HRESULT getAnimation( [in] BSTR name, [out, retval] IAnimation ** anim );
	[id( 5 ), helpstring( "Starts all the animable animations" )] HRESULT StartAllAnimations();
	[id( 6 ), helpstring( "Stops all the animable animations" )] HRESULT StopAllAnimations();
	[id( 7 ), helpstring( "Pauses all the animable animations" )] HRESULT PauseAllAnimations();
	[id( 8 ), helpstring( "Starts the animation with given name" )] HRESULT StartAnimation( [in] BSTR name );
	[id( 9 ), helpstring( "Stops the animation with given name" )] HRESULT StopAnimation( [in] BSTR name );
	[id( 10 ), helpstring( "Pauses the animation with given name" )] HRESULT PauseAnimation( [in] BSTR name );
};

// IAnimatedObjectGroup
[
	uuid( E369A7E4-0E42-42B9-B541-CD23A20FCDC1 ),
	helpstring( "Castor3D AnimatedObjectGroup interface" ),
	dual,
	oleautomation
]
interface IAnimatedObjectGroup
	: IDispatch
{
	[propget, id( 1 ), helpstring( "Retrieves the animsations count" )] HRESULT AnimationCount( [out, retval] unsigned int * pVal );
	[propget, id( 2 ), helpstring( "Retrieves the animable objects count" )] HRESULT ObjectCount( [out, retval] unsigned int * pVal );
	[propget, id( 3 ), helpstring( "Retrieves the scene" )] HRESULT Scene( [out, retval] IScene ** anim );
	[id( 5 ), helpstring( "Retrieves the animable object with given name" )] HRESULT GetAnimableObject( [in] BSTR name, [out, retval] IAnimable ** obj );
	[id( 6 ), helpstring( "Starts all the animable animations" )] HRESULT StartAllAnimations();
	[id( 7 ), helpstring( "Stops all the animable animations" )] HRESULT StopAllAnimations();
	[id( 8 ), helpstring( "Pauses all the animable animations" )] HRESULT PauseAllAnimations();
	[id( 9 ), helpstring( "Starts the animation with given name" )] HRESULT StartAnimation( [in] BSTR name );
	[id( 10 ), helpstring( "Stops the animation with given name" )] HRESULT StopAnimation( [in] BSTR name );
	[id( 11 ), helpstring( "Pauses the animation with given name" )] HRESULT PauseAnimation( [in] BSTR name );
	[id( 12 ), helpstring( "Creates the animable object" )] HRESULT CreateObject( [in] BSTR name, [out, retval] IAnimable ** obj );
	[id( 13 ), helpstring( "Adds an animable object to the group" )] HRESULT AddObject( [in] IAnimable * obj, [out, retval] boolean * pVal );
	[id( 14 ), helpstring( "Adds an animation to the group" )] HRESULT AddAnimation( [in] BSTR name );
	[id( 15 ), helpstring( "Sets the animation loop status" )] HRESULT SetAnimationLooped( [in] BSTR name, [in] boolean val );
};

// IEngine
[
	uuid( 66132C94-BBD3-4C20-BADC-B8EB03E21E11 ),
	helpstring( "Castor3D Engine interface" ),
	dual,
	oleautomation
]
interface IEngine
	: IDispatch
{
	[propget, id( 1 ), helpstring( "Retrieves the plugins directory" )] HRESULT PluginsDirectory( [out, retval] BSTR * path );
	[propget, id( 2 ), helpstring( "Retrieves engine directory" )] HRESULT EngineDirectory( [out, retval] BSTR * path );
	[propget, id( 3 ), helpstring( "Retrieves data directory" )] HRESULT DataDirectory( [out, retval] BSTR * path );
	[id( 11 ), helpstring( "Creates the engine" )] HRESULT Create( [in] BSTR appName, [in] boolean enableValidation );
	[id( 12 ), helpstring( "Destroys the engine" )] HRESULT Destroy();
	[id( 13 ), helpstring( "Initialises the engine" )] HRESULT Initialise( [in] int fps );
	[id( 14 ), helpstring( "Cleans up the engine" )] HRESULT Cleanup();
	[id( 15 ), helpstring( "Creates a scene" )] HRESULT CreateScene( [in] BSTR name, [out, retval] IScene ** pVal );
	[id( 16 ), helpstring( "Cleans up the scenes" )] HRESULT ClearScenes();
	[id( 17 ), helpstring( "Loads a renderer" )] HRESULT LoadRenderer( [in] BSTR type );
	[id( 18 ), helpstring( "Renders a frame" )] HRESULT RenderOneFrame();
	[id( 19 ), helpstring( "Loads a plugin from its path" )] HRESULT LoadPlugin( [in] BSTR path );
	[id( 21 ), helpstring( "Creates an overlay" )] HRESULT CreateOverlay( [in] eOVERLAY_TYPE type, [in] BSTR name, [in] IOverlay * parent, [in] IScene * scene, [out, retval] IOverlay ** pVal );
	[id( 22 ), helpstring( "Creates a render window" )] HRESULT CreateRenderWindow( [in] BSTR name, [out, retval] IRenderWindow ** pVal );
	[id( 23 ), helpstring( "Removes a render window" )] HRESULT RemoveWindow( [in] IRenderWindow * val );
	[id( 24 ), helpstring( "Creates a sampler" )] HRESULT CreateSampler( [in] BSTR name, [out, retval] ISampler ** pVal );
	[id( 29 ), helpstring( "Removes the scene with the given name" )] HRESULT RemoveScene( [in] BSTR name );
	[id( 30 ), helpstring( "Loads a scene file" )] HRESULT LoadScene( [in] BSTR name, [out, retval] IRenderWindow ** window );
};

// Castor3DLib
[
	uuid( AE7400FF-58CB-40F5-9D8B-3373BCC45E54 ),
	version( 0.8 ),
	helpstring( "Castor3D interfaces" )
]
library Castor3D
{
	importlib( "stdole32.tlb" ); // Import libraries containing. 
	importlib( "stdole2.tlb" ); // standard COM API calls.

	// RgbaColour
	[
		uuid( 22125089-C34A-4C20-B8F9-07907A8AEA0D )
	]
	coclass RgbaColour
	{
		[default] interface IRgbaColour;
	};

	// RgbColour
	[
		uuid( 7D790705-5D16-4D1E-A557-957D6D4E01E7 )
	]
	coclass RgbColour
	{
		[default] interface IRgbColour;
	};

	// HdrRgbaColour
	[
		uuid( A25F52A6-5CF2-45F5-BED8-FB0294FCA339 )
	]
	coclass HdrRgbaColour
	{
		[default] interface IHdrRgbaColour;
	};

	// HdrRgbColour
	[
		uuid( 097DF712-996C-4E4B-89FB-9C0D06F42BE7 )
	]
	coclass HdrRgbColour
	{
		[default] interface IHdrRgbColour;
	};

	// Vector2D
	[
		uuid( 9A7B169B-06DF-4617-A93D-3EF10A4362F7 )
	]
	coclass Vector2D
	{
		[default] interface IVector2D;
	};

	// Vector3D
	[
		uuid( D406D2D9-865B-40CF-AB98-CA79F00C0797 )
	]
	coclass Vector3D
	{
		[default] interface IVector3D;
	};

	// Vector4D
	[
		uuid( EF3A4D20-DC85-493C-BBC3-0A17065CF17A )
	]
	coclass Vector4D
	{
		[default] interface IVector4D;
	};

	// Angle
	[
		uuid( 236D0939-4F04-4D7C-A8CD-1415F3CCBA71 )
	]
	coclass Angle
	{
		[default] interface IAngle;
	};

	// Quaternion
	[
		uuid( 7A301C67-36E2-483D-925A-62E3C5DBE871 )
	]
	coclass Quaternion
	{
		[default] interface IQuaternion;
	};

	// IMatrix4x4
	[
		uuid( 3353741E-3F82-4A99-B8DC-6D6AB0584E04 )
	]
	coclass Matrix4x4
	{
		[default] interface IMatrix4x4;
	};

	// Position
	[
		uuid( 2C6A4321-6187-436B-9B31-4B340D1C6507 )
	]
	coclass Position
	{
		[default] interface IPosition;
	};

	// Size
	[
		uuid( 3F1B36E8-4E97-403C-B2F3-25267C23A7FD )
	]
	coclass Size
	{
		[default] interface ISize;
	};

	// Rect
	[
		uuid( A1C8B71D-D5BC-4664-9058-1EE9F964BFF7 )
	]
	coclass Rect
	{
		[default] interface IRect;
	};

	// Glyph
	[
		uuid( E8EB965B-EB5E-413D-B119-FADC081C8AD9 )
	]
	coclass Glyph
	{
		[default] interface IGlyph;
	};

	// Font
	[
		uuid( 814FF4F4-8FFC-4048-A972-6EF3DA5314E1 )
	]
	coclass Font
	{
		[default] interface ICastorFont;
	};

	// PixelBuffer
	[
		uuid( D2F8DD56-82D0-4467-9AB4-61F3BB228ACC )
	]
	coclass PixelBuffer
	{
		[default] interface IPixelBuffer;
	};

	// Image
	[
		uuid( 032154A9-2E6F-4FEE-A132-5840EEEC21FD )
	]
	coclass Image
	{
		[default] interface IImage;
	};

	// Logger
	[
		uuid( A39A1B4B-9882-4B2E-AB1D-55257AF40727 )
	]
	coclass Logger
	{
		[default] interface ILogger;
	};

	// Sampler
	[
		uuid( 98978C6B-C6FB-447C-A874-15068F900011 )
	]
	coclass Sampler
	{
		[default] interface ISampler;
	}

	// TextureView
	[
		uuid( 3CA68187-BD17-4E78-8D5C-B994DDA134BA )
	]
	coclass TextureView
	{
		[default] interface ITextureView;
	}

	// TextureLayout
	[
		uuid( 0FF08968-9937-4771-8949-0E86E3615F98 )
	]
	coclass TextureLayout
	{
		[default] interface ITextureLayout;
	}

	// TextureUnit
	[
		uuid( E8DD6F29-F296-4687-AADD-F6FD1D0AC670 )
	]
	coclass TextureUnit
	{
		[default] interface ITextureUnit;
	}

	// Pass
	[
		uuid( 1B6D6829-C5D7-4B75-8A92-E016C63147B3 )
	]
	coclass Pass
	{
		[default] interface IPass;
	}

	// LegacyPass
	[
		uuid( 2A4B5235-063A-454B-860C-CA91ED042E2D )
	]
	coclass LegacyPass
	{
		[default] interface ILegacyPass;
	}

	// MetallicRoughnessPbrPass
	[
		uuid( 20C67D15-677C-43DE-98B5-E328293740AF )
	]
	coclass MetallicRoughnessPbrPass
	{
		[default] interface IMetallicRoughnessPbrPass;
	}

	// SpecularGlossinessPass
	[
		uuid( 5ED10C5B-248B-427A-818F-C4F94A5FA54F )
	]
	coclass SpecularGlossinessPbrPass
	{
		[default] interface ISpecularGlossinessPbrPass;
	}

	// Material
	[
		uuid( A9F3E2A5-A54C-4E4A-8448-0A663BE88E40 )
	]
	coclass Material
	{
		[default] interface IMaterial;
	}

	// IndexMapping
	[
		uuid( 56FAEA93-D2BC-4845-9F7C-A225044C7626 )
	]
	coclass IndexMapping
	{
		[default] interface IIndexMapping;
	}

	// TriFaceMapping
	[
		uuid( 3357AAE2-E50A-47AB-A0FE-83833CE2944C )
	]
	coclass TriFaceMapping
	{
		[default] interface ITriFaceMapping;
	}

	// LinesMapping
	[
		uuid( 93151A09-8DC0-491F-BCDE-1B58954B97C2 )
	]
	coclass LinesMapping
	{
		[default] interface ILinesMapping;
	}

	// Submesh
	[
		uuid( E59360F1-2F5B-4011-A61F-32E1A77207C8 )
	]
	coclass Submesh
	{
		[default] interface ISubmesh;
	};

	// Mesh
	[
		uuid( C5053069-A376-4E0E-AA0A-5CCE3A78C205 )
	]
	coclass Mesh
	{
		[default] interface IMesh;
	};

	// MovableObject
	[
		uuid( C36B1CB1-9623-4DE9-B5D8-108AC6D32D54 )
	]
	coclass MovableObject
	{
		[default] interface IMovableObject;
	};

	// LightCategory
	[
		uuid( 9C77B39B-EAD2-4EDB-815E-1B74B1F8B5C3 )
	]
	coclass LightCategory
	{
		[default] interface ILightCategory;
	};

	// DirectionalLight
	[
		uuid( F0FC01FC-2C13-40C0-A07F-9B913181264B )
	]
	coclass DirectionalLight
	{
		[default] interface IDirectionalLight;
	};

	// PointLight
	[
		uuid( 3581BE19-66C5-407B-8E7E-C761424C5974 )
	]
	coclass PointLight
	{
		[default] interface IPointLight;
	};

	// SpotLight
	[
		uuid( 0819BA84-8671-454B-B9A3-84C8A3C5DB95 )
	]
	coclass SpotLight
	{
		[default] interface ISpotLight;
	};

	// Camera
	[
		uuid( 823F16E0-606C-46C7-8B22-8B5C907B4E48 )
	]
	coclass Camera
	{
		[default] interface ICamera;
	};

	// Light
	[
		uuid( 7499D2D6-4275-4816-B25E-042CC75C566E )
	]
	coclass Light
	{
		[default] interface ILight;
	};

	// Geometry
	[
		uuid( 0F08578A-FD57-4F6F-8CB5-26E5C1CBA88A )
	]
	coclass Geometry
	{
		[default] interface IGeometry;
	};

	// SceneNode
	[
		uuid( 665CE022-156D-4C04-B621-35CB66A6D6D4 )
	]
	coclass SceneNode
	{
		[default] interface ISceneNode;
	};

	// OverlayCategory
	[
		uuid( 0A9CE856-F576-41EF-A6F0-C27291C6C2D2 )
	]
	coclass OverlayCategory
	{
		[default] interface IOverlayCategory;
	};

	// PanelOverlay
	[
		uuid( B5AD045F-0EDE-46F9-8AF0-381FBDB62385 )
	]
	coclass PanelOverlay
	{
		[default] interface IPanelOverlay;
	};

	// BorderPanelOverlay
	[
		uuid( 147C4638-20C2-46AC-8765-B67F0128BC4A )
	]
	coclass BorderPanelOverlay
	{
		[default] interface IBorderPanelOverlay;
	};

	// TextOverlay
	[
		uuid( 287EAF30-2165-49AC-BC96-8CF568D28CAE )
	]
	coclass TextOverlay
	{
		[default] interface ITextOverlay;
	};

	// Overlay
	[
		uuid( CA66D170-B96A-4910-83D5-D622E9A813F7 )
	]
	coclass Overlay
	{
		[default] interface IOverlay;
	};

	// Animable
	[
		uuid( F9185125-9460-4039-A0B0-EB2295AC6AB1 )
	]
	coclass Animable
	{
		[default] interface IAnimable;
	};

	// AnimatedObject
	[
		uuid( F31A778F-F9E5-4619-A35B-2EE8325BF1D2 )
	]
	coclass AnimatedObject
	{
		[default] interface IAnimatedObject;
	};

	// AnimatedObjectGroup
	[
		uuid( 7180F914-17E1-45A1-A2AB-F195F0724AD7 )
	]
	coclass AnimatedObjectGroup
	{
		[default] interface IAnimatedObjectGroup;
	};

	// SceneBackground
	[
		uuid( 5CA94585-1FBC-466A-8A59-90733AD8DF1D )
	]
	coclass SceneBackground
	{
		[default] interface ISceneBackground;
	};

	// ColourBackground
	[
		uuid( F75EA477-3EFF-4254-B995-32A606A861F8 )
	]
	coclass ColourBackground
	{
		[default] interface IColourBackground;
	};

	// ImageBackground
	[
		uuid( 829D988E-BE04-421D-BE4B-DCE72A6C1E4E )
	]
	coclass ImageBackground
	{
		[default] interface IImageBackground;
	};

	// SkyboxBackground
	[
		uuid( 391A6B49-95D3-4B92-ACFC-058083FC06D2 )
	]
	coclass SkyboxBackground
	{
		[default] interface ISkyboxBackground;
	};

	// Scene
	[
		uuid( C2669704-BF96-4D28-9627-7E625EA2EC99 )
	]
	coclass Scene
	{
		[default] interface IScene;
	};

	// Animation
	[
		uuid( 5B26DE5C-FFE8-42AE-A07C-837D5164CAFE )
	]
	coclass Animation
	{
		[default] interface IAnimation;
	};

	// Skeleton
	[
		uuid( 53A552B5-8524-4DDD-987C-AC68AA87233E )
	]
	coclass Skeleton
	{
		[default] interface ISkeleton;
	};

	// RenderWindow
	[
		uuid( AD82930D-4682-4CF1-B9E8-EDFD869E7AF7 )
	]
	coclass RenderTarget
	{
		[default] interface IRenderTarget;
	};

	// RenderWindow
	[
		uuid( 68E4373D-24BB-45FE-9717-CB512111A984 )
	]
	coclass RenderWindow
	{
		[default] interface IRenderWindow;
	};

	// Engine
	[
		uuid( 557E0DD9-00E5-48A2-AE26-B78CC6031956 )
	]
	coclass Engine
	{
		[default] interface IEngine;
	};
}
