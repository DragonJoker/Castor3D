// This file will be processed by the MIDL tool to
// produce the type library (Castor3D.tlb) and marshalling code.

import "oaidl.idl";
import "ocidl.idl";

// eLOG_TYPE
[
	uuid( EC3C4DA0-439C-4CD0-A879-001377785B0A )
]
typedef enum
{
	eLOG_TYPE_DEBUG,
	eLOG_TYPE_MESSAGE,
	eLOG_TYPE_WARNING,
	eLOG_TYPE_ERROR,
	eLOG_TYPE_COUNT,
}	eLOG_TYPE;

// eINTERSECTION
[
	uuid( 906BC7B0-9600-4A6D-904B-55135066E57B )
]
typedef enum
{
	eINTERSECTION_IN,
	eINTERSECTION_OUT,
	eINTERSECTION_INTERSECT,
	eINTERSECTION_COUNT,
}	eINTERSECTION;

// ePIXEL_FORMAT
[
	uuid( A6264911-DB89-4B0B-902B-69E79A943979 )
]
typedef enum
{
	ePIXEL_FORMAT_L8,			//!< 8 bits luminosity
	ePIXEL_FORMAT_L16F32F,		//!< Half floats luminosity on GPU, floats luminosity on CPU
	ePIXEL_FORMAT_L32F,			//!< Floats luminosity on CPU
	ePIXEL_FORMAT_A8L8,			//!< 16 bits alpha and luminosity
	ePIXEL_FORMAT_AL16F32F,		//!< Half floats alpha and luminosity on GPU, floats alpha and luminosity on CPU
	ePIXEL_FORMAT_AL32F,		//!< Floats alpha and luminosity on CPU
	ePIXEL_FORMAT_A1R5G5B5,		//!< 16 bits 5551 ARGB
	ePIXEL_FORMAT_A4R4G4B4,		//!< 16 bits 4444 ARGB
	ePIXEL_FORMAT_R5G6B5,		//!< 16 bits 565 RGB
	ePIXEL_FORMAT_R8G8B8,		//!< 24 bits 888 RGB
	ePIXEL_FORMAT_B8G8R8,		//!< 24 bits 888 BGR
	ePIXEL_FORMAT_A8R8G8B8,		//!< 32 bits 8888 ARGB
	ePIXEL_FORMAT_A8B8G8R8,		//!< 32 bits 8888 ABGR
	ePIXEL_FORMAT_RGB16F32F,	//!< Half float RGB on GPU, Float RGB on CPU
	ePIXEL_FORMAT_ARGB16F32F,	//!< Half float ARGB on GPU, Float ARGB on CPU
	ePIXEL_FORMAT_RGB32F,		//!< Float RGB
	ePIXEL_FORMAT_ARGB32F,		//!< Float ARGB
	ePIXEL_FORMAT_DXTC1,		//!< DXT1 8 bits compressed format
	ePIXEL_FORMAT_DXTC3,		//!< DXT3 16 bits compressed format
	ePIXEL_FORMAT_DXTC5,		//!< DXT5 16 bits compressed format
	ePIXEL_FORMAT_YUY2,			//!< YUY2 16 bits compressed format
	ePIXEL_FORMAT_DEPTH16,		//!< Depth 16 bits
	ePIXEL_FORMAT_DEPTH24,		//!< Depth 24 bits
	ePIXEL_FORMAT_DEPTH24S8,	//!< Depth 24 bits, Stencil 8 bits
	ePIXEL_FORMAT_DEPTH32,		//!< Depth 32 bits
	ePIXEL_FORMAT_STENCIL1,		//!< Stencil 1 bit
	ePIXEL_FORMAT_STENCIL8,		//!< Stencil 8 bits
	ePIXEL_FORMAT_COUNT,
}	ePIXEL_FORMAT;

// eRENDERER_TYPE
[
	uuid( 30F8D353-04EA-4041-A67C-C421945DF1D2 )
]
typedef enum
{
	eRENDERER_TYPE_OPENGL,
	eRENDERER_TYPE_DIRECT3D,
}	eRENDERER_TYPE;

// eMESH_TYPE
[
	uuid( D90AA81E-6407-47D0-BC77-23823381B71E )
]
typedef enum
{
	eMESH_TYPE_CUSTOM,
	eMESH_TYPE_CONE,
	eMESH_TYPE_CYLINDER,
	eMESH_TYPE_SPHERE,
	eMESH_TYPE_CUBE,
	eMESH_TYPE_TORUS,
	eMESH_TYPE_PLANE,
	eMESH_TYPE_ICOSAHEDRON,
	eMESH_TYPE_PROJECTION,
}	eMESH_TYPE;

// eLIGHT_TYPE
[
	uuid( 084CFBD9-923F-40AD-8008-0BF71D274051 )
]
typedef enum
{
	eLIGHT_TYPE_DIRECTIONAL,
	eLIGHT_TYPE_POINT,
	eLIGHT_TYPE_SPOT,
}	eLIGHT_TYPE;

// eMOVABLE_TYPE
[
	uuid( 8A15F144-5401-40C1-BF16-126783598F51 )
]
typedef enum
{
	eMOVABLE_TYPE_CAMERA,
	eMOVABLE_TYPE_GEOMETRY,
	eMOVABLE_TYPE_LIGHT,
	eMOVABLE_TYPE_BILLBOARD,
}	eMOVABLE_TYPE;

// eOVERLAY_TYPE
[
	uuid( A6E2293D-371E-4D83-9075-02778A546FA5 )
]
typedef enum
{
	eOVERLAY_TYPE_PANEL,
	eOVERLAY_TYPE_BORDER_PANEL,
	eOVERLAY_TYPE_TEXT,
}	eOVERLAY_TYPE;

// eTEXT_WRAPPING_MODE
[
	uuid( 41DE0D68-CE43-4601-8B75-63D193E2A74C )
]
typedef enum
{
	eTEXT_WRAPPING_MODE_NONE,
	eTEXT_WRAPPING_MODE_BREAK,
	eTEXT_WRAPPING_MODE_BREAK_WORDS,
}	eTEXT_WRAPPING_MODE;

// eHALIGN
[
	uuid( CD545DC8-E7DC-4DBC-B32C-6368E9B83C21 )
]
typedef enum
{
	eHALIGN_LEFT,
	eHALIGN_CENTER,
	eHALIGN_RIGHT,
}	eHALIGN;

// eVALIGN
[
	uuid( 8C88E7EE-6D8F-4E30-9663-98BD86ED9DF9 )
]
typedef enum
{
	eVALIGN_TOP,
	eVALIGN_CENTER,
	eVALIGN_BOTTOM,
}	eVALIGN;

// eBORDER_POSITION
[
	uuid( B78BF8F8-8A36-4AB4-B8C8-3AE85D9FD3F0 )
]
typedef enum
{
	eBORDER_POSITION_INTERNAL,
	eBORDER_POSITION_MIDDLE,
	eBORDER_POSITION_EXTERNAL,
}	eBORDER_POSITION;

// eVIEWPORT_TYPE
[
	uuid( A4D87FE1-238D-4CE5-9458-6923F4196875 )
]
typedef enum
{
	eVIEWPORT_TYPE_ORTHO,
	eVIEWPORT_TYPE_PERSPECTIVE,
	eVIEWPORT_TYPE_FRUSTUM,
	eVIEWPORT_TYPE_COUNT,
}	eVIEWPORT_TYPE;

// eTOPOLOGY
[
	uuid( 02DDE08E-075A-4047-9F32-44B0DE80257D )
]
typedef enum
{
	eTOPOLOGY_POINTS,
	eTOPOLOGY_LINES,
	eTOPOLOGY_LINE_LOOP,
	eTOPOLOGY_LINE_STRIP,
	eTOPOLOGY_TRIANGLES,
	eTOPOLOGY_TRIANGLE_STRIPS,
	eTOPOLOGY_TRIANGLE_FAN,
	eTOPOLOGY_QUADS,
	eTOPOLOGY_QUAD_STRIPS,
	eTOPOLOGY_POLYGON,
}	eTOPOLOGY;

// ePROJECTION_DIRECTION
[
	uuid( CA9AAB5D-C834-4C7A-A854-67EEB124DC4C )
]
typedef enum
{
	ePROJECTION_DIRECTION_FRONT,
	ePROJECTION_DIRECTION_BACK,
	ePROJECTION_DIRECTION_LEFT,
	ePROJECTION_DIRECTION_RIGHT,
	ePROJECTION_DIRECTION_TOP,
	ePROJECTION_DIRECTION_BOTTOM,
}	ePROJECTION_DIRECTION;

// eTEXTURE_CHANNEL
[
	uuid( C0F75923-E03E-49B7-B7C9-EFAC55630B7F )
]
typedef enum
{
	eTEXTURE_CHANNEL_COLOUR = 0x00000001,	//!< Colour map
	eTEXTURE_CHANNEL_DIFFUSE = 0x00000002,	//!< Diffuse map
	eTEXTURE_CHANNEL_NORMAL = 0x00000004,	//!< Normal map
	eTEXTURE_CHANNEL_OPACITY = 0x00000008,	//!< Opacity map
	eTEXTURE_CHANNEL_SPECULAR = 0x00000010,	//!< Specular map
	eTEXTURE_CHANNEL_HEIGHT = 0x00000020,	//!< Height map
	eTEXTURE_CHANNEL_AMBIENT = 0x00000040,	//!< Ambient map
	eTEXTURE_CHANNEL_GLOSS = 0x00000080,	//!< Gloss map
	eTEXTURE_CHANNEL_ALL,
}	eTEXTURE_CHANNEL;

// eRGB_BLEND_FUNC
[
	uuid( 1A330154-AE9E-44E0-865F-BA0661671228 )
]
typedef enum
{
	eRGB_BLEND_FUNC_NONE,
	eRGB_BLEND_FUNC_FIRST_ARG,
	eRGB_BLEND_FUNC_ADD,
	eRGB_BLEND_FUNC_ADD_SIGNED,
	eRGB_BLEND_FUNC_MODULATE,
	eRGB_BLEND_FUNC_INTERPOLATE,
	eRGB_BLEND_FUNC_SUBTRACT,
	eRGB_BLEND_FUNC_DOT3_RGB,
	eRGB_BLEND_FUNC_DOT3_RGBA,
}	eRGB_BLEND_FUNC;

// eALPHA_BLEND_FUNC
[
	uuid( CF775A66-A035-449A-BEE1-E7F4B8070A9C )
]
typedef enum
{
	eALPHA_BLEND_FUNC_NONE,
	eALPHA_BLEND_FUNC_FIRST_ARG,
	eALPHA_BLEND_FUNC_ADD,
	eALPHA_BLEND_FUNC_ADD_SIGNED,
	eALPHA_BLEND_FUNC_MODULATE,
	eALPHA_BLEND_FUNC_INTERPOLATE,
	eALPHA_BLEND_FUNC_SUBSTRACT,
}	eALPHA_BLEND_FUNC;

// eBLEND_SOURCE
[
	uuid( 312C3EA5-F1C9-4192-B675-3CCFFFFDAAB4 )
]
typedef enum
{
	eBLEND_SOURCE_TEXTURE,
	eBLEND_SOURCE_TEXTURE0,
	eBLEND_SOURCE_TEXTURE1,
	eBLEND_SOURCE_TEXTURE2,
	eBLEND_SOURCE_TEXTURE3,
	eBLEND_SOURCE_CONSTANT,
	eBLEND_SOURCE_DIFFUSE,
	eBLEND_SOURCE_PREVIOUS,
}	eBLEND_SOURCE;

// eALPHA_FUNC
[
	uuid( 64B09ACE-F388-40FE-83BE-DB4A85BCB84E )
]
typedef enum
{
	eALPHA_FUNC_ALWAYS,
	eALPHA_FUNC_LESS,
	eALPHA_FUNC_LESS_OR_EQUAL,
	eALPHA_FUNC_EQUAL,
	eALPHA_FUNC_NOT_EQUAL,
	eALPHA_FUNC_GREATER_OR_EQUAL,
	eALPHA_FUNC_GREATER,
	eALPHA_FUNC_NEVER,
}	eALPHA_FUNC;

// eTEXTURE_TYPE
[
	uuid( 7B89A147-BC55-40AC-B720-435B74348074 )
]
typedef enum
{
	eTEXTURE_TYPE_BUFFER,
	eTEXTURE_TYPE_1D,
	eTEXTURE_TYPE_1DARRAY,
	eTEXTURE_TYPE_2D,
	eTEXTURE_TYPE_2DARRAY,
	eTEXTURE_TYPE_2DMS,
	eTEXTURE_TYPE_2DMSARRAY,
	eTEXTURE_TYPE_3D,
	eTEXTURE_TYPE_CUBE,
	eTEXTURE_TYPE_CUBEARRAY,
	eTEXTURE_TYPE_COUNT,
}	eTEXTURE_TYPE;

// eINTERPOLATION_MODE
[
	uuid( D569C3E8-B4C6-454C-AB73-836D2D0489C3 )
]
typedef enum
{
	eINTERPOLATION_MODE_UNDEFINED,
	eINTERPOLATION_MODE_NEAREST,
	eINTERPOLATION_MODE_LINEAR,
	eINTERPOLATION_MODE_COUNT,
}	eINTERPOLATION_MODE;

// eWRAP_MODE
[
	uuid( 7F174FD6-49BC-4430-B8BB-1448FCD393D6 )
]
typedef enum
{
	eWRAP_MODE_REPEAT,
	eWRAP_MODE_MIRRORED_REPEAT,
	eWRAP_MODE_CLAMP_TO_BORDER,
	eWRAP_MODE_CLAMP_TO_EDGE,
	eWRAP_MODE_COUNT,
}	eWRAP_MODE;

// eINTERPOLATION_FILTER
[
	uuid( 3C873590-292E-4229-992A-95EAA46EC353 )
]
typedef enum
{
	eINTERPOLATION_FILTER_MIN,
	eINTERPOLATION_FILTER_MAG,
	eINTERPOLATION_FILTER_MIP,
	eINTERPOLATION_FILTER_COUNT,
}	eINTERPOLATION_FILTER;

// eBLEND_OP
[
	uuid( 3AAC5392-A4B1-467B-9CFA-1ADEE49FE94A )
]
typedef enum
{
	eBLEND_OP_ADD,
	eBLEND_OP_SUBSTRACT,
	eBLEND_OP_REV_SUBSTRACT,
	eBLEND_OP_MIN,
	eBLEND_OP_MAX,
}	eBLEND_OP;

// eBLEND
[
	uuid( 6795B6CF-D15D-46AC-AB59-E3151ECBDA14 )
]
typedef enum
{
	eBLEND_ZERO,
	eBLEND_ONE,
	eBLEND_SRC_COLOUR,
	eBLEND_INV_SRC_COLOUR,
	eBLEND_DST_COLOUR,
	eBLEND_INV_DST_COLOUR,
	eBLEND_SRC_ALPHA,
	eBLEND_INV_SRC_ALPHA,
	eBLEND_DST_ALPHA,
	eBLEND_INV_DST_ALPHA,
	eBLEND_CONSTANT,
	eBLEND_INV_CONSTANT,
	eBLEND_SRC_ALPHA_SATURATE,
	eBLEND_SRC1_COLOUR,
	eBLEND_INV_SRC1_COLOUR,
	eBLEND_SRC1_ALPHA,
	eBLEND_INV_SRC1_ALPHA,
}	eBLEND;

// eDEPTH_FUNC
[
	uuid( 540E7F7C-6E6D-4C09-85F3-62237E92DC8E )
]
typedef enum
{
	eDEPTH_FUNC_NEVER,
	eDEPTH_FUNC_LESS,
	eDEPTH_FUNC_EQUAL,
	eDEPTH_FUNC_LEQUAL,
	eDEPTH_FUNC_GREATER,
	eDEPTH_FUNC_NOTEQUAL,
	eDEPTH_FUNC_GEQUAL,
	eDEPTH_FUNC_ALWAYS,
}	eDEPTH_FUNC;

// eWRITING_MASK
[
	uuid( F2BE12B9-AECB-430A-8542-9BE953559A1E )
]
typedef enum
{
	eWRITING_MASK_ZERO,
	eWRITING_MASK_ALL,
}	eWRITING_MASK;

// eSTENCIL_FUNC
[
	uuid( 479C15A3-B00E-462F-89FD-C3D1DBAE7BDE )
]
typedef enum
{
	eSTENCIL_FUNC_NEVER,
	eSTENCIL_FUNC_LESS,
	eSTENCIL_FUNC_EQUAL,
	eSTENCIL_FUNC_LEQUAL,
	eSTENCIL_FUNC_GREATER,
	eSTENCIL_FUNC_NOTEQUAL,
	eSTENCIL_FUNC_GEQUAL,
	eSTENCIL_FUNC_ALWAYS,
}	eSTENCIL_FUNC;

// eSTENCIL_OP
[
	uuid( 274FBB17-6AD8-4EF5-AA05-239E9C327E86 )
]
typedef enum
{
	eSTENCIL_OP_KEEP,
	eSTENCIL_OP_ZERO,
	eSTENCIL_OP_REPLACE,
	eSTENCIL_OP_INCR,
	eSTENCIL_OP_INCR_WRAP,
	eSTENCIL_OP_DECR,
	eSTENCIL_OP_DECR_WRAP,
	eSTENCIL_OP_INVERT,
}	eSTENCIL_OP;

// eFILL_MODE
[
	uuid( 7C2540A8-298D-4170-89A7-7D5CBF61A126 )
]
typedef enum
{
	eFILL_MODE_POINT,
	eFILL_MODE_LINE,
	eFILL_MODE_SOLID,
}	eFILL_MODE;

// eFACE
[
	uuid( C41A62D1-AC5F-4A2B-A902-9621F680FAF2 )
]
typedef enum
{
	eFACE_NONE,
	eFACE_FRONT,
	eFACE_BACK,
	eFACE_FRONT_AND_BACK,
}	eFACE;

// eSHADER_TYPE
[
	uuid( D2095EB6-4629-4764-BA23-CDBC7359084A )
]
typedef enum
{
	eSHADER_TYPE_NONE = -1,
	eSHADER_TYPE_VERTEX,
	eSHADER_TYPE_HULL,
	eSHADER_TYPE_DOMAIN,
	eSHADER_TYPE_GEOMETRY,
	eSHADER_TYPE_PIXEL,
	eSHADER_TYPE_COMPUTE,
}	eSHADER_TYPE;

// eSHADER_MODEL
[
	uuid( B5F87E8B-A8FD-44D8-8C6E-C4ADBA9B2C64 )
]
typedef enum
{
	eSHADER_MODEL_1,
	eSHADER_MODEL_2,
	eSHADER_MODEL_3,
	eSHADER_MODEL_4,
	eSHADER_MODEL_5,
}	eSHADER_MODEL;

interface IColour;
interface IVector2D;
interface IVector3D;
interface IAngle;
interface IQuaternion;
interface IMatrix4x4;
interface IPosition;
interface ISize;
interface IRect;
interface IGlyph;
interface ICastorFont;
interface IPixelBuffer;
interface IImage;
interface ILogger;

interface ISubmesh;
interface IMesh;
interface IMovableObject;
interface ILightCategory;
interface IDirectionalLight;
interface IPointLight;
interface ISpotLight;
interface ICamera;
interface ILight;
interface IGeometry;
interface ISceneNode;
interface IOverlayCategory;
interface IPanelOverlay;
interface IBorderPanelOverlay;
interface ITextOverlay;
interface IOverlay;
interface IAnimable;
interface IAnimatedObject;
interface IAnimatedObjectGroup;
interface ITextureImage;
interface ITextureLayout;
interface ITextureUnit;
interface IPass;
interface IMaterial;
interface IEngine;
interface IAnimation;
interface IBone;
interface ISkeleton;
interface IScene;

// IColour
[
	uuid( CC83C7E1-7669-431D-B174-FB224CD9F0D6 ),
	helpstring( "RGBA Colour interface" ),
	dual,
	oleautomation
]
interface IColour
	: IDispatch
{
	// Properties
	[propget, id( 1 ), helpstring( "The red value" )] HRESULT R( [out, retval] float * pVal );
	[propput, id( 1 ), helpstring( "The red value" )] HRESULT R( [in] float val );
	[propget, id( 2 ), helpstring( "The green value" )] HRESULT G( [out, retval] float * pVal );
	[propput, id( 2 ), helpstring( "The green value" )] HRESULT G( [in] float val );
	[propget, id( 3 ), helpstring( "The blue value" )] HRESULT B( [out, retval] float * pVal );
	[propput, id( 3 ), helpstring( "The blue value" )] HRESULT B( [in] float val );
	[propget, id( 4 ), helpstring( "The alpha value" )] HRESULT A( [out, retval] float * pVal );
	[propput, id( 4 ), helpstring( "The alpha value" )] HRESULT A( [in] float val );
};

// IVector2D
[
	uuid( B068FB7C-535D-4179-8C58-4E900E1D3265 ),
	helpstring( "2D Vector interface" ),
	dual,
	oleautomation
]
interface IVector2D
	: IDispatch
{
	// Properties
	[propget, id( 1 ), helpstring( "The X coordinate" )] HRESULT X( [out, retval] float * pVal );
	[propput, id( 1 ), helpstring( "The X coordinate" )] HRESULT X( [in] float val );
	[propget, id( 2 ), helpstring( "The Y coordinate" )] HRESULT Y( [out, retval] float * pVal );
	[propput, id( 2 ), helpstring( "The Y coordinate" )] HRESULT Y( [in] float val );
	// Methods
	[id( 4 ), helpstring( "Negates each coordinate" )] HRESULT Negate();
	[id( 5 ), helpstring( "Modifies Vector to make its length equal to 1" )] HRESULT Normalise();
	[id( 6 ), helpstring( "Scalar product" )] HRESULT Dot( [in] IVector2D * val, [out, retval] float * pRet );
	[id( 8 ), helpstring( "The vector length" )] HRESULT Length( [out, retval] float * pVal );
};

// IVector3D
[
	uuid( D57AB8FD-6CD1-4271-AFC8-C687A2208637 ),
	helpstring( "3D Vector interface" ),
	dual,
	oleautomation
]
interface IVector3D
	: IDispatch
{
	// Properties
	[propget, id( 1 ), helpstring( "The X coordinate" )] HRESULT X( [out, retval] float * pVal );
	[propput, id( 1 ), helpstring( "The X coordinate" )] HRESULT X( [in] float val );
	[propget, id( 2 ), helpstring( "The Y coordinate" )] HRESULT Y( [out, retval] float * pVal );
	[propput, id( 2 ), helpstring( "The Y coordinate" )] HRESULT Y( [in] float val );
	[propget, id( 3 ), helpstring( "The Z coordinate" )] HRESULT Z( [out, retval] float * pVal );
	[propput, id( 3 ), helpstring( "The Z coordinate" )] HRESULT Z( [in] float val );
	// Methods
	[id( 4 ), helpstring( "Negates each coordinate" )] HRESULT Negate();
	[id( 5 ), helpstring( "Modifies Vector to make its length equal to 1" )] HRESULT Normalise();
	[id( 6 ), helpstring( "Scalar product" )] HRESULT Dot( [in] IVector3D * val, [out, retval] float * pRet );
	[id( 7 ), helpstring( "Cross product" )] HRESULT Cross( [in] IVector3D * val, [out, retval] IVector3D ** pRet );
	[id( 8 ), helpstring( "The vector length" )] HRESULT Length( [out, retval] float * pVal );
};

// IAngle
[
	uuid( 8C61B6CB-616A-4B2F-92BE-5A00511233EF ),
	helpstring( "Angle interface" ),
	dual,
	oleautomation
]
interface IAngle
	: IDispatch
{
	[propget, id( 1 ), helpstring( "The degrees value for the angle" )] HRESULT Degrees( [out, retval] float * pVal );
	[propput, id( 1 ), helpstring( "The degrees value for the angle" )] HRESULT Degrees( [in] float val );
	[propget, id( 2 ), helpstring( "The radians value for the angle" )] HRESULT Radians( [out, retval] float * pVal );
	[propput, id( 2 ), helpstring( "The radians value for the angle" )] HRESULT Radians( [in] float val );
	[propget, id( 3 ), helpstring( "The grads value for the angle" )] HRESULT Grads( [out, retval] float * pVal );
	[propput, id( 3 ), helpstring( "The grads value for the angle" )] HRESULT Grads( [in] float val );
	[id( 4 ), helpstring( "The cosine value for this angle" )] HRESULT Cos( [out, retval] float * pVal );
	[id( 5 ), helpstring( "The sine value for this angle" )] HRESULT Sin( [out, retval] float * pVal );
	[id( 6 ), helpstring( "The tangent value for this angle" )] HRESULT Tan( [out, retval] float * pVal );
	[id( 7 ), helpstring( "Sets this angle value from a cosine" )] HRESULT ACos( [in] float val );
	[id( 8 ), helpstring( "Sets this angle value from a sine" )] HRESULT ASin( [in] float val );
	[id( 9 ), helpstring( "Sets this angle value from a tangent" )] HRESULT ATan( [in] float val );
	[id( 10 ), helpstring( "The hyperbolic cosine value for this angle" )] HRESULT Cosh( [out, retval] float * pVal );
	[id( 11 ), helpstring( "The hyperbolic sine value for this angle" )] HRESULT Sinh( [out, retval] float * pVal );
	[id( 12 ), helpstring( "The hyperbolic tangent value for this angle" )] HRESULT Tanh( [out, retval] float * pVal );
};

// IQuaternion
[
	uuid( B28DD02F-A3D5-48C1-89BB-E5B69B21455D ),
	helpstring( "Quaternion interface" ),
	dual,
	oleautomation
]
interface IQuaternion
	: IDispatch
{
	[propget, id( 1 ), helpstring( "The quaternions's rotation matrix" )] HRESULT RotationMatrix( [out, retval] IMatrix4x4 ** pVal );
	[propput, id( 1 ), helpstring( "The quaternions's rotation matrix" )] HRESULT RotationMatrix( [in] IMatrix4x4 * val );
	[id( 2 ), helpstring( "Transforms a vector through this quaternion" )] HRESULT Transform( [in] IVector3D * val, [out, retval] IVector3D ** pVal );
	[id( 3 ), helpstring( "Retrieves the quaternion's axis and angle" )] HRESULT ToAxisAngle( [out] IVector3D ** pAxis, [out] IAngle ** pAngle );
	[id( 4 ), helpstring( "Defines this quaternion's axis and angle" )] HRESULT FromAxisAngle( [in] IVector3D * axis, [in] IAngle * angle );
	[id( 5 ), helpstring( "Retrieves the quaternion's axes" )] HRESULT ToAxes( [out] IVector3D ** pX, [out] IVector3D ** pY, [out] IVector3D ** pZ );
	[id( 6 ), helpstring( "Defines this quaternion's axes" )] HRESULT FromAxes( [in] IVector3D * x, [in] IVector3D * y, [in] IVector3D * z );
	[id( 7 ), helpstring( "Retrieves the quaternion's rotation around the Y axis" )] HRESULT GetYaw( [out, retval] IAngle ** pVal );
	[id( 8 ), helpstring( "Retrieves the quaternion's rotation around the X axis" )] HRESULT GetPitch( [out, retval] IAngle ** pVal );
	[id( 9 ), helpstring( "Retrieves the quaternion's rotation around the Z axis" )] HRESULT GetRoll( [out, retval] IAngle ** pVal );
	[id( 10 ), helpstring( "Retrieves the quaternion's magnitude" )] HRESULT GetMagnitude( [out, retval] float * pVal );
	[id( 11 ), helpstring( "Retrieves the quaternion's conjugate" )] HRESULT Conjugate();
	[id( 12 ), helpstring( "Spherical linear interpolation with another quaternion, takes the shortest path." )] HRESULT Slerp( [in]IQuaternion * quat, [in] float percent, [out, retval] IQuaternion ** pQuat );
	[id( 13 ), helpstring( "Spherical linear interpolation with another quaternion." )] HRESULT Mix( [in]IQuaternion * quat, [in] float percent, [out, retval] IQuaternion ** pQuat );
}

// IMatrix4x4
[
	uuid( 80CF5574-9CE8-4CF8-B402-F013A0A9BD4C ),
	helpstring( "Square 4x4 matrix interface" ),
	dual,
	oleautomation
]
interface IMatrix4x4
	: IDispatch
{
	[id( 1 ), helpstring( "Transposes the matrix" )] HRESULT Transpose();
	[id( 2 ), helpstring( "Inverts the matrix" )] HRESULT Invert();
};

// IPosition
[
	uuid( AFBFFD86-1B3A-4217-900A-97E9B4CEB397 ),
	helpstring( "2D Position interface" ),
	dual,
	oleautomation
]
interface IPosition
	: IDispatch
{
	// Properties
	[propget, id( 1 ), helpstring( "The X coordinate" )] HRESULT X( [out, retval] int * pVal );
	[propput, id( 1 ), helpstring( "The X coordinate" )] HRESULT X( [in] int val );
	[propget, id( 2 ), helpstring( "The Y coordinate" )] HRESULT Y( [out, retval] int * pVal );
	[propput, id( 2 ), helpstring( "The Y coordinate" )] HRESULT Y( [in] int val );
	// Methods
	[id( 3 ), helpstring( "Sets the position coordinates" )] HRESULT Set( [in] int x, [in] int y );
	[id( 4 ), helpstring( "Moves the position with the given values" )] HRESULT Offset( [in] int x, [in] int y );
};

// ISize
[
	uuid( 8C3BBFE3-6894-4615-B19E-72243E7BF550 ),
	helpstring( "2D Size interface" ),
	dual,
	oleautomation
]
interface ISize
	: IDispatch
{
	// Properties
	[propget, id( 1 ), helpstring( "The width value" )] HRESULT Width( [out, retval] unsigned int * pVal );
	[propput, id( 1 ), helpstring( "The width value" )] HRESULT Width( [in] unsigned int val );
	[propget, id( 2 ), helpstring( "The height value" )] HRESULT Height( [out, retval] unsigned int * pVal );
	[propput, id( 2 ), helpstring( "The height value" )] HRESULT Height( [in] unsigned int val );
	// Methods
	[id( 3 ), helpstring( "Sets the size value" )] HRESULT Set( [in] unsigned int cx, [in] unsigned int cy );
	[id( 4 ), helpstring( "Adds the parameters to the size ones" )] HRESULT Grow( [in] int cx, [in] int cy );
};

// IRectangle
[
	uuid( 2E2DF1BB-83BE-4AEB-B183-6DEF2B7930B2 ),
	helpstring( "2D Rectangle interface" ),
	dual,
	oleautomation
]
interface IRect
	: IDispatch
{
	// Properties
	[propget, id( 1 ), helpstring( "The top value" )] HRESULT Top( [out, retval] int * pVal );
	[propput, id( 1 ), helpstring( "The top value" )] HRESULT Top( [in] int val );
	[propget, id( 2 ), helpstring( "The bottom value" )] HRESULT Bottom( [out, retval] int * pVal );
	[propput, id( 2 ), helpstring( "The bottom value" )] HRESULT Bottom( [in] int val );
	[propget, id( 3 ), helpstring( "The left value" )] HRESULT Left( [out, retval] int * pVal );
	[propput, id( 3 ), helpstring( "The left value" )] HRESULT Left( [in] int val );
	[propget, id( 4 ), helpstring( "The right value" )] HRESULT Right( [out, retval] int * pVal );
	[propput, id( 4 ), helpstring( "The right value" )] HRESULT Right( [in] int val );
	[propget, id( 5 ), helpstring( "The width value" )] HRESULT Width( [out, retval] int * pVal );
	[propget, id( 6 ), helpstring( "The height value" )] HRESULT Height( [out, retval] int * pVal );
	// Methods
	[id( 7 ), helpstring( "Sets the rect values" )] HRESULT Set( [in] int top, [in] int left, [in] int right, [in] int bottom );
	[id( 8 ), helpstring( "Checks if the given point is in the rect" )] HRESULT IntersectsPosition( [in] IPosition * pos, [out, retval] eINTERSECTION * pVal );
	[id( 9 ), helpstring( "Checks if the given rectanggle intersects this one" )] HRESULT IntersectsRectangle( [in] IRect * rect, [out, retval] eINTERSECTION * pVal );
};

// IGlyph
[
	uuid( D7252720-F639-4B97-8DF6-EAC59CF8A0B5 ),
	helpstring( "Glyph interface" ),
	dual,
	oleautomation
]
interface IGlyph
	: IDispatch
{
	[propget, id( 1 ), helpstring( "property Size" )] HRESULT Size( [out, retval] ISize ** pVal );
	[propget, id( 2 ), helpstring( "property Bearing" )] HRESULT Bearing( [out, retval] IPosition ** pVal );
	[propget, id( 3 ), helpstring( "property Advance" )] HRESULT Advance( [out, retval] int * pVal );
};

// ICastorFont
[
	uuid( 46E09586-EB07-4759-BAE1-E4BD7109415E ),
	helpstring( "Castor Font interface" ),
	dual,
	oleautomation
]
interface ICastorFont
	: IDispatch
{
	[propget, id( 1 ), helpstring( "property Height" )] HRESULT Height( [out, retval] UINT * pVal );
	[propget, id( 2 ), helpstring( "property MaxHeight" )] HRESULT MaxHeight( [out, retval] INT * pVal );
	[propget, id( 3 ), helpstring( "property MaxWidth" )] HRESULT MaxWidth( [out, retval] INT * pVal );
	[id( 4 ), helpstring( "method LoadFromFile" )] HRESULT LoadFromFile( [in] IEngine * engine, [in] BSTR path, [in] BSTR name, [in] UINT height );
	[id( 5 ), helpstring( "method GetGlyph" )] HRESULT GetGlyph( [in] WORD glyph, [out, retval] IGlyph ** pGlyph );
};

// IPixelBuffer
[
	uuid( A7DBFA7B-DE35-4A97-906B-DCCF59669F68 ),
	helpstring( "Castor PixelBuffer interface" ),
	dual,
	oleautomation
]
interface IPixelBuffer
	: IDispatch
{
	[propget, id( 1 ), helpstring( "property Dimensions" )] HRESULT Dimensions( [out, retval] ISize ** pVal );
	[propget, id( 2 ), helpstring( "property Width" )] HRESULT Width( [out, retval] unsigned int * pVal );
	[propget, id( 3 ), helpstring( "property Height" )] HRESULT Height( [out, retval] unsigned int * pVal );
	[propget, id( 4 ), helpstring( "property PixelFormat" )] HRESULT PixelFormat( [out, retval] ePIXEL_FORMAT * pVal );
	[id( 5 ), helpstring( "method Flip" )] HRESULT Flip();
	[id( 6 ), helpstring( "method Mirror" )] HRESULT Mirror();
	[id( 7 ), helpstring( "Initialises the buffer" )] HRESULT Initialise( ISize * size, ePIXEL_FORMAT pf );
};

// IImage
[
	uuid( 2841C68A-359E-4642-A8C5-43CC5D30F93C ),
	helpstring( "Castor Image interface" ),
	dual,
	oleautomation
]
interface IImage
	: IDispatch
{
	// Properties
	[propget, id( 1 ), helpstring( "The image pixels buffer" )] HRESULT Buffer( [out, retval] IPixelBuffer ** pVal );

	// Methods
	[id( 2 ), helpstring( "method LoadFromFile" )] HRESULT LoadFromFile( [in] IEngine * engine, [in] BSTR name, [in] BSTR val );
	[id( 3 ), helpstring( "method LoadFromFormat" )] HRESULT LoadFromFormat( [in] IEngine * engine, [in] BSTR name, [in] ePIXEL_FORMAT fmt, [in] ISize * size );
	[id( 4 ), helpstring( "method Resample" )] HRESULT Resample( [in] ISize * val );
	[id( 5 ), helpstring( "method Fill" )] HRESULT Fill( [in] IColour * val );
	[id( 6 ), helpstring( "method CopyImage" )] HRESULT CopyImage( [in] IImage * pVal );
	[id( 7 ), helpstring( "method SubImage" )] HRESULT SubImage( [in] IRect * val, [out, retval] IImage ** pVal );
};

// ILogger
[
	uuid( 7C23A081-332D-40F2-B12E-2CBEDB5FB242 ),
	helpstring( "Logger interface" ),
	dual,
	oleautomation
]
interface ILogger
	: IDispatch
{
	// Methods
	[id( 1 ), helpstring( "method Initialise" )] HRESULT Initialise( [in] eLOG_TYPE level );
	[id( 2 ), helpstring( "method SetFileName" )] HRESULT SetFileName( [in] BSTR name, eLOG_TYPE target );
	[id( 3 ), helpstring( "method Cleanup" )] HRESULT Cleanup();
	[id( 4 ), helpstring( "method LogDebug" )] HRESULT LogDebug( [in] BSTR msg );
	[id( 5 ), helpstring( "method LogInfo" )] HRESULT LogInfo( [in] BSTR msg );
	[id( 6 ), helpstring( "method LogWarning" )] HRESULT LogWarning( [in] BSTR msg );
	[id( 7 ), helpstring( "method LogError" )] HRESULT LogError( [in] BSTR msg );
};

// IBlendState
[
	uuid( 9F7F071A-18D5-403A-80C4-A934B85F35F7 ),
	helpstring( "Castor3D BlendState interface" ),
	dual,
	oleautomation
]
interface IBlendState
	: IDispatch
{
	[propget, id( 1 ), helpstring( "The alpha to coverage enabled status" )] HRESULT AlphaToCoverageEnabled( [out, retval] boolean * pVal );
	[propput, id( 1 ), helpstring( "The alpha to coverage enabled status" )] HRESULT AlphaToCoverageEnabled( [in] boolean val );
	[propget, id( 2 ), helpstring( "The independant blend enabled status" )] HRESULT IndependantBlendEnabled( [out, retval] boolean * pVal );
	[propput, id( 2 ), helpstring( "The independant blend enabled status" )] HRESULT IndependantBlendEnabled( [in] boolean val );
	[propget, id( 3 ), helpstring( "The blend factors" )] HRESULT BlendFactors( [out, retval] IColour ** pVal );
	[propput, id( 3 ), helpstring( "The blend factors" )] HRESULT BlendFactors( [in] IColour * val );
	[propget, id( 4 ), helpstring( "The sample coverage mask" )] HRESULT SampleCoverageMask( [out, retval] unsigned int * pVal );
	[propput, id( 4 ), helpstring( "The sample coverage mask" )] HRESULT SampleCoverageMask( [in] unsigned int val );
	[propget, id( 5 ), helpstring( "The blend enabled status, for nth unit" )] HRESULT BlendEnabled( [in] unsigned int index, [out, retval] boolean * pVal );
	[propput, id( 5 ), helpstring( "The blend enabled status, for nth unit" )] HRESULT BlendEnabled( [in] unsigned int index, [in] boolean val );
	[propget, id( 6 ), helpstring( "The source source RGB blend value, for nth unit" )] HRESULT RgbSrcBlend( [in] unsigned int index, [out, retval] eBLEND * pVal );
	[propput, id( 6 ), helpstring( "The source source RGB blend value, for nth unit" )] HRESULT RgbSrcBlend( [in] unsigned int index, [in] eBLEND val );
	[propget, id( 7 ), helpstring( "The source destination RGB blend value, for nth unit" )] HRESULT RgbDstBlend( [in] unsigned int index, [out, retval] eBLEND * pVal );
	[propput, id( 7 ), helpstring( "The source destination RGB blend value, for nth unit" )] HRESULT RgbDstBlend( [in] unsigned int index, [in] eBLEND val );
	[propget, id( 8 ), helpstring( "The RGB blend operator, for nth unit" )] HRESULT RgbBlendOp( [in] unsigned int index, [out, retval] eBLEND_OP * pVal );
	[propput, id( 8 ), helpstring( "The RGB blend operator, for nth unit" )] HRESULT RgbBlendOp( [in] unsigned int index, [in] eBLEND_OP val );
	[propget, id( 9 ), helpstring( "The source source Alpha blend value, for nth unit" )] HRESULT AlphaSrcBlend( [in] unsigned int index, [out, retval] eBLEND * pVal );
	[propput, id( 9 ), helpstring( "The source source Alpha blend value, for nth unit" )] HRESULT AlphaSrcBlend( [in] unsigned int index, [in] eBLEND val );
	[propget, id( 10 ), helpstring( "The source destination Alpha blend value, for nth unit" )] HRESULT AlphaDstBlend( [in] unsigned int index, [out, retval] eBLEND * pVal );
	[propput, id( 10 ), helpstring( "The source destination Alpha blend value, for nth unit" )] HRESULT AlphaDstBlend( [in] unsigned int index, [in] eBLEND val );
	[propget, id( 11 ), helpstring( "The Alpha blend operator, for nth unit" )] HRESULT AlphaBlendOp( [in] unsigned int index, [out, retval] eBLEND_OP * pVal );
	[propput, id( 11 ), helpstring( "The Alpha blend operator, for nth unit" )] HRESULT AlphaBlendOp( [in] unsigned int index, [in] eBLEND_OP val );
	[propget, id( 12 ), helpstring( "The render target write mask, for nth unit" )] HRESULT WriteMask( [in] unsigned int index, [out, retval] byte * pVal );
	[propput, id( 12 ), helpstring( "The render target write mask, for nth unit" )] HRESULT WriteMask( [in] unsigned int index, [in] byte val );
	[id( 13 ), helpstring( "Initialises the blend state" )] HRESULT Initialise();
	[id( 14 ), helpstring( "Cleans the blend state up" )] HRESULT Cleanup();
	[id( 15 ), helpstring( "The colour test mask" )] HRESULT SetColourMask( [in] eWRITING_MASK red, [in] eWRITING_MASK green, [in] eWRITING_MASK blue, [in] eWRITING_MASK alpha );
};

// IDepthStencilState
[
	uuid( 0BC058D9-CEB3-4155-AC8C-8642F6DAEE8C ),
	helpstring( "Castor3D DepthStencilState interface" ),
	dual,
	oleautomation
]
interface IDepthStencilState
	: IDispatch
{
	[propget, id( 1 ), helpstring( "The depth test enabled status" )] HRESULT DepthTest( [out, retval] boolean * pVal );
	[propput, id( 1 ), helpstring( "The depth test enabled status" )] HRESULT DepthTest( [in] boolean val );
	[propget, id( 2 ), helpstring( "The depth test function" )] HRESULT DepthFunc( [out, retval] eDEPTH_FUNC * pVal );
	[propput, id( 2 ), helpstring( "The depth test function" )] HRESULT DepthFunc( [in] eDEPTH_FUNC val );
	[propget, id( 3 ), helpstring( "The depth test mask" )] HRESULT DepthMask( [out, retval] eWRITING_MASK * pVal );
	[propput, id( 3 ), helpstring( "The depth test mask" )] HRESULT DepthMask( [in] eWRITING_MASK val );
	[propget, id( 4 ), helpstring( "The depth near distance" )] HRESULT DepthNear( [out, retval] double * pVal );
	[propget, id( 5 ), helpstring( "The depth far distance" )] HRESULT DepthFar( [out, retval] double * pVal );
	[propget, id( 6 ), helpstring( "The stencil test enabled status" )] HRESULT StencilTest( [out, retval] boolean * pVal );
	[propput, id( 6 ), helpstring( "The stencil test enabled status" )] HRESULT StencilTest( [in] boolean val );
	[propget, id( 7 ), helpstring( "The stencil test read mask" )] HRESULT StencilReadMask( [out, retval] unsigned long * pVal );
	[propput, id( 7 ), helpstring( "The stencil test read mask" )] HRESULT StencilReadMask( [in] unsigned long val );
	[propget, id( 8 ), helpstring( "The stencil test write mask" )] HRESULT StencilWriteMask( [out, retval] unsigned long * pVal );
	[propput, id( 8 ), helpstring( "The stencil test write mask" )] HRESULT StencilWriteMask( [in] unsigned long val );
	[propget, id( 9 ), helpstring( "The stencil test function, for the front faces" )] HRESULT StencilFrontFunc( [out, retval] eSTENCIL_FUNC * pVal );
	[propput, id( 9 ), helpstring( "The stencil test function, for the front faces" )] HRESULT StencilFrontFunc( [in] eSTENCIL_FUNC val );
	[propget, id( 10 ), helpstring( "The stencil test failed operation, for the front faces" )] HRESULT StencilFrontFailOp( [out, retval] eSTENCIL_OP * pVal );
	[propput, id( 10 ), helpstring( "The stencil test failed operation, for the front faces" )] HRESULT StencilFrontFailOp( [in] eSTENCIL_OP val );
	[propget, id( 11 ), helpstring( "The stencil test, depth test failed operation, for the front faces" )] HRESULT StencilFrontDepthFailOp( [out, retval] eSTENCIL_OP * pVal );
	[propput, id( 11 ), helpstring( "The stencil test, depth test failed operation, for the front faces" )] HRESULT StencilFrontDepthFailOp( [in] eSTENCIL_OP val );
	[propget, id( 12 ), helpstring( "The stencil test passed operation, for the front faces" )] HRESULT StencilFrontPassOp( [out, retval] eSTENCIL_OP * pVal );
	[propput, id( 12 ), helpstring( "The stencil test passed operation, for the front faces" )] HRESULT StencilFrontPassOp( [in] eSTENCIL_OP val );
	[propget, id( 13 ), helpstring( "The stencil test function, for the back faces" )] HRESULT StencilBackFunc( [out, retval] eSTENCIL_FUNC * pVal );
	[propput, id( 13 ), helpstring( "The stencil test function, for the back faces" )] HRESULT StencilBackFunc( [in] eSTENCIL_FUNC val );
	[propget, id( 14 ), helpstring( "The stencil test failed operation, for the back faces" )] HRESULT StencilBackFailOp( [out, retval] eSTENCIL_OP * pVal );
	[propput, id( 14 ), helpstring( "The stencil test failed operation, for the back faces" )] HRESULT StencilBackFailOp( [in] eSTENCIL_OP val );
	[propget, id( 15 ), helpstring( "The stencil test, depth test failed operation, for the back faces" )] HRESULT StencilBackDepthFailOp( [out, retval] eSTENCIL_OP * pVal );
	[propput, id( 15 ), helpstring( "The stencil test, depth test failed operation, for the back faces" )] HRESULT StencilBackDepthFailOp( [in] eSTENCIL_OP val );
	[propget, id( 16 ), helpstring( "The stencil test passed operation, for the back faces" )] HRESULT StencilBackPassOp( [out, retval] eSTENCIL_OP * pVal );
	[propput, id( 16 ), helpstring( "The stencil test passed operation, for the back faces" )] HRESULT StencilBackPassOp( [in] eSTENCIL_OP val );
	[id( 17 ), helpstring( "Sets the depth test range" )] HRESULT SetDepthRange( [in] double dnear, [in] double dfar );
	[id( 18 ), helpstring( "Initialises the depth stencil state" )] HRESULT Initialise();
	[id( 19 ), helpstring( "Cleans the depth stencil state up" )] HRESULT Cleanup();
};

// IRasteriserState
[
	uuid( 7AE4EAFB-BF93-4CBB-A935-830CD3097F27 ),
	helpstring( "Castor3D RasteriserState interface" ),
	dual,
	oleautomation
]
interface IRasteriserState
	: IDispatch
{
	[propget, id( 1 ), helpstring( "The fill mode" )] HRESULT FillMode( [out, retval] eFILL_MODE * pVal );
	[propput, id( 1 ), helpstring( "The fill mode" )] HRESULT FillMode( [in] eFILL_MODE val );
	[propget, id( 2 ), helpstring( "The faces culled by rasteriser" )] HRESULT CulledFaces( [out, retval] eFACE * pVal );
	[propput, id( 2 ), helpstring( "The faces culled by rasteriser" )] HRESULT CulledFaces( [in] eFACE val );
	[propget, id( 3 ), helpstring( "The faces which are considered front facing (true => CCW, false => CW)" )] HRESULT FrontCCW( [out, retval] boolean * pVal );
	[propput, id( 3 ), helpstring( "The faces which are considered front facing (true => CCW, false => CW)" )] HRESULT FrontCCW( [in] boolean val );
	[propget, id( 4 ), helpstring( "The antialiased lines status" )] HRESULT AntialiasedLines( [out, retval] boolean * pVal );
	[propput, id( 4 ), helpstring( "The antialiased lines status" )] HRESULT AntialiasedLines( [in] boolean val );
	[propget, id( 5 ), helpstring( "The depth bias" )] HRESULT DepthBias( [out, retval] float * pVal );
	[propput, id( 5 ), helpstring( "The depth bias" )] HRESULT DepthBias( [in] float val );
	[propget, id( 6 ), helpstring( "The depth clipping enabled status" )] HRESULT DepthClipping( [out, retval] boolean * pVal );
	[propput, id( 6 ), helpstring( "The depth clipping enabled status" )] HRESULT DepthClipping( [in] boolean val );
	[propget, id( 7 ), helpstring( "The multisample enabled status" )] HRESULT Multisample( [out, retval] boolean * pVal );
	[propput, id( 7 ), helpstring( "The multisample enabled status" )] HRESULT Multisample( [in] boolean val );
	[propget, id( 8 ), helpstring( "The scissor test enabled status" )] HRESULT Scissor( [out, retval] boolean * pVal );
	[propput, id( 8 ), helpstring( "The scissor test enabled status" )] HRESULT Scissor( [in] boolean val );
	[id( 9 ), helpstring( "Initialises the rasteriser state" )] HRESULT Initialise();
	[id( 10 ), helpstring( "Cleans the rasteriser state up" )] HRESULT Cleanup();
};

// IRenderTarget
[
	uuid( EC5787A9-9B4B-4F14-B2FF-2C2FB9E58B90 ),
	helpstring( "Castor3D RenderTarget interface" ),
	dual,
	oleautomation
]
interface IRenderTarget
	: IDispatch
{
	[propget, id( 1 ), helpstring( "The samples count, when multisampling" )] HRESULT SamplesCount( [out, retval] unsigned int * pVal );
	[propput, id( 1 ), helpstring( "The samples count, when multisampling" )] HRESULT SamplesCount( [in] unsigned int val );
	[propget, id( 2 ), helpstring( "The target camera" )] HRESULT Camera( [out, retval] ICamera ** pVal );
	[propput, id( 2 ), helpstring( "The target camera" )] HRESULT Camera( [in] ICamera * camera );
	[propget, id( 4 ), helpstring( "The viewport type" )] HRESULT ViewportType( [out, retval] eVIEWPORT_TYPE * pVal );
	[propput, id( 4 ), helpstring( "The viewport type" )] HRESULT ViewportType( [in] eVIEWPORT_TYPE val );
	[propget, id( 5 ), helpstring( "The rendered scene" )] HRESULT Scene( [out, retval] IScene ** pVal );
	[propput, id( 5 ), helpstring( "The rendered scene" )] HRESULT Scene( [in] IScene * val );
	[propget, id( 6 ), helpstring( "The target pixel format" )] HRESULT PixelFormat( [out, retval] ePIXEL_FORMAT * pVal );
	[propput, id( 6 ), helpstring( "The target pixel format" )] HRESULT PixelFormat( [in] ePIXEL_FORMAT val );
	[propget, id( 7 ), helpstring( "The target size" )] HRESULT Size( [out, retval] ISize ** pVal );
	[id( 9 ), helpstring( "Initialises the render target" ), local] HRESULT Initialise( [in] unsigned int index );
	[id( 10 ), helpstring( "Cleans the render target up" )] HRESULT Cleanup();
};

// ISampler
[
	uuid( AE167A91-F79C-42C3-9F07-2491F5FD9931 ),
	helpstring( "Castor3D Sampler interface" ),
	dual,
	oleautomation
]
interface ISampler
	: IDispatch
{
	[propget, id( 2 ), helpstring( "The sampler min filter" )] HRESULT MinFilter( [out, retval] eINTERPOLATION_MODE * pVal );
	[propput, id( 2 ), helpstring( "The sampler min filter" )] HRESULT MinFilter( [in] eINTERPOLATION_MODE val );
	[propget, id( 3 ), helpstring( "The sampler mag filter" )] HRESULT MagFilter( [out, retval] eINTERPOLATION_MODE * pVal );
	[propput, id( 3 ), helpstring( "The sampler mag filter" )] HRESULT MagFilter( [in] eINTERPOLATION_MODE val );
	[propget, id( 4 ), helpstring( "The sampler mip filter" )] HRESULT MipFilter( [out, retval] eINTERPOLATION_MODE * pVal );
	[propput, id( 4 ), helpstring( "The sampler mip filter" )] HRESULT MipFilter( [in] eINTERPOLATION_MODE val );
	[propget, id( 5 ), helpstring( "The sampler U wrap mode" )] HRESULT UWrappingMode( [out, retval] eWRAP_MODE * pVal );
	[propput, id( 5 ), helpstring( "The sampler U wrap mode" )] HRESULT UWrappingMode( [in] eWRAP_MODE val );
	[propget, id( 6 ), helpstring( "The sampler V wrap mode" )] HRESULT VWrappingMode( [out, retval] eWRAP_MODE * pVal );
	[propput, id( 6 ), helpstring( "The sampler V wrap mode" )] HRESULT VWrappingMode( [in] eWRAP_MODE val );
	[propget, id( 7 ), helpstring( "The sampler W wrap mode" )] HRESULT WWrappingMode( [out, retval] eWRAP_MODE * pVal );
	[propput, id( 7 ), helpstring( "The sampler W wrap mode" )] HRESULT WWrappingMode( [in] eWRAP_MODE val );
	[propget, id( 8 ), helpstring( "The sampler max anisotropy" )] HRESULT MaxAnisotropy( [out, retval] float * pVal );
	[propput, id( 8 ), helpstring( "The sampler max anisotropy" )] HRESULT MaxAnisotropy( [in] float val );
	[propget, id( 9 ), helpstring( "The sampler min LOD" )] HRESULT MinLod( [out, retval] float * pVal );
	[propput, id( 9 ), helpstring( "The sampler min LOD" )] HRESULT MinLod( [in] float val );
	[propget, id( 10 ), helpstring( "The sampler max LOD" )] HRESULT MaxLod( [out, retval] float * pVal );
	[propput, id( 10 ), helpstring( "The sampler max LOD" )] HRESULT MaxLod( [in] float val );
	[propget, id( 11 ), helpstring( "The sampler LOD bias" )] HRESULT LodBias( [out, retval] float * pVal );
	[propput, id( 11 ), helpstring( "The sampler LOD bias" )] HRESULT LodBias( [in] float val );
	[propget, id( 12 ), helpstring( "The sampler border colour" )] HRESULT BorderColour( [out, retval] IColour ** pVal );
	[propput, id( 12 ), helpstring( "The sampler border colour" )] HRESULT BorderColour( [in] IColour * val );
	[id( 13 ), helpstring( "Initialises the sampler" )] HRESULT Initialise();
	[id( 14 ), helpstring( "Cleans the sampler up" )] HRESULT Cleanup();
};

// ITextureImage
[
	uuid( AD4C78E2-277A-4F6E-A1BB-F94FEA78F4A5 ),
	helpstring( "Castor3D TextureImage interface" ),
	dual,
	oleautomation
]
interface ITextureImage
	: IDispatch
{
	[propget, id( 1 ), helpstring( "The texture image height" )] HRESULT Height( [out, retval] unsigned int * pVal );
	[propget, id( 2 ), helpstring( "The texture image width" )] HRESULT Width( [out, retval] unsigned int * pVal );
	[propget, id( 3 ), helpstring( "The texture image depth" )] HRESULT Depth( [out, retval] unsigned int * pVal );
	[propget, id( 4 ), helpstring( "The texture image buffer" )] HRESULT Buffer( [out, retval] IPixelBuffer ** pVal );
	[id(  5 ), helpstring( "Initialises the texture" )] HRESULT Initialise( [in] eTEXTURE_TYPE p_type, [in] unsigned int p_cpuAccess, [in] unsigned int p_gpuAccess );
	[id(  6 ), helpstring( "Cleans the texture up" )] HRESULT Cleanup();
	[id(  7 ), helpstring( "Resizes the texture" )] HRESULT Resize2D( [in] unsigned int w, [in] unsigned int h );
	[id(  8 ), helpstring( "Resizes the texture" )] HRESULT Resize3D( [in] unsigned int w, [in] unsigned int h, [in] unsigned int d );
	[id(  9 ), helpstring( "Sets the image source" )] HRESULT Static2DSource( [in] IPixelBuffer * val );
	[id( 10 ), helpstring( "Sets the image source" )] HRESULT Static3DSource( [in] unsigned int w, [in] unsigned int h, [in] unsigned int d, [in] IPixelBuffer * val );
	[id( 11 ), helpstring( "Sets the image source" )] HRESULT Dynamic2DSource( [in] unsigned int w, [in] unsigned int h, [in] ePIXEL_FORMAT format );
	[id( 12 ), helpstring( "Sets the image source" )] HRESULT Dynamic3DSource( [in] unsigned int w, [in] unsigned int h, [in] unsigned int d, [in] ePIXEL_FORMAT format );
};

// ITextureLayout
[
	uuid( 8985F532-34C0-4996-882C-8850D45C53F1 ),
	helpstring( "Castor3D TextureLayout interface" ),
	dual,
	oleautomation
]
interface ITextureLayout
	: IDispatch
{
	[propget, id( 1 ), helpstring( "The texture type" )] HRESULT Type( [out, retval] eTEXTURE_TYPE * pVal );
	[propget, id( 2 ), helpstring( "The texture image" )] HRESULT Image( [in] unsigned int index, [out, retval] ITextureImage ** pVal );
	[id( 6 ), helpstring( "Initialises the texture" )] HRESULT Initialise();
	[id( 7 ), helpstring( "Cleans the texture up" )] HRESULT Cleanup();
};

// ITextureUnit
[
	uuid( 224BAC64-C97E-4CB7-8A77-88284BDC4BA7 ),
	helpstring( "Castor3D TextureUnit interface" ),
	dual,
	oleautomation
]
interface ITextureUnit
	: IDispatch
{
	[propget, id( 1 ), helpstring( "The unit texture" )] HRESULT Texture( [out, retval] ITextureLayout ** pVal );
	[propput, id( 1 ), helpstring( "The unit texture" )] HRESULT Texture( [in] ITextureLayout * val );
	[propget, id( 2 ), helpstring( "The unit sampler" )] HRESULT Sampler( [out, retval] ISampler ** pVal );
	[propput, id( 2 ), helpstring( "The unit sampler" )] HRESULT Sampler( [in] ISampler * val );
	[propget, id( 3 ), helpstring( "The Alpha Test function" )] HRESULT AlphaFunc( [out, retval] eALPHA_FUNC * pVal );
	[propput, id( 3 ), helpstring( "The Alpha Test function" )] HRESULT AlphaFunc( [in] eALPHA_FUNC val );
	[propget, id( 4 ), helpstring( "The Alpha Test reference value" )] HRESULT AlphaValue( [out, retval] float * pVal );
	[propput, id( 4 ), helpstring( "The Alpha Test reference value" )] HRESULT AlphaValue( [in] float val );
	[propget, id( 5 ), helpstring( "The Alpha Blending function" )] HRESULT AlpFunction( [out, retval] eALPHA_BLEND_FUNC * pVal );
	[propput, id( 5 ), helpstring( "The Alpha Blending function" )] HRESULT AlpFunction( [in] eALPHA_BLEND_FUNC val );
	[propget, id( 6 ), helpstring( "The Alpha Blending argument" )] HRESULT AlpArgument( [in] unsigned int index, [out, retval] eBLEND_SOURCE * pVal );
	[propput, id( 6 ), helpstring( "The Alpha Blending argument" )] HRESULT AlpArgument( [in] unsigned int index, [in] eBLEND_SOURCE val );
	[propget, id( 7 ), helpstring( "The RGB Blending function" )] HRESULT RgbFunction( [out, retval] eRGB_BLEND_FUNC * pVal );
	[propput, id( 7 ), helpstring( "The RGB Blending function" )] HRESULT RgbFunction( [in] eRGB_BLEND_FUNC val );
	[propget, id( 8 ), helpstring( "The RGB Blending argument" )] HRESULT RgbArgument( [in] unsigned int index, [out, retval] eBLEND_SOURCE * pVal );
	[propput, id( 8 ), helpstring( "The RGB Blending argument" )] HRESULT RgbArgument( [in] unsigned int index, [in] eBLEND_SOURCE val );
	[propget, id( 9 ), helpstring( "The texture channel" )] HRESULT Channel( [out, retval] eTEXTURE_CHANNEL * pVal );
	[propput, id( 9 ), helpstring( "The texture channel" )] HRESULT Channel( [in] eTEXTURE_CHANNEL val );
	[propget, id( 10 ), helpstring( "The texture blend colour" )] HRESULT BlendColour( [out, retval] IColour ** pVal );
	[propput, id( 10 ), helpstring( "The texture blend colour" )] HRESULT BlendColour( [in] IColour * val );
	[id( 11 ), helpstring( "Loads the texture image from a file" )] HRESULT LoadTexture( [in] BSTR path );
};

// IShaderProgram
[
	uuid( C6C6C1C0-6023-467F-B084-05C3CD8C4ADA ),
	helpstring( "Castor3D ShaderProgram interface" ),
	dual,
	oleautomation
]
interface IShaderProgram
	: IDispatch
{
	[propget, id( 1 ), helpstring( "Retrieves the shader source for the shader object of wanted type" )] HRESULT File( [in] eSHADER_TYPE target, [in] eSHADER_MODEL model, [out, retval] BSTR * pVal );
	[propput, id( 1 ), helpstring( "Sets the shader source for the shader object of wanted type" )] HRESULT File( [in] eSHADER_TYPE target, [in] eSHADER_MODEL model, [in] BSTR val );
	[propget, id( 2 ), helpstring( "Retrieves the shader source for the shader object of wanted type" )] HRESULT Source( [in] eSHADER_TYPE target, [in] eSHADER_MODEL model, [out, retval] BSTR * pVal );
	[propput, id( 2 ), helpstring( "Sets the shader source for the shader object of wanted type" )] HRESULT Source( [in] eSHADER_TYPE target, [in] eSHADER_MODEL model, [in] BSTR val );
	[id( 4 ), helpstring( "Initialises the shader program" )] HRESULT Initialise();
	[id( 5 ), helpstring( "Cleans the shader program up" )] HRESULT Cleanup();
	[id( 6 ), helpstring( "Creates the shader object of wanted type" )] HRESULT CreateObject( [in] eSHADER_TYPE val );
};

// IPass
[
	uuid( 4A915888-BC95-4F0C-A544-2AC83363C5AE ),
	helpstring( "Castor3D Pass interface" ),
	dual,
	oleautomation
]
interface IPass
	: IDispatch
{
	[propget, id( 1 ), helpstring( "The pass ambient colour" )] HRESULT Ambient( [out, retval] IColour ** pVal );
	[propput, id( 1 ), helpstring( "The pass ambient colour" )] HRESULT Ambient( [in] IColour * val );
	[propget, id( 2 ), helpstring( "The pass diffuse colour" )] HRESULT Diffuse( [out, retval] IColour ** pVal );
	[propput, id( 2 ), helpstring( "The pass diffuse colour" )] HRESULT Diffuse( [in] IColour * val );
	[propget, id( 3 ), helpstring( "The pass specular colour" )] HRESULT Specular( [out, retval] IColour ** pVal );
	[propput, id( 3 ), helpstring( "The pass specular colour" )] HRESULT Specular( [in] IColour * val );
	[propget, id( 4 ), helpstring( "The pass emissive colour" )] HRESULT Emissive( [out, retval] IColour ** pVal );
	[propput, id( 4 ), helpstring( "The pass emissive colour" )] HRESULT Emissive( [in] IColour * val );
	[propget, id( 5 ), helpstring( "The pass shininess value" )] HRESULT Shininess( [out, retval] float * pVal );
	[propput, id( 5 ), helpstring( "The pass shininess value" )] HRESULT Shininess( [in] float val );
	[propget, id( 6 ), helpstring( "The pass two sided status" )] HRESULT TwoSided( [out, retval] boolean * pVal );
	[propput, id( 6 ), helpstring( "The pass two sided status" )] HRESULT TwoSided( [in] boolean val );
	[propget, id( 7 ), helpstring( "The pass global alpha value" )] HRESULT Alpha( [out, retval] float * pVal );
	[propput, id( 7 ), helpstring( "The pass global alpha value" )] HRESULT Alpha( [in] float val );
	[propget, id( 8 ), helpstring( "Retrieves the units count" )] HRESULT TextureUnitCount( [out, retval] unsigned int * pVal );
	[id( 9 ), helpstring( "Creates a texture unit" )] HRESULT CreateTextureUnit( [out, retval] ITextureUnit ** pVal );
	[id( 10 ), helpstring( "Retrieves the texture unit at given index" )] HRESULT GetTextureUnitByIndex( [in] unsigned int index, [out, retval] ITextureUnit ** pVal );
	[id( 11 ), helpstring( "Destroys the texture unit" )] HRESULT DestroyTextureUnit( [in] ITextureUnit * val );
	[id( 12 ), helpstring( "Retrieves the texture unit at given channel" )] HRESULT GetTextureUnitByChannel( [in] eTEXTURE_CHANNEL channe, [out, retval] ITextureUnit ** pVal );
};

// IMaterial
[
	uuid( 60CDC28E-625E-4277-BA83-499AC743433D ),
	helpstring( "Castor3D Material interface" ),
	dual,
	oleautomation
]
interface IMaterial
	: IDispatch
{
	[propget, id( 1 ), helpstring( "Retrieves the passes count" )] HRESULT PassCount( [out, retval] unsigned int * pVal );
	[id( 2 ), helpstring( "Initialises the material" )] HRESULT Initialise();
	[id( 3 ), helpstring( "Cleans the material up" )] HRESULT Cleanup();
	[id( 4 ), helpstring( "Creates a pass" )] HRESULT CreatePass( [out, retval] IPass ** pVal );
	[id( 5 ), helpstring( "Retrieves the pass at given index" )] HRESULT GetPass( [in] unsigned int val, [out, retval] IPass ** pVal );
	[id( 6 ), helpstring( "Destroys the given pass" )] HRESULT DestroyPass( [in] unsigned int val );
};

// ISubmesh
[
	uuid( 59DAC74D-1B5C-49BE-A404-96A18E117CC0 ),
	helpstring( "Castor3D Submesh interface" ),
	dual,
	oleautomation
]
interface ISubmesh
	: IDispatch
{
	[propget, id( 1 ), helpstring( "The faces count" )] HRESULT FaceCount( [out, retval] unsigned int * pVal );
	[propget, id( 2 ), helpstring( "The points count" )] HRESULT PointsCount( [out, retval] unsigned int * pVal );
	[propget, id( 3 ), helpstring( "The rendering topology" )] HRESULT Topology( [out, retval] eTOPOLOGY * pVal );
	[propput, id( 3 ), helpstring( "The rendering topology" )] HRESULT Topology( [in] eTOPOLOGY val );
	[id( 4 ), helpstring( "Adds a point to the submesh" )] HRESULT AddPoint( [in] IVector3D * val );
	[id( 5 ), helpstring( "Adds a face to the submesh, defined by its vertex indices" )] HRESULT AddFace( [in] unsigned int x, [in] unsigned int y, [in] unsigned int z );
};

// IMesh
[
	uuid( 2CD94C1A-39A2-4301-B412-04C7E766DF64 ),
	helpstring( "Castor3D Mesh interface" ),
	dual,
	oleautomation
]
interface IMesh
	: IDispatch
{
	[propget, id( 1 ), helpstring( "The total mesh's submeshes count" )] HRESULT SubmeshCount( [out, retval] unsigned int * pVal );
	[propget, id( 2 ), helpstring( "The total mesh's faces count" )] HRESULT FaceCount( [out, retval] unsigned int * pVal );
	[propget, id( 3 ), helpstring( "The total mesh's vertices count" )] HRESULT VertexCount( [out, retval] unsigned int * pVal );
	[id( 4 ), helpstring( "Retrieves the submesh at the given index" )] HRESULT GetSubmesh( [in] unsigned int val, [out, retval] ISubmesh ** pVal );
	[id( 5 ), helpstring( "Creates a new submesh for this mesh" )] HRESULT CreateSubmesh( [out, retval] ISubmesh ** pVal );
	[id( 6 ), helpstring( "Deletes the given submesh" )] HRESULT DeleteSubmesh( [in] ISubmesh * val );
};

// IScene
[
	uuid( 6684A9C0-CC49-41F3-B78D-9C34F294AF62 ),
	helpstring( "Castor3D Scene interface" ),
	dual,
	oleautomation
]
interface IScene
	: IDispatch
{
	[propget, id( 1 ), helpstring( "The background colour" )] HRESULT BackgroundColour( [out, retval] IColour ** pVal );
	[propput, id( 1 ), helpstring( "The background colour" )] HRESULT BackgroundColour( [in] IColour * val );
	[propget, id( 2 ), helpstring( "The scene name" )] HRESULT Name( [out, retval] BSTR * pVal );
	[propput, id( 2 ), helpstring( "The scene name" )] HRESULT Name( [in] BSTR val );
	[propget, id( 3 ), helpstring( "The ambient light colour" )] HRESULT AmbientLight( [out, retval] IColour ** pVal );
	[propput, id( 3 ), helpstring( "The ambient light colour" )] HRESULT AmbientLight( [in] IColour * val );
	[propget, id( 8 ), helpstring( "The root scene node" )] HRESULT RootNode( [out, retval] ISceneNode ** pVal );
	[propget, id( 9 ), helpstring( "The objects root scene node" )] HRESULT ObjectRootNode( [out, retval] ISceneNode ** pVal );
	[propget, id( 10 ), helpstring( "The cameras root scene node" )] HRESULT CameraRootNode( [out, retval] ISceneNode ** pVal );
	[id( 11 ), helpstring( "Clears the created objects maps" )] HRESULT ClearScene();
	[id( 12 ), helpstring( "Sets the background image" )] HRESULT SetBackgroundImage( [in] BSTR path );
	[id( 13 ), helpstring( "Creates a new scene node" )] HRESULT CreateSceneNode( [in] BSTR name, [in] ISceneNode * parent, [out, retval] ISceneNode ** pVal );
	[id( 14 ), helpstring( "Creates a new geometry" )] HRESULT CreateGeometry( [in] BSTR name, [out, retval] IGeometry ** pVal );
	[id( 15 ), helpstring( "Creates a new camera" )] HRESULT CreateCamera( [in] BSTR name, [in] int ww, [in] int wh, [in] ISceneNode * node, [out, retval] ICamera ** pVal );
	[id( 16 ), helpstring( "Creates a new light" )] HRESULT CreateLight( [in] BSTR name, [in] ISceneNode * node, [in] eLIGHT_TYPE type, [out, retval] ILight ** pVal );
	[id( 17 ), helpstring( "Retrieves the scene node with the given name" )] HRESULT GetNode( [in] BSTR name, [out, retval] ISceneNode ** pVal );
	[id( 18 ), helpstring( "Retrieves the geometry with the given name" )] HRESULT GetGeometry( [in] BSTR name, [out, retval] IGeometry ** pVal );
	[id( 19 ), helpstring( "Retrieves the light with the given name" )] HRESULT GetLight( [in] BSTR name, [out, retval] ILight ** pVal );
	[id( 20 ), helpstring( "Retrieves the camera with the given name" )] HRESULT GetCamera( [in] BSTR name, [out, retval] ICamera ** pVal );
	[id( 21 ), helpstring( "Removes the light with the given name" )] HRESULT RemoveLight( [in] ILight * light );
	[id( 22 ), helpstring( "Removes the scene node with the given name" )] HRESULT RemoveNode( [in] ISceneNode * node );
	[id( 23 ), helpstring( "Removes the geometry with the given name" )] HRESULT RemoveGeometry( [in] IGeometry * geometry );
	[id( 24 ), helpstring( "Removes the camera with the given name" )] HRESULT RemoveCamera( [in] ICamera * camera );
	[id( 30 ), helpstring( "Retrieves the backround image" )] HRESULT GetBackgroundImage( [out, retval] ITextureLayout ** pVal );
};

// IRenderWindow
[
	uuid( 37C075FA-038D-468B-AFF8-386E852AC5A2 ),
	helpstring( "Castor3D RenderWindow interface" ),
	dual,
	oleautomation
]
interface IRenderWindow
	: IDispatch
{
	[propget, id( 1 ), helpstring( "The render target" )] HRESULT RenderTarget( [out, retval] IRenderTarget ** pVal );
	[propput, id( 1 ), helpstring( "The render target" )] HRESULT RenderTarget( [in] IRenderTarget * camera );
	[propget, id( 2 ), helpstring( "The window name" )] HRESULT Name( [out, retval] BSTR * pVal );
	[id( 3 ), helpstring( "Initialises the render window" ), local] HRESULT Initialise( [in] ISize * size, [in] LPVOID val, [out, retval] VARIANT_BOOL * pVal );
	[id( 4 ), helpstring( "Cleans the render window up" )] HRESULT Cleanup();
	[id( 5 ), helpstring( "Resizes the render window" )] HRESULT Resize( [in] ISize * size );
	[id( 6 ), helpstring( "MouseMove event processing" )] HRESULT OnMouseMove( [in] IPosition * pos );
	[id( 7 ), helpstring( "MouseMouseLButtonDown event processing" )] HRESULT OnMouseLButtonDown( [in] IPosition * pos );
	[id( 8 ), helpstring( "MouseMouseLButtonUp event processing" )] HRESULT OnMouseLButtonUp( [in] IPosition * pos );
	[id( 9 ), helpstring( "MouseMouseMButtonDown event processing" )] HRESULT OnMouseMButtonDown( [in] IPosition * pos );
	[id( 10 ), helpstring( "MouseMouseLButtonUp event processing" )] HRESULT OnMouseMButtonUp( [in] IPosition * pos );
	[id( 11 ), helpstring( "MouseMouseRButtonDown event processing" )] HRESULT OnMouseRButtonDown( [in] IPosition * pos );
	[id( 12 ), helpstring( "MouseMouseRButtonUp event processing" )] HRESULT OnMouseRButtonUp( [in] IPosition * pos );
};

// IAnimation
[
	uuid( 242D6D0F-1470-4F0A-A7D0-9288E1D8856C ),
	helpstring( "Castor3D Animation interface" ),
	dual,
	oleautomation
]
interface IAnimation
	: IDispatch
{
};

// ISkeleton
[
	uuid( B9815090-EE8B-4FEB-91EE-B7D29C963B38 ),
	helpstring( "Castor3D Skeleton interface" ),
	dual,
	oleautomation
]
interface ISkeleton
	: IDispatch
{
};

// IMovableObject
[
	uuid( C0B3C2C4-365F-4E66-9520-FD95D45CA96C ),
	helpstring( "Castor3D MovableObject interface" ),
	dual,
	oleautomation
]
interface IMovableObject
	: IDispatch
{
	[propget, id( 1 ), helpstring( "The object name" )] HRESULT Name( [out, retval] BSTR * pVal );
	[propget, id( 2 ), helpstring( "The movable object type" )] HRESULT Type( [out, retval] eMOVABLE_TYPE * pVal );
	[propget, id( 3 ), helpstring( "The object's parent scene" )] HRESULT Scene( [out, retval] IScene ** pVal );
	[id( 4 ), helpstring( "Attaches the movable object to the given node" )] HRESULT AttachTo( [in] ISceneNode * val );
	[id( 5 ), helpstring( "Detaches the movable object from its parent node" )] HRESULT Detach();
};

// ILightCategory
[
	uuid( 65C7028B-1B92-4504-A5D8-909C28CC6C47 ),
	helpstring( "Castor3D LightCategory interface" ),
	dual,
	oleautomation
]
interface ILightCategory
	: IDispatch
{
	[propget, id( 1 ), helpstring( "The light colour" )] HRESULT Colour( [out, retval] IVector3D ** pVal );
	[propput, id( 1 ), helpstring( "The light colour" )] HRESULT Colour( [in] IVector3D * val );
	[propget, id( 2 ), helpstring( "The light ambient intensity" )] HRESULT AmbientIntensity( [out, retval] float * pVal );
	[propput, id( 2 ), helpstring( "The light ambient intensity" )] HRESULT AmbientIntensity( [in] float val );
	[propget, id( 3 ), helpstring( "The light diffuse intensity" )] HRESULT DiffuseIntensity( [out, retval] float * pVal );
	[propput, id( 3 ), helpstring( "The light diffuse intensity" )] HRESULT DiffuseIntensity( [in] float val );
	[propget, id( 4 ), helpstring( "The light specular intensity" )] HRESULT SpecularIntensity( [out, retval] float * pVal );
	[propput, id( 4 ), helpstring( "The light specular intensity" )] HRESULT SpecularIntensity( [in] float val );
};

// IDirectionalLight
[
	uuid( 96333EBA-90E9-4884-A56C-C65E60BF0C21 ),
	helpstring( "Castor3D DirectionalLight interface" ),
	dual,
	oleautomation
]
interface IDirectionalLight
	: IDispatch
{
	[propget, id( 1 ), helpstring( "The light direction" )] HRESULT Direction( [out, retval] IVector3D ** pVal );
	[propput, id( 1 ), helpstring( "The light direction" )] HRESULT Direction( [in] IVector3D * val );
};

// IPointLight
[
	uuid( D0DD3B04-6638-4B5C-991C-BB16447C2149 ),
	helpstring( "Castor3D PointLight interface" ),
	dual,
	oleautomation
]
interface IPointLight
	: IDispatch
{
	[propget, id( 1 ), helpstring( "The light source position" )] HRESULT Position( [out, retval] IVector3D ** pVal );
	[propput, id( 1 ), helpstring( "The light source position" )] HRESULT Position( [in] IVector3D * val );
	[propget, id( 2 ), helpstring( "The light attenuation values (constant, linear and quadratic)" )] HRESULT Attenuation( [out, retval] IVector3D ** pVal );
	[propput, id( 2 ), helpstring( "The light attenuation values (constant, linear and quadratic)" )] HRESULT Attenuation( [in] IVector3D * val );
};

// ISpotLight
[
	uuid( 08B2CE8A-04A2-4F35-AFA3-B96809F8685E ),
	helpstring( "Castor3D SpotLight interface" ),
	dual,
	oleautomation
]
interface ISpotLight
	: IDispatch
{
	[propget, id( 1 ), helpstring( "The light source position" )] HRESULT Position( [out, retval] IVector3D ** pVal );
	[propput, id( 1 ), helpstring( "The light source position" )] HRESULT Position( [in] IVector3D * val );
	[propget, id( 2 ), helpstring( "The light attenuation values (constant, linear and quadratic)" )] HRESULT Attenuation( [out, retval] IVector3D ** pVal );
	[propput, id( 2 ), helpstring( "The light attenuation values (constant, linear and quadratic)" )] HRESULT Attenuation( [in] IVector3D * val );
	[propget, id( 3 ), helpstring( "The light exponent value" )] HRESULT Exponent( [out, retval] float * pVal );
	[propput, id( 3 ), helpstring( "The light exponent value" )] HRESULT Exponent( [in] float val );
	[propget, id( 4 ), helpstring( "The light cut off value" )] HRESULT CutOff( [out, retval] float * pVal );
	[propput, id( 4 ), helpstring( "The light cut off value" )] HRESULT CutOff( [in] float val );
};

// ICamera
[
	uuid( 6E91B5E9-E5F9-4C04-8518-54F48DC39470 ),
	helpstring( "Castor3D Camera interface" ),
	dual,
	oleautomation
]
interface ICamera
	: IMovableObject
{
	[propget, id( 12 ), helpstring( "The camera viewport type" )] HRESULT ViewportType( [out, retval] eVIEWPORT_TYPE * pVal );
	[propput, id( 12 ), helpstring( "The camera viewport type" )] HRESULT ViewportType( [in] eVIEWPORT_TYPE val );
	[propget, id( 13 ), helpstring( "The camera horizontal resolution" )] HRESULT Width( [out, retval] unsigned int * pVal );
	[propget, id( 14 ), helpstring( "The camera vertical resolution" )] HRESULT Height( [out, retval] unsigned int * pVal );
	[id( 15 ), helpstring( "Changes the camera resolution" )] HRESULT Resize( [in] unsigned int width, [in] unsigned int height );
};

// ILight
[
	uuid( 9C79BC67-7FEC-4758-83C7-53F95B203878 ),
	helpstring( "Castor3D Light interface" ),
	dual,
	oleautomation
]
interface ILight
	: IMovableObject
{
	[propget, id( 11 ), helpstring( "The light type" )] HRESULT LightType( [out, retval] eLIGHT_TYPE * pVal );
	[propget, id( 12 ), helpstring( "The directional light category" )] HRESULT DirectionalLight( [out, retval] IDirectionalLight ** pVal );
	[propget, id( 13 ), helpstring( "The point light category" )] HRESULT PointLight( [out, retval] IPointLight ** pVal );
	[propget, id( 14 ), helpstring( "The spot light category" )] HRESULT SpotLight( [out, retval] ISpotLight ** pVal );
};

// IGeometry
[
	uuid( E1C7D856-CEBD-45BB-80DA-A6B50D4906CA ),
	helpstring( "Castor3D Geometry interface" ),
	dual,
	oleautomation
]
interface IGeometry
	: IMovableObject
{
	[propget, id( 11 ), helpstring( "The geometry's mesh" )] HRESULT Mesh( [out, retval] IMesh ** pVal );
	[propput, id( 11 ), helpstring( "The geometry's mesh" )] HRESULT Mesh( [in] IMesh * val );
	[id( 12 ), helpstring( "Retrieves the given submesh's material" )] HRESULT GetMaterial( [in] ISubmesh * submesh, [out, retval] IMaterial ** pVal );
	[id( 13 ), helpstring( "Defines the given submesh's material" )] HRESULT SetMaterial( [in] ISubmesh * submesh, [in] IMaterial * val );
};

// ISceneNode
[
	uuid( 6BDE5A33-7ACA-4CBA-BA25-795F9003F9A5 ),
	helpstring( "Castor3D SceneNode interface" ),
	dual,
	oleautomation
]
interface ISceneNode
	: IDispatch
{
	[propget, id( 1 ), helpstring( "The node position" )] HRESULT Position( [out, retval] IVector3D ** pVal );
	[propput, id( 1 ), helpstring( "The node position" )] HRESULT Position( [in] IVector3D * val );
	[propget, id( 2 ), helpstring( "The node orientation" )] HRESULT Orientation( [out, retval] IQuaternion ** pVal );
	[propput, id( 2 ), helpstring( "The node orientation" )] HRESULT Orientation( [in] IQuaternion * val );
	[propget, id( 3 ), helpstring( "The node scale" )] HRESULT Scaling( [out, retval] IVector3D ** pVal );
	[propput, id( 3 ), helpstring( "The node scale" )] HRESULT Scaling( [in] IVector3D * val );
	[id( 4 ), helpstring( "Attaches an object to the node" )] HRESULT AttachObject( [in] IMovableObject * val );
	[id( 5 ), helpstring( "Detaches an object from the node" )] HRESULT DetachObject( [in] IMovableObject * val );
	[id( 6 ), helpstring( "Attaches this node to another one" )] HRESULT AttachTo( [in] ISceneNode * val );
	[id( 7 ), helpstring( "Detaches this node from its parent" )] HRESULT Detach();
	[id( 8 ), helpstring( "Retrieves Y axis orientation" )] HRESULT Yaw( [in] IAngle * val );
	[id( 9 ), helpstring( "Retrieves X axis orientation" )] HRESULT Pitch( [in] IAngle * val );
	[id( 10 ), helpstring( "Retrieves Z axis orientation" )] HRESULT Roll( [in] IAngle * val );
	[id( 11 ), helpstring( "Rotates the node" )] HRESULT Rotate( [in] IQuaternion * val );
	[id( 12 ), helpstring( "Translates the node" )] HRESULT Translate( [in] IVector3D * val );
	[id( 13 ), helpstring( "Scales the node" )] HRESULT Scale( [in] IVector3D * val );
};

// IOverlayCategory
[
	uuid( 4AAADEFD-6698-45E4-BD2D-EEE7C43A1F65 ),
	helpstring( "Castor3D OverlayCategory interface" ),
	dual,
	oleautomation
]
interface IOverlayCategory
	: IDispatch
{
	[propget, id( 1 ), helpstring( "The overlay type" )] HRESULT Type( [out, retval] eOVERLAY_TYPE * pVal );
	[propget, id( 2 ), helpstring( "The overlay position, relative to its parent" )] HRESULT Position( [out, retval] IVector2D ** pVal );
	[propput, id( 2 ), helpstring( "The overlay position, relative to its parent" )] HRESULT Position( [in] IVector2D * val );
	[propget, id( 3 ), helpstring( "The overlay size, relative to its parent" )] HRESULT Size( [out, retval] IVector2D ** pVal );
	[propput, id( 3 ), helpstring( "The overlay size, relative to its parent" )] HRESULT Size( [in] IVector2D * val );
	[propget, id( 4 ), helpstring( "The overlay visibility" )] HRESULT Visible( [out, retval] boolean * pVal );
	[propput, id( 4 ), helpstring( "The overlay visibility" )] HRESULT Visible( [in] boolean * val );
	[propget, id( 5 ), helpstring( "The overlay z-index" )] HRESULT ZIndex( [out, retval] int * pVal );
	[propput, id( 5 ), helpstring( "The overlay z-index" )] HRESULT ZIndex( [in] int val );
	[propget, id( 6 ), helpstring( "The overlay material" )] HRESULT Material( [out, retval] IMaterial ** pVal );
	[propput, id( 6 ), helpstring( "The overlay material" )] HRESULT Material( [in] IMaterial * val );
};

// IPanelOverlay
[
	uuid( 0C35C9BA-56BE-4CB0-AEEC-6A337046B385 ),
	helpstring( "Castor3D PanelOverlay interface" ),
	dual,
	oleautomation
]
interface IPanelOverlay
	: IDispatch
{
};

// IBorderPanelOverlay
[
	uuid( B5FC19FF-70E4-400E-8E2B-24339F0AEF71 ),
	helpstring( "Castor3D BorderPanelOverlay interface" ),
	dual,
	oleautomation
]
interface IBorderPanelOverlay
	: IDispatch
{
	[propget, id( 1 ), helpstring( "The bottom border width" )] HRESULT LeftBorderSize( [out, retval] float * pVal );
	[propput, id( 1 ), helpstring( "The bottom border width" )] HRESULT LeftBorderSize( [in] float val );
	[propget, id( 2 ), helpstring( "The right border width" )] HRESULT RightBorderSize( [out, retval] float * pVal );
	[propput, id( 2 ), helpstring( "The right border width" )] HRESULT RightBorderSize( [in] float val );
	[propget, id( 3 ), helpstring( "The top border width" )] HRESULT TopBorderSize( [out, retval] float * pVal );
	[propput, id( 3 ), helpstring( "The top border width" )] HRESULT TopBorderSize( [in] float val );
	[propget, id( 4 ), helpstring( "The bottom border width" )] HRESULT BottomBorderSize( [out, retval] float * pVal );
	[propput, id( 4 ), helpstring( "The bottom border width" )] HRESULT BottomBorderSize( [in] float val );
	[propget, id( 5 ), helpstring( "The border material" )] HRESULT BorderMaterial( [out, retval] IMaterial ** pVal );
	[propput, id( 5 ), helpstring( "The border material" )] HRESULT BorderMaterial( [in] IMaterial * val );
};

// ITextOverlay
[
	uuid( 3B011483-3744-4B48-9363-BDD52A5F5D44 ),
	helpstring( "Castor3D TextOverlay interface" ),
	dual,
	oleautomation
]
interface ITextOverlay
	: IDispatch
{
	[propget, id( 1 ), helpstring( "The text font" )] HRESULT Font( [out, retval] BSTR * pVal );
	[propput, id( 1 ), helpstring( "The text font" )] HRESULT Font( [in] BSTR val );
	[propget, id( 2 ), helpstring( "The text caption" )] HRESULT Caption( [out, retval] BSTR * pVal );
	[propput, id( 2 ), helpstring( "The text caption" )] HRESULT Caption( [in] BSTR val );
};

// IOverlay
[
	uuid( C29F0735-AC5D-4C68-A189-81FAA0AD0405 ),
	helpstring( "Castor3D Overlay interface" ),
	dual,
	oleautomation
]
interface IOverlay
	: IDispatch
{
	[propget, id( 1 ), helpstring( "The overlay name" )] HRESULT Name( [out, retval] BSTR * pVal );
	[propput, id( 1 ), helpstring( "The overlay name" )] HRESULT Name( [in] BSTR val );
	[propget, id( 2 ), helpstring( "The panel overlay category" )] HRESULT PanelOverlay( [out, retval] IPanelOverlay ** pVal );
	[propget, id( 3 ), helpstring( "The border panel overlay category" )] HRESULT BorderPanelOverlay( [out, retval] IBorderPanelOverlay ** pVal );
	[propget, id( 4 ), helpstring( "The text overlay category" )] HRESULT TextOverlay( [out, retval] ITextOverlay ** pVal );
	[id( 5 ), helpstring( "Retrieves the childs count" )] HRESULT GetChildsCount( [in] unsigned int * pVal );
	[id( 6 ), helpstring( "Adds a child" )] HRESULT AddChild( [in] IOverlay * overlay, [in] int zindex );
};

// IAnimable
[
	uuid( 18CB2526-98C6-4E19-932C-25264D419FFA ),
	helpstring( "Castor3D Animable interface" ),
	dual,
	oleautomation
]
interface IAnimable
	: IDispatch
{
	[id( 1 ), helpstring( "Retrieves the animation with the given name" )] HRESULT GetAnimation( [in] BSTR name, [out, retval] IAnimation ** anim );
	[id( 2 ), helpstring( "Creates an animation" )] HRESULT CreateAnimation( [in] BSTR name, [out, retval] IAnimation ** anim );
};

// IAnimatedObject
[
	uuid( 6F5C61B7-507C-4C5C-9463-368776C647D1 ),
	helpstring( "Castor3D AnimatedObject interface" ),
	dual,
	oleautomation
]
interface IAnimatedObject
	: IDispatch
{
	[propget, id( 1 ), helpstring( "The animable geometry" )] HRESULT Geometry( [out, retval] IGeometry ** pVal );
	[propput, id( 1 ), helpstring( "The animable geometry" )] HRESULT Geometry( [in] IGeometry * val );
	[propget, id( 2 ), helpstring( "The animable mesh" )] HRESULT Mesh( [out, retval] IMesh ** pVal );
	[propput, id( 2 ), helpstring( "The animable mesh" )] HRESULT Mesh( [in] IMesh * val );
	[propget, id( 3 ), helpstring( "The animable skeleton" )] HRESULT Skeleton( [out, retval] ISkeleton ** pVal );
	[propput, id( 3 ), helpstring( "The animable skeleton" )] HRESULT Skeleton( [in] ISkeleton * val );
	[id( 4 ), helpstring( "Retrieves the animation with given name" )] HRESULT GetAnimation( [in] BSTR name, [out, retval] IAnimation ** anim );
	[id( 5 ), helpstring( "Starts all the animable animations" )] HRESULT StartAllAnimations();
	[id( 6 ), helpstring( "Stops all the animable animations" )] HRESULT StopAllAnimations();
	[id( 7 ), helpstring( "Pauses all the animable animations" )] HRESULT PauseAllAnimations();
	[id( 8 ), helpstring( "Starts the animation with given name" )] HRESULT StartAnimation( [in] BSTR name );
	[id( 9 ), helpstring( "Stops the animation with given name" )] HRESULT StopAnimation( [in] BSTR name );
	[id( 10 ), helpstring( "Pauses the animation with given name" )] HRESULT PauseAnimation( [in] BSTR name );
};

// IAnimatedObjectGroup
[
	uuid( E369A7E4-0E42-42B9-B541-CD23A20FCDC1 ),
	helpstring( "Castor3D AnimatedObjectGroup interface" ),
	dual,
	oleautomation
]
interface IAnimatedObjectGroup
	: IDispatch
{
	[propget, id( 1 ), helpstring( "Retrieves the animsations count" )] HRESULT AnimationCount( [out, retval] unsigned int * pVal );
	[propget, id( 2 ), helpstring( "Retrieves the animable objects count" )] HRESULT ObjectCount( [out, retval] unsigned int * pVal );
	[propget, id( 3 ), helpstring( "Retrieves the scene" )] HRESULT Scene( [out, retval] IScene ** anim );
	[id( 5 ), helpstring( "Retrieves the animable object with given name" )] HRESULT GetAnimableObject( [in] BSTR name, [out, retval] IAnimable ** obj );
	[id( 6 ), helpstring( "Starts all the animable animations" )] HRESULT StartAllAnimations();
	[id( 7 ), helpstring( "Stops all the animable animations" )] HRESULT StopAllAnimations();
	[id( 8 ), helpstring( "Pauses all the animable animations" )] HRESULT PauseAllAnimations();
	[id( 9 ), helpstring( "Starts the animation with given name" )] HRESULT StartAnimation( [in] BSTR name );
	[id( 10 ), helpstring( "Stops the animation with given name" )] HRESULT StopAnimation( [in] BSTR name );
	[id( 11 ), helpstring( "Pauses the animation with given name" )] HRESULT PauseAnimation( [in] BSTR name );
	[id( 12 ), helpstring( "Creates the animable object" )] HRESULT CreateObject( [in] BSTR name, [out, retval] IAnimable ** obj );
	[id( 13 ), helpstring( "Adds an animable object to the group" )] HRESULT AddObject( [in] IAnimable * obj, [out, retval] boolean * pVal );
	[id( 14 ), helpstring( "Adds an animation to the group" )] HRESULT AddAnimation( [in] BSTR name );
	[id( 15 ), helpstring( "Sets the animation loop status" )] HRESULT SetAnimationLooped( [in] BSTR name, [in] boolean val );
};

// IEngine
[
	uuid( 66132C94-BBD3-4C20-BADC-B8EB03E21E11 ),
	helpstring( "Castor3D Engine interface" ),
	dual,
	oleautomation
]
interface IEngine
	: IDispatch
{
	[propget, id( 1 ), helpstring( "Retrieves the plugins directory" )] HRESULT PluginsDirectory( [out, retval] BSTR * path );
	[propget, id( 2 ), helpstring( "Retrieves engine directory" )] HRESULT EngineDirectory( [out, retval] BSTR * path );
	[propget, id( 3 ), helpstring( "Retrieves data directory" )] HRESULT DataDirectory( [out, retval] BSTR * path );
	[id( 11 ), helpstring( "Creates the engine" )] HRESULT Create();
	[id( 12 ), helpstring( "Destroys the engine" )] HRESULT Destroy();
	[id( 13 ), helpstring( "Initialises the engine" )] HRESULT Initialise( [in] int fps );
	[id( 14 ), helpstring( "Cleans up the engine" )] HRESULT Cleanup();
	[id( 15 ), helpstring( "Creates a scene" )] HRESULT CreateScene( [in] BSTR name, [out, retval] IScene ** pVal );
	[id( 16 ), helpstring( "Cleans up the scenes" )] HRESULT ClearScenes();
	[id( 17 ), helpstring( "Loads a renderer" )] HRESULT LoadRenderer( [in] eRENDERER_TYPE type );
	[id( 18 ), helpstring( "Renders a frame" )] HRESULT RenderOneFrame();
	[id( 19 ), helpstring( "Loads a plugin from its path" )] HRESULT LoadPlugin( [in] BSTR path );
	[id( 20 ), helpstring( "Creates a mesh" )] HRESULT CreateMesh( [in] eMESH_TYPE type, [in] BSTR name, [out, retval] IMesh ** pVal );
	[id( 21 ), helpstring( "Creates an overlay" )] HRESULT CreateOverlay( [in] eOVERLAY_TYPE type, [in] BSTR name, [in] IOverlay * parent, [in] IScene * scene, [out, retval] IOverlay ** pVal );
	[id( 22 ), helpstring( "Creates a render window" )] HRESULT CreateRenderWindow( [in] BSTR name, [out, retval] IRenderWindow ** pVal );
	[id( 23 ), helpstring( "Removes a render window" )] HRESULT RemoveWindow( [in] IRenderWindow * val );
	[id( 24 ), helpstring( "Creates a sampler" )] HRESULT CreateSampler( [in] BSTR name, [out, retval] ISampler ** pVal );
	[id( 25 ), helpstring( "Creates a blend state" )] HRESULT CreateBlendState( [in] BSTR name, [out, retval] IBlendState ** pVal );
	[id( 26 ), helpstring( "Creates a depth stencil state" )] HRESULT CreateDepthStencilState( [in] BSTR name, [out, retval] IDepthStencilState ** pVal );
	[id( 27 ), helpstring( "Creates a rasteriser state" )] HRESULT CreateRasteriserState( [in] BSTR name, [out, retval] IRasteriserState ** pVal );
	[id( 28 ), helpstring( "Removes the scene with the given name" )] HRESULT RemoveScene( [in] BSTR name );
	[id( 29 ), helpstring( "Loads a scene file" )] HRESULT LoadScene( [in] BSTR name, [out, retval] IRenderWindow ** window );
};

// Castor3DLib
[
	uuid( AE7400FF-58CB-40F5-9D8B-3373BCC45E54 ),
	version( 0.8 ),
	helpstring( "Castor3D interfaces" )
]
library Castor3D
{
	importlib( "stdole32.tlb" ); // Import libraries containing. 
	importlib( "stdole2.tlb" ); // standard COM API calls.

								// Colour
	[
		uuid( 22125089-C34A-4C20-B8F9-07907A8AEA0D )
	]
	coclass Colour
	{
		[default] interface IColour;
	};

	// Vector2D
	[
		uuid( 9A7B169B-06DF-4617-A93D-3EF10A4362F7 )
	]
	coclass Vector2D
	{
		[default] interface IVector2D;
	};

	// Vector3D
	[
		uuid( D406D2D9-865B-40CF-AB98-CA79F00C0797 )
	]
	coclass Vector3D
	{
		[default] interface IVector3D;
	};

	// Angle
	[
		uuid( 236D0939-4F04-4D7C-A8CD-1415F3CCBA71 )
	]
	coclass Angle
	{
		[default] interface IAngle;
	};

	// Quaternion
	[
		uuid( 7A301C67-36E2-483D-925A-62E3C5DBE871 )
	]
	coclass Quaternion
	{
		[default] interface IQuaternion;
	};

	// IMatrix4x4
	[
		uuid( 3353741E-3F82-4A99-B8DC-6D6AB0584E04 )
	]
	coclass Matrix4x4
	{
		[default] interface IMatrix4x4;
	};

	// Position
	[
		uuid( 2C6A4321-6187-436B-9B31-4B340D1C6507 )
	]
	coclass Position
	{
		[default] interface IPosition;
	};

	// Size
	[
		uuid( 3F1B36E8-4E97-403C-B2F3-25267C23A7FD )
	]
	coclass Size
	{
		[default] interface ISize;
	};

	// Rect
	[
		uuid( A1C8B71D-D5BC-4664-9058-1EE9F964BFF7 )
	]
	coclass Rect
	{
		[default] interface IRect;
	};

	// Glyph
	[
		uuid( E8EB965B-EB5E-413D-B119-FADC081C8AD9 )
	]
	coclass Glyph
	{
		[default] interface IGlyph;
	};

	// Font
	[
		uuid( 814FF4F4-8FFC-4048-A972-6EF3DA5314E1 )
	]
	coclass Font
	{
		[default] interface ICastorFont;
	};

	// PixelBuffer
	[
		uuid( D2F8DD56-82D0-4467-9AB4-61F3BB228ACC )
	]
	coclass PixelBuffer
	{
		[default] interface IPixelBuffer;
	};

	// Image
	[
		uuid( 032154A9-2E6F-4FEE-A132-5840EEEC21FD )
	]
	coclass Image
	{
		[default] interface IImage;
	};

	// Logger
	[
		uuid( A39A1B4B-9882-4B2E-AB1D-55257AF40727 )
	]
	coclass Logger
	{
		[default] interface ILogger;
	};

	// BlendState
	[
		uuid( CA7E6B72-3130-4888-83D3-33BFBBA2B3FD )
	]
	coclass BlendState
	{
		[default] interface IBlendState;
	}

	// DepthStencilState
	[
		uuid( 8699BD20-FDE7-4FA9-9265-60B539CCE45D )
	]
	coclass DepthStencilState
	{
		[default] interface IDepthStencilState;
	}

	// RasteriserState
	[
		uuid( 5880CD0C-969C-471D-8FD0-3F271A492D33 )
	]
	coclass RasteriserState
	{
		[default] interface IRasteriserState;
	}

	// Sampler
	[
		uuid( 98978C6B-C6FB-447C-A874-15068F900011 )
	]
	coclass Sampler
	{
		[default] interface ISampler;
	}

	// TextureImage
	[
		uuid( 3CA68187-BD17-4E78-8D5C-B994DDA134BA )
	]
	coclass TextureImage
	{
		[default] interface ITextureImage;
	}

	// TextureLayout
	[
		uuid( 0FF08968-9937-4771-8949-0E86E3615F98 )
	]
	coclass TextureLayout
	{
		[default] interface ITextureLayout;
	}

	// TextureUnit
	[
		uuid( E8DD6F29-F296-4687-AADD-F6FD1D0AC670 )
	]
	coclass TextureUnit
	{
		[default] interface ITextureUnit;
	}

	// ShaderProgram
	[
		uuid( B62FE384-D806-4DA7-B091-A7E260D95D7F )
	]
	coclass ShaderProgram
	{
		[default] interface IShaderProgram;
	}

	// Pass
	[
		uuid( 1B6D6829-C5D7-4B75-8A92-E016C63147B3 )
	]
	coclass Pass
	{
		[default] interface IPass;
	}

	// Material
	[
		uuid( A9F3E2A5-A54C-4E4A-8448-0A663BE88E40 )
	]
	coclass Material
	{
		[default] interface IMaterial;
	}

	// Submesh
	[
		uuid( E59360F1-2F5B-4011-A61F-32E1A77207C8 )
	]
	coclass Submesh
	{
		[default] interface ISubmesh;
	};

	// Mesh
	[
		uuid( C5053069-A376-4E0E-AA0A-5CCE3A78C205 )
	]
	coclass Mesh
	{
		[default] interface IMesh;
	};

	// MovableObject
	[
		uuid( C36B1CB1-9623-4DE9-B5D8-108AC6D32D54 )
	]
	coclass MovableObject
	{
		[default] interface IMovableObject;
	};

	// LightCategory
	[
		uuid( 9C77B39B-EAD2-4EDB-815E-1B74B1F8B5C3 )
	]
	coclass LightCategory
	{
		[default] interface ILightCategory;
	};

	// DirectionalLight
	[
		uuid( F0FC01FC-2C13-40C0-A07F-9B913181264B )
	]
	coclass DirectionalLight
	{
		[default] interface IDirectionalLight;
	};

	// PointLight
	[
		uuid( 3581BE19-66C5-407B-8E7E-C761424C5974 )
	]
	coclass PointLight
	{
		[default] interface IPointLight;
	};

	// SpotLight
	[
		uuid( 0819BA84-8671-454B-B9A3-84C8A3C5DB95 )
	]
	coclass SpotLight
	{
		[default] interface ISpotLight;
	};

	// Camera
	[
		uuid( 823F16E0-606C-46C7-8B22-8B5C907B4E48 )
	]
	coclass Camera
	{
		[default] interface ICamera;
	};

	// Light
	[
		uuid( 7499D2D6-4275-4816-B25E-042CC75C566E )
	]
	coclass Light
	{
		[default] interface ILight;
	};

	// Geometry
	[
		uuid( 0F08578A-FD57-4F6F-8CB5-26E5C1CBA88A )
	]
	coclass Geometry
	{
		[default] interface IGeometry;
	};

	// SceneNode
	[
		uuid( 665CE022-156D-4C04-B621-35CB66A6D6D4 )
	]
	coclass SceneNode
	{
		[default] interface ISceneNode;
	};

	// OverlayCategory
	[
		uuid( 0A9CE856-F576-41EF-A6F0-C27291C6C2D2 )
	]
	coclass OverlayCategory
	{
		[default] interface IOverlayCategory;
	};

	// PanelOverlay
	[
		uuid( B5AD045F-0EDE-46F9-8AF0-381FBDB62385 )
	]
	coclass PanelOverlay
	{
		[default] interface IPanelOverlay;
	};

	// BorderPanelOverlay
	[
		uuid( 147C4638-20C2-46AC-8765-B67F0128BC4A )
	]
	coclass BorderPanelOverlay
	{
		[default] interface IBorderPanelOverlay;
	};

	// TextOverlay
	[
		uuid( 287EAF30-2165-49AC-BC96-8CF568D28CAE )
	]
	coclass TextOverlay
	{
		[default] interface ITextOverlay;
	};

	// Overlay
	[
		uuid( CA66D170-B96A-4910-83D5-D622E9A813F7 )
	]
	coclass Overlay
	{
		[default] interface IOverlay;
	};

	// Animable
	[
		uuid( F9185125-9460-4039-A0B0-EB2295AC6AB1 )
	]
	coclass Animable
	{
		[default] interface IAnimable;
	};

	// AnimatedObject
	[
		uuid( F31A778F-F9E5-4619-A35B-2EE8325BF1D2 )
	]
	coclass AnimatedObject
	{
		[default] interface IAnimatedObject;
	};

	// AnimatedObjectGroup
	[
		uuid( 7180F914-17E1-45A1-A2AB-F195F0724AD7 )
	]
	coclass AnimatedObjectGroup
	{
		[default] interface IAnimatedObjectGroup;
	};

	// Scene
	[
		uuid( C2669704-BF96-4D28-9627-7E625EA2EC99 )
	]
	coclass Scene
	{
		[default] interface IScene;
	};

	// Animation
	[
		uuid( 5B26DE5C-FFE8-42AE-A07C-837D5164CAFE )
	]
	coclass Animation
	{
		[default] interface IAnimation;
	};

	// Skeleton
	[
		uuid( 53A552B5-8524-4DDD-987C-AC68AA87233E )
	]
	coclass Skeleton
	{
		[default] interface ISkeleton;
	};

	// RenderWindow
	[
		uuid( AD82930D-4682-4CF1-B9E8-EDFD869E7AF7 )
	]
	coclass RenderTarget
	{
		[default] interface IRenderTarget;
	};

	// RenderWindow
	[
		uuid( 68E4373D-24BB-45FE-9717-CB512111A984 )
	]
	coclass RenderWindow
	{
		[default] interface IRenderWindow;
	};

	// Engine
	[
		uuid( 557E0DD9-00E5-48A2-AE26-B78CC6031956 )
	]
	coclass Engine
	{
		[default] interface IEngine;
	};
}
