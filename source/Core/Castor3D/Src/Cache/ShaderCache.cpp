#include "ShaderCache.hpp"

#include "Engine.hpp"

#include "Event/Frame/CleanupEvent.hpp"
#include "Event/Frame/InitialiseEvent.hpp"
#include "Material/Pass.hpp"
#include "Render/RenderPipeline.hpp"
#include "Render/RenderPass.hpp"
#include "Shader/ShaderProgram.hpp"

#include <GlslSource.hpp>

using namespace castor;

namespace castor3d
{
	namespace
	{
		uint64_t makeKey( PassFlags const & passFlags
			, TextureChannels const & textureFlags
			, ProgramFlags const & programFlags
			, SceneFlags const & sceneFlags
			, ComparisonFunc alphaFunc
			, bool invertNormals )
		{
			return ( uint64_t( passFlags ) << 56 ) // Pass flags on 8 bits
				   | ( uint64_t( textureFlags ) << 44 ) // Texture flags on 12 bits
				   | ( uint64_t( programFlags ) << 28 ) // Program flags on 16 bits
				   | ( uint64_t( sceneFlags ) << 20 ) // SceneFlags on 8 bits
				   | ( uint64_t( alphaFunc ) << 12 ) // Alpha func on 8 bits
				   | ( uint64_t( invertNormals ? 0x01 : 0x00 ) );
		}
	}

	ShaderProgramCache::ShaderProgramCache( Engine & engine )
		: OwnedBy< Engine >( engine )
	{
	}

	ShaderProgramCache::~ShaderProgramCache()
	{
	}

	void ShaderProgramCache::cleanup()
	{
		for ( auto program : m_arrayPrograms )
		{
			getEngine()->postEvent( makeCleanupEvent( *program ) );
		}
	}

	void ShaderProgramCache::clear()
	{
		m_mapBillboards.clear();
		m_mapAutogenerated.clear();
		m_arrayPrograms.clear();
	}

	ShaderProgramSPtr ShaderProgramCache::getNewProgram( bool p_initialise )
	{
		ShaderProgramSPtr result = getEngine()->getRenderSystem()->createShaderProgram();

		if ( result )
		{
			doAddProgram( result, p_initialise );
		}

		return result;
	}

	ShaderProgramSPtr ShaderProgramCache::getAutomaticProgram( RenderPass const & renderPass
		, PassFlags const & passFlags
		, TextureChannels const & textureFlags
		, ProgramFlags const & programFlags
		, SceneFlags const & sceneFlags
		, ComparisonFunc alphaFunc
		, bool invertNormals )
	{
		ShaderProgramSPtr result;

		if ( checkFlag( programFlags, ProgramFlag::eBillboards ) )
		{
			uint64_t key = makeKey( passFlags
				, textureFlags
				, programFlags
				, sceneFlags
				, alphaFunc
				, false );
			auto const & it = m_mapBillboards.find( key );

			if ( it != m_mapBillboards.end() )
			{
				result = it->second.lock();
			}
			else
			{
				result = doCreateBillboardProgram( renderPass
					, passFlags
					, textureFlags
					, programFlags
					, sceneFlags
					, alphaFunc );

				if ( result )
				{
					doAddBillboardProgram( result
						, passFlags
						, textureFlags
						, programFlags
						, sceneFlags
						, alphaFunc );
				}
			}
		}
		else
		{
			uint64_t key = makeKey( passFlags
				, textureFlags
				, programFlags
				, sceneFlags
				, alphaFunc
				, invertNormals );
			ShaderProgramWPtrUInt64MapConstIt it = m_mapAutogenerated.find( key );

			if ( it != m_mapAutogenerated.end() )
			{
				result = it->second.lock();
			}
			else
			{
				result = doCreateAutomaticProgram( renderPass
					, passFlags
					, textureFlags
					, programFlags
					, sceneFlags
					, alphaFunc
					, invertNormals );

				if ( result )
				{
					doAddAutomaticProgram( result
						, passFlags
						, textureFlags
						, programFlags
						, sceneFlags
						, alphaFunc
						, invertNormals );
				}
			}
		}

		return result;
	}

	void ShaderProgramCache::createTextureVariables( ShaderProgram & shader
		, PassFlags const & passFlags
		, TextureChannels const & textureFlags
		, ProgramFlags const & programFlags )const
	{
		if ( checkFlag( programFlags, ProgramFlag::eLighting ) )
		{
			shader.createUniform< UniformType::eSampler >( ShaderProgram::Lights, ShaderType::ePixel )->setValue( LightBufferIndex );
		}

		if ( checkFlag( textureFlags, TextureChannel::eNormal ) )
		{
			shader.createUniform< UniformType::eSampler >( ShaderProgram::MapNormal, ShaderType::ePixel );
		}

		if ( checkFlag( textureFlags, TextureChannel::eEmissive ) )
		{
			shader.createUniform< UniformType::eSampler >( ShaderProgram::MapEmissive, ShaderType::ePixel );
		}

		if ( checkFlag( textureFlags, TextureChannel::eOpacity ) )
		{
			shader.createUniform< UniformType::eSampler >( ShaderProgram::MapOpacity, ShaderType::ePixel );
		}

		if ( checkFlag( textureFlags, TextureChannel::eHeight ) )
		{
			shader.createUniform< UniformType::eSampler >( ShaderProgram::MapHeight, ShaderType::ePixel );
		}

		if ( checkFlag( textureFlags, TextureChannel::eTransmittance ) )
		{
			shader.createUniform< UniformType::eSampler >( ShaderProgram::MapTransmittance, ShaderType::ePixel );
		}

		if ( checkFlag( passFlags, PassFlag::ePbrMetallicRoughness ) )
		{
			if ( checkFlag( textureFlags, TextureChannel::eAlbedo ) )
			{
				shader.createUniform< UniformType::eSampler >( ShaderProgram::MapAlbedo, ShaderType::ePixel );
			}

			if ( checkFlag( textureFlags, TextureChannel::eMetallic ) )
			{
				shader.createUniform< UniformType::eSampler >( ShaderProgram::MapMetallic, ShaderType::ePixel );
			}

			if ( checkFlag( textureFlags, TextureChannel::eRoughness ) )
			{
				shader.createUniform< UniformType::eSampler >( ShaderProgram::MapRoughness, ShaderType::ePixel );
			}

			if ( checkFlag( textureFlags, TextureChannel::eAmbientOcclusion ) )
			{
				shader.createUniform< UniformType::eSampler >( ShaderProgram::MapAmbientOcclusion, ShaderType::ePixel );
			}

			shader.createUniform< UniformType::eSampler >( ShaderProgram::MapEnvironment, ShaderType::ePixel );
		}
		else if ( checkFlag( passFlags, PassFlag::ePbrSpecularGlossiness ) )
		{
			if ( checkFlag( textureFlags, TextureChannel::eDiffuse ) )
			{
				shader.createUniform< UniformType::eSampler >( ShaderProgram::MapDiffuse, ShaderType::ePixel );
			}

			if ( checkFlag( textureFlags, TextureChannel::eSpecular ) )
			{
				shader.createUniform< UniformType::eSampler >( ShaderProgram::MapSpecular, ShaderType::ePixel );
			}

			if ( checkFlag( textureFlags, TextureChannel::eGloss ) )
			{
				shader.createUniform< UniformType::eSampler >( ShaderProgram::MapGloss, ShaderType::ePixel );
			}

			if ( checkFlag( textureFlags, TextureChannel::eAmbientOcclusion ) )
			{
				shader.createUniform< UniformType::eSampler >( ShaderProgram::MapAmbientOcclusion, ShaderType::ePixel );
			}

			shader.createUniform< UniformType::eSampler >( ShaderProgram::MapEnvironment, ShaderType::ePixel );
		}
		else
		{
			if ( checkFlag( textureFlags, TextureChannel::eReflection )
				|| checkFlag( textureFlags, TextureChannel::eRefraction ) )
			{
				shader.createUniform< UniformType::eSampler >( ShaderProgram::MapEnvironment, ShaderType::ePixel );
			}

			if ( checkFlag( textureFlags, TextureChannel::eDiffuse ) )
			{
				shader.createUniform< UniformType::eSampler >( ShaderProgram::MapDiffuse, ShaderType::ePixel );
			}

			if ( checkFlag( textureFlags, TextureChannel::eSpecular ) )
			{
				shader.createUniform< UniformType::eSampler >( ShaderProgram::MapSpecular, ShaderType::ePixel );
			}

			if ( checkFlag( textureFlags, TextureChannel::eGloss ) )
			{
				shader.createUniform< UniformType::eSampler >( ShaderProgram::MapGloss, ShaderType::ePixel );
			}
		}
	}

	void ShaderProgramCache::doAddProgram( ShaderProgramSPtr program
		, bool initialise )
	{
		m_arrayPrograms.push_back( program );

		if ( initialise )
		{
			if ( getEngine()->getRenderSystem()->getCurrentContext() )
			{
				program->initialise();
			}
			else
			{
				getEngine()->postEvent( makeInitialiseEvent( *program ) );
			}
		}
	}

	ShaderProgramSPtr ShaderProgramCache::doCreateAutomaticProgram( RenderPass const & renderPass
		, PassFlags const & passFlags
		, TextureChannels const & textureFlags
		, ProgramFlags const & programFlags
		, SceneFlags const & sceneFlags
		, ComparisonFunc alphaFunc
		, bool invertNormals )const
	{
		ShaderProgramSPtr result = getEngine()->getRenderSystem()->createShaderProgram();

		if ( result )
		{
			ShaderTypeFlags matrixUboShaderMask = ShaderTypeFlag::eVertex | ShaderTypeFlag::ePixel;
			result->createObject( ShaderType::eVertex );
			result->createObject( ShaderType::ePixel );
			result->setSource( ShaderType::eVertex
				, renderPass.getVertexShaderSource( passFlags
					, textureFlags
					, programFlags
					, sceneFlags
					, invertNormals ) );
			result->setSource( ShaderType::ePixel
				, renderPass.getPixelShaderSource( passFlags
					, textureFlags
					, programFlags
					, sceneFlags
					, alphaFunc ) );
			auto geometry = renderPass.getGeometryShaderSource( passFlags
				, textureFlags
				, programFlags
				, sceneFlags );

			if ( !geometry.getSource().empty() )
			{
				addFlag( matrixUboShaderMask, ShaderTypeFlag::eGeometry );
				result->createObject( ShaderType::eGeometry );
				result->setSource( ShaderType::eGeometry, geometry );
			}

			createTextureVariables( *result
				, passFlags
				, textureFlags
				, programFlags );
		}

		return result;
	}

	void ShaderProgramCache::doAddAutomaticProgram( ShaderProgramSPtr program
		, PassFlags const & passFlags
		, TextureChannels const & textureFlags
		, ProgramFlags const & programFlags
		, SceneFlags const & sceneFlags
		, ComparisonFunc alphaFunc
		, bool invertNormals )
	{
		uint64_t key = makeKey( passFlags
			, textureFlags
			, programFlags
			, sceneFlags
			, alphaFunc
			, invertNormals );
		auto const & it = m_mapAutogenerated.find( key );

		if ( it == m_mapAutogenerated.end() )
		{
			m_mapAutogenerated.insert( { key, program } );
			doAddProgram( program, true );
		}
	}

	ShaderProgramSPtr ShaderProgramCache::doCreateBillboardProgram( RenderPass const & renderPass
		, PassFlags const & passFlags
		, TextureChannels const & textureFlags
		, ProgramFlags const & programFlags
		, SceneFlags const & sceneFlags
		, ComparisonFunc alphaFunc )const
	{
		auto & engine = *getEngine();
		auto & renderSystem = *engine.getRenderSystem();
		ShaderProgramSPtr result = getEngine()->getRenderSystem()->createShaderProgram();

		if ( result )
		{
			glsl::Shader strVtxShader;
			{
				using namespace glsl;
				auto writer = renderSystem.createGlslWriter();

				// Shader inputs
				auto position = writer.declAttribute< Vec4 >( ShaderProgram::Position );
				auto texture = writer.declAttribute< Vec2 >( ShaderProgram::Texture );
				auto center = writer.declAttribute< Vec3 >( cuT( "center" ) );
				auto gl_InstanceID( writer.declBuiltin< Int >( cuT( "gl_InstanceID" ) ) );
				auto gl_VertexID( writer.declBuiltin< Int >( cuT( "gl_VertexID" ) ) );
				UBO_MATRIX( writer );
				UBO_MODEL_MATRIX( writer );
				UBO_SCENE( writer );
				UBO_MODEL( writer );
				UBO_BILLBOARD( writer );

				// Shader outputs
				auto vtx_position = writer.declOutput< Vec3 >( cuT( "vtx_position" ) );
				auto vtx_curPosition = writer.declOutput< Vec3 >( cuT( "vtx_curPosition" ) );
				auto vtx_prvPosition = writer.declOutput< Vec3 >( cuT( "vtx_prvPosition" ) );
				auto vtx_normal = writer.declOutput< Vec3 >( cuT( "vtx_normal" ) );
				auto vtx_tangent = writer.declOutput< Vec3 >( cuT( "vtx_tangent" ) );
				auto vtx_bitangent = writer.declOutput< Vec3 >( cuT( "vtx_bitangent" ) );
				auto vtx_texture = writer.declOutput< Vec3 >( cuT( "vtx_texture" ) );
				auto vtx_instance = writer.declOutput< Int >( cuT( "vtx_instance" ) );
				auto vtx_material = writer.declOutput< Int >( cuT( "vtx_material" ) );
				auto gl_Position = writer.declBuiltin< Vec4 >( cuT( "gl_Position" ) );

				writer.implementFunction< void >( cuT( "main" ), [&]()
				{
					auto bbcenter = writer.declLocale( cuT( "bbcenter" ), writer.paren( c3d_mtxModel * vec4( center, 1.0 ) ).xyz() );
					auto toCamera = writer.declLocale( cuT( "toCamera" ), c3d_cameraPosition - bbcenter );
					toCamera.y() = 0.0_f;
					toCamera = normalize( toCamera );
					auto right = writer.declLocale( cuT( "right" ), vec3( c3d_curView[0][0], c3d_curView[1][0], c3d_curView[2][0] ) );
					auto up = writer.declLocale( cuT( "up" ), vec3( c3d_curView[0][1], c3d_curView[1][1], c3d_curView[2][1] ) );

					if ( !checkFlag( programFlags, ProgramFlag::eSpherical ) )
					{
						right = normalize( vec3( right.x(), 0.0, right.z() ) );
						up = vec3( 0.0_f, 1.0f, 0.0f );
					}

					vtx_material = c3d_materialIndex;
					vtx_normal = toCamera;
					vtx_tangent = up;
					vtx_bitangent = right;

					auto width = writer.declLocale( cuT( "width" ), c3d_dimensions.x() );
					auto height = writer.declLocale( cuT( "height" ), c3d_dimensions.y() );

					if ( checkFlag( programFlags, ProgramFlag::eFixedSize ) )
					{
						width = c3d_dimensions.x() / c3d_windowSize.x();
						height = c3d_dimensions.y() / c3d_windowSize.y();
					}

					vtx_position = bbcenter
						+ right * position.x() * width
						+ up * position.y() * height;

					vtx_texture = vec3( texture, 0.0 );
					vtx_instance = gl_InstanceID;
					auto curPosition = writer.declLocale( cuT( "curPosition" )
						, writer.paren( c3d_curView * vec4( vtx_position, 1.0 ) ).xyz() );
					auto prvPosition = writer.declLocale( cuT( "prvPosition" )
						, writer.paren( c3d_prvView * vec4( vtx_position, 1.0 ) ) );
					gl_Position = c3d_projection * vec4( curPosition, 1.0 );
					prvPosition = c3d_projection * prvPosition;
					vtx_curPosition = gl_Position.xyw();
					vtx_prvPosition = prvPosition.xyw();
				} );

				strVtxShader = writer.finalise();
			}

			glsl::Shader strPxlShader = renderPass.getPixelShaderSource( passFlags
				, textureFlags
				, programFlags
				, sceneFlags
				, alphaFunc );

			result->createObject( ShaderType::eVertex );
			result->createObject( ShaderType::ePixel );
			result->setSource( ShaderType::eVertex, strVtxShader );
			result->setSource( ShaderType::ePixel, strPxlShader );

			createTextureVariables( *result
				, passFlags
				, textureFlags
				, programFlags );
		}

		return result;
	}

	void ShaderProgramCache::doAddBillboardProgram( ShaderProgramSPtr p_program
		, PassFlags const & passFlags
		, TextureChannels const & textureFlags
		, ProgramFlags const & programFlags
		, SceneFlags const & sceneFlags
		, ComparisonFunc alphaFunc )
	{
		uint64_t key = makeKey( passFlags
			, textureFlags
			, programFlags
			, sceneFlags
			, alphaFunc
			, false );
		auto const & it = m_mapBillboards.find( key );

		if ( it == m_mapBillboards.end() )
		{
			m_mapBillboards.insert( { key, p_program } );
			doAddProgram( p_program, true );
		}
	}
}
