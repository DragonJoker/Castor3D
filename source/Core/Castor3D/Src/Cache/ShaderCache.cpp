#include "ShaderCache.hpp"

#include "Engine.hpp"

#include "Event/Frame/CleanupEvent.hpp"
#include "Event/Frame/InitialiseEvent.hpp"
#include "Material/Pass.hpp"
#include "Render/RenderPass.hpp"
#include "Shader/Program.hpp"

#include <GlslSource.hpp>

#include <Core/Device.hpp>

using namespace castor;

namespace castor3d
{
	namespace
	{
		uint64_t makeKey( PassFlags const & passFlags
			, TextureChannels const & textureFlags
			, ProgramFlags const & programFlags
			, SceneFlags const & sceneFlags
			, renderer::CompareOp alphaFunc
			, bool invertNormals )
		{
			return ( uint64_t( passFlags ) << 56 ) // Pass flags on 8 bits
				   | ( uint64_t( textureFlags ) << 44 ) // Texture flags on 12 bits
				   | ( uint64_t( programFlags ) << 28 ) // Program flags on 16 bits
				   | ( uint64_t( sceneFlags ) << 20 ) // SceneFlags on 8 bits
				   | ( uint64_t( alphaFunc ) << 12 ) // Alpha func on 8 bits
				   | ( uint64_t( invertNormals ? 0x01 : 0x00 ) );
		}
	}

	ShaderProgramCache::ShaderProgramCache( Engine & engine )
		: OwnedBy< Engine >( engine )
	{
	}

	ShaderProgramCache::~ShaderProgramCache()
	{
	}

	void ShaderProgramCache::cleanup()
	{
		for ( auto & program : m_arrayPrograms )
		{
			getEngine()->postEvent( makeFunctorEvent( EventType::ePreRender
				, [&program]()
				{
					program->cleanup();
				} ) );
		}
	}

	void ShaderProgramCache::clear()
	{
		m_mapBillboards.clear();
		m_mapAutogenerated.clear();
		m_arrayPrograms.clear();
	}

	ShaderProgramSPtr ShaderProgramCache::getNewProgram( bool initialise )
	{
		return doAddProgram( std::make_shared< ShaderProgram >( *getEngine()->getRenderSystem() ), initialise );
	}

	ShaderProgramSPtr ShaderProgramCache::getAutomaticProgram( RenderPass const & renderPass
		, PassFlags const & passFlags
		, TextureChannels const & textureFlags
		, ProgramFlags const & programFlags
		, SceneFlags const & sceneFlags
		, renderer::CompareOp alphaFunc
		, bool invertNormals )
	{
		if ( checkFlag( programFlags, ProgramFlag::eBillboards ) )
		{
			uint64_t key = makeKey( passFlags
				, textureFlags
				, programFlags
				, sceneFlags
				, alphaFunc
				, false );
			auto const & it = m_mapBillboards.find( key );

			if ( it != m_mapBillboards.end() )
			{
				return it->second;
			}
			else
			{
				auto result = doCreateBillboardProgram( renderPass
					, passFlags
					, textureFlags
					, programFlags
					, sceneFlags
					, alphaFunc );
				REQUIRE( result );
				return doAddBillboardProgram( std::move( result )
					, passFlags
					, textureFlags
					, programFlags
					, sceneFlags
					, alphaFunc );
			}
		}
		else
		{
			uint64_t key = makeKey( passFlags
				, textureFlags
				, programFlags
				, sceneFlags
				, alphaFunc
				, invertNormals );
			auto it = m_mapAutogenerated.find( key );

			if ( it != m_mapAutogenerated.end() )
			{
				return it->second;
			}
			else
			{
				auto result = doCreateAutomaticProgram( renderPass
					, passFlags
					, textureFlags
					, programFlags
					, sceneFlags
					, alphaFunc
					, invertNormals );
				REQUIRE( result );
				return doAddAutomaticProgram( std::move( result )
					, passFlags
					, textureFlags
					, programFlags
					, sceneFlags
					, alphaFunc
					, invertNormals );
			}
		}
	}

	ShaderProgramSPtr ShaderProgramCache::doAddProgram( ShaderProgramSPtr program
		, bool initialise )
	{
		m_arrayPrograms.push_back( program );

		if ( initialise )
		{
			getEngine()->sendEvent( makeFunctorEvent( EventType::ePreRender
				, [program]()
				{
					program->initialise();
				} ) );
		}

		return m_arrayPrograms.back();
	}

	ShaderProgramSPtr ShaderProgramCache::doCreateAutomaticProgram( RenderPass const & renderPass
		, PassFlags const & passFlags
		, TextureChannels const & textureFlags
		, ProgramFlags const & programFlags
		, SceneFlags const & sceneFlags
		, renderer::CompareOp alphaFunc
		, bool invertNormals )const
	{
		renderer::ShaderStageFlags matrixUboShaderMask = renderer::ShaderStageFlag::eVertex | renderer::ShaderStageFlag::eFragment;
		ShaderProgramSPtr result = std::make_shared< ShaderProgram >( *getEngine()->getRenderSystem() );
		result->setSource( renderer::ShaderStageFlag::eVertex
			, renderPass.getVertexShaderSource( passFlags
				, textureFlags
				, programFlags
				, sceneFlags
				, invertNormals ) );
		result->setSource( renderer::ShaderStageFlag::eFragment
			, renderPass.getPixelShaderSource( passFlags
				, textureFlags
				, programFlags
				, sceneFlags
				, alphaFunc ).getSource() );
		auto geometry = renderPass.getGeometryShaderSource( passFlags
			, textureFlags
			, programFlags
			, sceneFlags );

		if ( !geometry.getSource().empty() )
		{
			addFlag( matrixUboShaderMask, renderer::ShaderStageFlag::eGeometry );
			result->setSource( renderer::ShaderStageFlag::eGeometry, geometry );
		}

		return result;
	}

	ShaderProgramSPtr ShaderProgramCache::doAddAutomaticProgram( ShaderProgramSPtr program
		, PassFlags const & passFlags
		, TextureChannels const & textureFlags
		, ProgramFlags const & programFlags
		, SceneFlags const & sceneFlags
		, renderer::CompareOp alphaFunc
		, bool invertNormals )
	{
		uint64_t key = makeKey( passFlags
			, textureFlags
			, programFlags
			, sceneFlags
			, alphaFunc
			, invertNormals );
		auto const & it = m_mapAutogenerated.find( key );

		if ( it == m_mapAutogenerated.end() )
		{
			m_mapAutogenerated.insert( { key, program } );
			return doAddProgram( std::move( program ), true );
		}

		return it->second;
	}

	ShaderProgramSPtr ShaderProgramCache::doCreateBillboardProgram( RenderPass const & renderPass
		, PassFlags const & passFlags
		, TextureChannels const & textureFlags
		, ProgramFlags const & programFlags
		, SceneFlags const & sceneFlags
		, renderer::CompareOp alphaFunc )const
	{
		auto & engine = *getEngine();
		auto & renderSystem = *engine.getRenderSystem();
		glsl::Shader vtxShader;
		{
			using namespace glsl;
			auto writer = renderSystem.createGlslWriter();

			// Shader inputs
			auto position = writer.declAttribute< Vec4 >( cuT( "position" ), 0u );
			auto texture = writer.declAttribute< Vec2 >( cuT( "texcoord" ), 1u );
			auto center = writer.declAttribute< Vec3 >( cuT( "center" ), 2u );
			auto gl_InstanceID( writer.declBuiltin< Int >( writer.getInstanceID() ) );
			auto gl_VertexID( writer.declBuiltin< Int >( writer.getVertexID() ) );
			UBO_MATRIX( writer, MatrixUbo::BindingPoint, 0 );
			UBO_SCENE( writer, SceneUbo::BindingPoint, 0 );
			UBO_MODEL_MATRIX( writer, ModelMatrixUbo::BindingPoint, 0 );
			UBO_MODEL( writer, ModelUbo::BindingPoint, 0 );
			UBO_BILLBOARD( writer, BillboardUbo::BindingPoint, 0 );

			// Shader outputs
			uint32_t location{ 0u };
			auto vtx_worldPosition = writer.declOutput< Vec3 >( cuT( "vtx_worldPosition" ), RenderPass::VertexOutputs::WorldPositionLocation );
			auto vtx_curPosition = writer.declOutput< Vec3 >( cuT( "vtx_curPosition" ), RenderPass::VertexOutputs::CurPositionLocation );
			auto vtx_prvPosition = writer.declOutput< Vec3 >( cuT( "vtx_prvPosition" ), RenderPass::VertexOutputs::PrvPositionLocation );
			auto vtx_normal = writer.declOutput< Vec3 >( cuT( "vtx_normal" ), RenderPass::VertexOutputs::NormalLocation );
			auto vtx_tangent = writer.declOutput< Vec3 >( cuT( "vtx_tangent" ), RenderPass::VertexOutputs::TangentLocation );
			auto vtx_bitangent = writer.declOutput< Vec3 >( cuT( "vtx_bitangent" ), RenderPass::VertexOutputs::BitangentLocation );
			auto vtx_texture = writer.declOutput< Vec3 >( cuT( "vtx_texture" ), RenderPass::VertexOutputs::TextureLocation );
			auto vtx_instance = writer.declOutput< Int >( cuT( "vtx_instance" ), RenderPass::VertexOutputs::InstanceLocation );
			auto vtx_material = writer.declOutput< Int >( cuT( "vtx_material" ), RenderPass::VertexOutputs::MaterialLocation );
			auto out = gl_PerVertex{ writer };

			writer.implementFunction< void >( cuT( "main" ), [&]()
			{
				auto bbcenter = writer.declLocale( cuT( "bbcenter" ), writer.paren( c3d_mtxModel * vec4( center, 1.0 ) ).xyz() );
				auto toCamera = writer.declLocale( cuT( "toCamera" ), c3d_cameraPosition.xyz() - bbcenter );
				toCamera.y() = 0.0_f;
				toCamera = normalize( toCamera );
				auto right = writer.declLocale( cuT( "right" ), vec3( c3d_curView[0][0], c3d_curView[1][0], c3d_curView[2][0] ) );
				auto up = writer.declLocale( cuT( "up" ), vec3( c3d_curView[0][1], c3d_curView[1][1], c3d_curView[2][1] ) );

				if ( !checkFlag( programFlags, ProgramFlag::eSpherical ) )
				{
					right = normalize( vec3( right.x(), 0.0, right.z() ) );
					up = vec3( 0.0_f, 1.0f, 0.0f );
				}

				vtx_material = c3d_materialIndex;
				vtx_normal = toCamera;
				vtx_tangent = up;
				vtx_bitangent = right;

				auto width = writer.declLocale( cuT( "width" ), c3d_dimensions.x() );
				auto height = writer.declLocale( cuT( "height" ), c3d_dimensions.y() );

				if ( checkFlag( programFlags, ProgramFlag::eFixedSize ) )
				{
					width = c3d_dimensions.x() / c3d_windowSize.x();
					height = c3d_dimensions.y() / c3d_windowSize.y();
				}

				vtx_worldPosition = bbcenter
					+ right * position.x() * width
					+ up * position.y() * height;

				vtx_texture = vec3( texture, 0.0 );
				vtx_instance = gl_InstanceID;
				auto curPosition = writer.declLocale( cuT( "curPosition" )
					, writer.paren( c3d_curView * vec4( vtx_worldPosition, 1.0 ) ).xyz() );
				auto prvPosition = writer.declLocale( cuT( "prvPosition" )
					, writer.paren( c3d_prvView * vec4( vtx_worldPosition, 1.0 ) ) );
				out.gl_Position() = c3d_projection * vec4( curPosition, 1.0 );
				prvPosition = c3d_projection * prvPosition;
				vtx_curPosition = out.gl_Position().xyw();
				vtx_prvPosition = prvPosition.xyw();
			} );

			vtxShader = writer.finalise();
		}

		glsl::Shader pxlShader = renderPass.getPixelShaderSource( passFlags
			, textureFlags
			, programFlags
			, sceneFlags
			, alphaFunc );

		ShaderProgramSPtr result = std::make_shared< ShaderProgram >( *getEngine()->getRenderSystem() );
		result->setSource( renderer::ShaderStageFlag::eVertex, vtxShader );
		result->setSource( renderer::ShaderStageFlag::eFragment, pxlShader );
		return result;
	}

	ShaderProgramSPtr ShaderProgramCache::doAddBillboardProgram( ShaderProgramSPtr program
		, PassFlags const & passFlags
		, TextureChannels const & textureFlags
		, ProgramFlags const & programFlags
		, SceneFlags const & sceneFlags
		, renderer::CompareOp alphaFunc )
	{
		uint64_t key = makeKey( passFlags
			, textureFlags
			, programFlags
			, sceneFlags
			, alphaFunc
			, false );
		auto const & it = m_mapBillboards.find( key );

		if ( it == m_mapBillboards.end() )
		{
			m_mapBillboards.insert( { key, program } );
			return doAddProgram( std::move( program ), true );
		}

		return it->second;
	}
}
