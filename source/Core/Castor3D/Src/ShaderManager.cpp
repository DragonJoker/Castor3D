#include "ShaderManager.hpp"
#include "ShaderProgram.hpp"
#include "RenderSystem.hpp"

using namespace Castor3D;
using namespace Castor;

ShaderManager::ShaderManager()
	:	m_nbVerticesOut( 0 )
{
}

ShaderManager::~ShaderManager()
{
}

void ShaderManager::Update()
{
	m_arrayToDelete.clear();
}

void ShaderManager::Clear()
{
	ClearShaders();
	Update();
}

void ShaderManager::ClearShaders()
{
	m_arrayToDelete.insert( m_arrayToDelete.end(), m_arrayPrograms.begin(), m_arrayPrograms.end() );
	m_mapAutogenerated.clear();
	m_arrayPrograms.clear();
}

ShaderProgramBaseSPtr ShaderManager::GetNewProgram( eSHADER_LANGUAGE p_eLanguage )
{
	ShaderProgramBaseSPtr l_pReturn;

	if ( p_eLanguage != eSHADER_LANGUAGE_AUTO )
	{
		l_pReturn = m_pRenderSystem->CreateShaderProgram( p_eLanguage );
	}
	else
	{
		l_pReturn = m_pRenderSystem->CreateShaderProgram();
	}

	if ( l_pReturn )
	{
		m_arrayPrograms.push_back( l_pReturn );
	}

	return l_pReturn;
}

ShaderProgramBaseSPtr ShaderManager::GetAutomaticProgram( uint32_t p_uiTextureFlags, uint32_t p_uiProgramFlags )
{
	ShaderProgramBaseSPtr l_pReturn;
	uint64_t l_key = p_uiTextureFlags | ( uint64_t( p_uiProgramFlags ) << 32 );
	ShaderProgramWPtrUInt64MapConstIt l_it = m_mapAutogenerated.find( l_key );

	if ( l_it != m_mapAutogenerated.end() )
	{
		l_pReturn = l_it->second.lock();
	}
	else
	{
		l_pReturn = GetNewProgram();

		for ( int i = 0; i < eSHADER_MODEL_COUNT; ++i )
		{
			l_pReturn->SetSource( eSHADER_TYPE_VERTEX,	eSHADER_MODEL( i ), l_pReturn->GetVertexShaderSource( p_uiProgramFlags ) );
			l_pReturn->SetSource( eSHADER_TYPE_PIXEL,	eSHADER_MODEL( i ), l_pReturn->GetPixelShaderSource( p_uiTextureFlags ) );
		}

		m_mapAutogenerated.insert( std::make_pair( l_key, l_pReturn ) );
	}

	return l_pReturn;
}
