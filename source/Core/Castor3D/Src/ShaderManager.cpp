#include "ShaderManager.hpp"

#include "FrameVariableBuffer.hpp"
#include "OneFrameVariable.hpp"
#include "Pipeline.hpp"
#include "RenderSystem.hpp"
#include "RenderTechnique.hpp"
#include "ShaderProgram.hpp"

using namespace Castor3D;
using namespace Castor;

ShaderManager::ShaderManager()
	:	m_nbVerticesOut( 0 )
{
}

ShaderManager::~ShaderManager()
{
}

void ShaderManager::Update()
{
	m_arrayToDelete.clear();
}

void ShaderManager::Clear()
{
	ClearShaders();
	Update();
}

void ShaderManager::ClearShaders()
{
	m_arrayToDelete.insert( m_arrayToDelete.end(), m_arrayPrograms.begin(), m_arrayPrograms.end() );
	m_mapAutogenerated.clear();
	m_arrayPrograms.clear();
}

ShaderProgramBaseSPtr ShaderManager::GetNewProgram( eSHADER_LANGUAGE p_eLanguage )
{
	ShaderProgramBaseSPtr l_pReturn;

	if ( p_eLanguage != eSHADER_LANGUAGE_AUTO )
	{
		l_pReturn = m_pRenderSystem->CreateShaderProgram( p_eLanguage );
	}
	else
	{
		l_pReturn = m_pRenderSystem->CreateShaderProgram();
	}

	if ( l_pReturn )
	{
		m_arrayPrograms.push_back( l_pReturn );
	}

	return l_pReturn;
}

ShaderProgramBaseSPtr ShaderManager::GetAutomaticProgram( RenderTechniqueBase const & p_technique, uint32_t p_uiTextureFlags, uint32_t p_uiProgramFlags )
{
	ShaderProgramBaseSPtr l_pReturn;
	uint64_t l_key = p_uiTextureFlags | ( uint64_t( p_uiProgramFlags ) << 32 );
	ShaderProgramWPtrUInt64MapConstIt l_it = m_mapAutogenerated.find( l_key );

	if ( l_it != m_mapAutogenerated.end() )
	{
		l_pReturn = l_it->second.lock();
	}
	else
	{
		l_pReturn = GetNewProgram();

		if ( l_pReturn )
		{
			for ( int i = 0; i < eSHADER_MODEL_COUNT; ++i )
			{
				l_pReturn->SetSource( eSHADER_TYPE_VERTEX, eSHADER_MODEL( i ), p_technique.GetVertexShaderSource( p_uiProgramFlags ) );
				l_pReturn->SetSource( eSHADER_TYPE_PIXEL, eSHADER_MODEL( i ), p_technique.GetPixelShaderSource( p_uiTextureFlags ) );
			}

			CreateTextureVariables( *l_pReturn, p_uiTextureFlags );
			auto l_matrixBuffer = CreateMatrixBuffer( *l_pReturn, MASK_SHADER_TYPE_VERTEX | MASK_SHADER_TYPE_PIXEL );
			auto l_pSceneBuffer = CreateSceneBuffer( *l_pReturn, MASK_SHADER_TYPE_PIXEL );
			auto l_pPassBuffer = CreatePassBuffer( *l_pReturn, MASK_SHADER_TYPE_PIXEL );
			m_mapAutogenerated.insert( std::make_pair( l_key, l_pReturn ) );
		}
	}

	return l_pReturn;
}

FrameVariableBufferSPtr ShaderManager::CreateMatrixBuffer( ShaderProgramBase & p_shader, uint32_t p_shaderMask )
{
	auto l_pMatrixBuffer = m_pRenderSystem->CreateFrameVariableBuffer( ShaderProgramBase::BufferMatrix );
	l_pMatrixBuffer->CreateVariable( p_shader, eFRAME_VARIABLE_TYPE_MAT4X4R, Pipeline::MtxProjection, 1 );
	l_pMatrixBuffer->CreateVariable( p_shader, eFRAME_VARIABLE_TYPE_MAT4X4R, Pipeline::MtxModel, 1 );
	l_pMatrixBuffer->CreateVariable( p_shader, eFRAME_VARIABLE_TYPE_MAT4X4R, Pipeline::MtxView, 1 );
	l_pMatrixBuffer->CreateVariable( p_shader, eFRAME_VARIABLE_TYPE_MAT4X4R, Pipeline::MtxModelView, 1 );
	l_pMatrixBuffer->CreateVariable( p_shader, eFRAME_VARIABLE_TYPE_MAT4X4R, Pipeline::MtxProjectionView, 1 );
	l_pMatrixBuffer->CreateVariable( p_shader, eFRAME_VARIABLE_TYPE_MAT4X4R, Pipeline::MtxProjectionModelView, 1 );
	l_pMatrixBuffer->CreateVariable( p_shader, eFRAME_VARIABLE_TYPE_MAT4X4R, Pipeline::MtxNormal, 1 );
	l_pMatrixBuffer->CreateVariable( p_shader, eFRAME_VARIABLE_TYPE_MAT4X4R, Pipeline::MtxTexture0, 1 );
	l_pMatrixBuffer->CreateVariable( p_shader, eFRAME_VARIABLE_TYPE_MAT4X4R, Pipeline::MtxTexture1, 1 );
	l_pMatrixBuffer->CreateVariable( p_shader, eFRAME_VARIABLE_TYPE_MAT4X4R, Pipeline::MtxTexture2, 1 );
	l_pMatrixBuffer->CreateVariable( p_shader, eFRAME_VARIABLE_TYPE_MAT4X4R, Pipeline::MtxTexture3, 1 );
	l_pMatrixBuffer->CreateVariable( p_shader, eFRAME_VARIABLE_TYPE_MAT4X4R, Pipeline::MtxBones, 100 );
	p_shader.AddFrameVariableBuffer( l_pMatrixBuffer, p_shaderMask );
	return l_pMatrixBuffer;
}

FrameVariableBufferSPtr ShaderManager::CreateSceneBuffer( ShaderProgramBase & p_shader, uint32_t p_shaderMask )
{
	auto l_pSceneBuffer = m_pRenderSystem->CreateFrameVariableBuffer( ShaderProgramBase::BufferScene );
	l_pSceneBuffer->CreateVariable( p_shader, eFRAME_VARIABLE_TYPE_INT, ShaderProgramBase::LightsCount, 1 );
	l_pSceneBuffer->CreateVariable( p_shader, eFRAME_VARIABLE_TYPE_VEC4F, ShaderProgramBase::AmbientLight, 1 );
	l_pSceneBuffer->CreateVariable( p_shader, eFRAME_VARIABLE_TYPE_VEC3R, ShaderProgramBase::CameraPos, 1 );
	p_shader.AddFrameVariableBuffer( l_pSceneBuffer, p_shaderMask );
	return l_pSceneBuffer;
}

FrameVariableBufferSPtr ShaderManager::CreatePassBuffer( ShaderProgramBase & p_shader, uint32_t p_shaderMask )
{
	auto l_pPassBuffer = m_pRenderSystem->CreateFrameVariableBuffer( ShaderProgramBase::BufferPass );
	l_pPassBuffer->CreateVariable( p_shader, eFRAME_VARIABLE_TYPE_VEC4F, ShaderProgramBase::MatAmbient, 1 );
	l_pPassBuffer->CreateVariable( p_shader, eFRAME_VARIABLE_TYPE_VEC4F, ShaderProgramBase::MatDiffuse, 1 );
	l_pPassBuffer->CreateVariable( p_shader, eFRAME_VARIABLE_TYPE_VEC4F, ShaderProgramBase::MatEmissive, 1 );
	l_pPassBuffer->CreateVariable( p_shader, eFRAME_VARIABLE_TYPE_VEC4F, ShaderProgramBase::MatSpecular, 1 );
	l_pPassBuffer->CreateVariable( p_shader, eFRAME_VARIABLE_TYPE_FLOAT, ShaderProgramBase::MatShininess, 1 );
	l_pPassBuffer->CreateVariable( p_shader, eFRAME_VARIABLE_TYPE_FLOAT, ShaderProgramBase::MatOpacity, 1 );
	p_shader.AddFrameVariableBuffer( l_pPassBuffer, p_shaderMask );
	return l_pPassBuffer;
}

void ShaderManager::CreateTextureVariables( ShaderProgramBase & p_shader, uint32_t p_uiTextureFlags )
{
	p_shader.CreateFrameVariable( ShaderProgramBase::Lights, eSHADER_TYPE_PIXEL );

	if ( p_uiTextureFlags & eTEXTURE_CHANNEL_AMBIENT )
	{
		p_shader.CreateFrameVariable( ShaderProgramBase::MapAmbient, eSHADER_TYPE_PIXEL );
	}

	if ( p_uiTextureFlags & eTEXTURE_CHANNEL_COLOUR )
	{
		p_shader.CreateFrameVariable( ShaderProgramBase::MapColour, eSHADER_TYPE_PIXEL );
	}

	if ( p_uiTextureFlags & eTEXTURE_CHANNEL_DIFFUSE )
	{
		p_shader.CreateFrameVariable( ShaderProgramBase::MapDiffuse, eSHADER_TYPE_PIXEL );
	}

	if ( p_uiTextureFlags & eTEXTURE_CHANNEL_NORMAL )
	{
		p_shader.CreateFrameVariable( ShaderProgramBase::MapNormal, eSHADER_TYPE_PIXEL );
	}

	if ( p_uiTextureFlags & eTEXTURE_CHANNEL_SPECULAR )
	{
		p_shader.CreateFrameVariable( ShaderProgramBase::MapSpecular, eSHADER_TYPE_PIXEL );
	}

	if ( p_uiTextureFlags & eTEXTURE_CHANNEL_OPACITY )
	{
		p_shader.CreateFrameVariable( ShaderProgramBase::MapOpacity, eSHADER_TYPE_PIXEL );
	}

	if ( p_uiTextureFlags & eTEXTURE_CHANNEL_GLOSS )
	{
		p_shader.CreateFrameVariable( ShaderProgramBase::MapGloss, eSHADER_TYPE_PIXEL );
	}

	if ( p_uiTextureFlags & eTEXTURE_CHANNEL_HEIGHT )
	{
		p_shader.CreateFrameVariable( ShaderProgramBase::MapHeight, eSHADER_TYPE_PIXEL );
	}
}
