#include "ShaderManager.hpp"

#include "Engine.hpp"
#include "FrameVariableBuffer.hpp"
#include "InitialiseEvent.hpp"
#include "CleanupEvent.hpp"
#include "OneFrameVariable.hpp"
#include "Pipeline.hpp"
#include "RenderSystem.hpp"
#include "RenderTechnique.hpp"
#include "ShaderProgram.hpp"

using namespace Castor;

namespace Castor3D
{
	ShaderManager::ShaderManager( Engine & p_engine )
		: OwnedBy< Engine >( p_engine )
		, m_nbVerticesOut( 0 )
	{
	}

	ShaderManager::~ShaderManager()
	{
	}

	void ShaderManager::Cleanup()
	{
		for ( auto l_program : m_arrayPrograms )
		{
			GetOwner()->PostEvent( MakeCleanupEvent( *l_program ) );
		}
	}

	void ShaderManager::Clear()
	{
		m_mapAutogenerated.clear();
		m_arrayPrograms.clear();
	}

	ShaderProgramBaseSPtr ShaderManager::GetNewProgram( eSHADER_LANGUAGE p_eLanguage )
	{
		ShaderProgramBaseSPtr l_return;

		if ( p_eLanguage != eSHADER_LANGUAGE_AUTO )
		{
			l_return = m_renderSystem->CreateShaderProgram( p_eLanguage );
		}
		else
		{
			l_return = m_renderSystem->CreateShaderProgram();
		}

		if ( l_return )
		{
			m_arrayPrograms.push_back( l_return );
		}

		return l_return;
	}

	ShaderProgramBaseSPtr ShaderManager::GetAutomaticProgram( RenderTechniqueBase const & p_technique, uint32_t p_uiTextureFlags, uint32_t p_uiProgramFlags )
	{
		ShaderProgramBaseSPtr l_return;
		uint64_t l_key = p_uiTextureFlags | ( uint64_t( p_uiProgramFlags ) << 32 );
		ShaderProgramWPtrUInt64MapConstIt l_it = m_mapAutogenerated.find( l_key );

		if ( l_it != m_mapAutogenerated.end() )
		{
			l_return = l_it->second.lock();
		}
		else
		{
			l_return = GetNewProgram();

			if ( l_return )
			{
				eSHADER_MODEL l_model = GetOwner()->GetRenderSystem()->GetMaxShaderModel();
				l_return->SetSource( eSHADER_TYPE_VERTEX, l_model, l_return->GetVertexShaderSource( p_uiProgramFlags ) );
				l_return->SetSource( eSHADER_TYPE_PIXEL, l_model, p_technique.GetPixelShaderSource( p_uiTextureFlags ) );

				CreateTextureVariables( *l_return, p_uiTextureFlags );
				auto l_matrixBuffer = CreateMatrixBuffer( *l_return, MASK_SHADER_TYPE_VERTEX | MASK_SHADER_TYPE_PIXEL );
				auto l_pSceneBuffer = CreateSceneBuffer( *l_return, MASK_SHADER_TYPE_PIXEL );
				auto l_pPassBuffer = CreatePassBuffer( *l_return, MASK_SHADER_TYPE_PIXEL );
				m_mapAutogenerated.insert( std::make_pair( l_key, l_return ) );
			}
		}

		return l_return;
	}

	FrameVariableBufferSPtr ShaderManager::CreateMatrixBuffer( ShaderProgramBase & p_shader, uint32_t p_shaderMask )
	{
		auto l_pMatrixBuffer = m_renderSystem->CreateFrameVariableBuffer( ShaderProgramBase::BufferMatrix );
		l_pMatrixBuffer->CreateVariable( p_shader, eFRAME_VARIABLE_TYPE_MAT4X4R, Pipeline::MtxProjection, 1 );
		l_pMatrixBuffer->CreateVariable( p_shader, eFRAME_VARIABLE_TYPE_MAT4X4R, Pipeline::MtxModel, 1 );
		l_pMatrixBuffer->CreateVariable( p_shader, eFRAME_VARIABLE_TYPE_MAT4X4R, Pipeline::MtxView, 1 );
		l_pMatrixBuffer->CreateVariable( p_shader, eFRAME_VARIABLE_TYPE_MAT4X4R, Pipeline::MtxModelView, 1 );
		l_pMatrixBuffer->CreateVariable( p_shader, eFRAME_VARIABLE_TYPE_MAT4X4R, Pipeline::MtxProjectionView, 1 );
		l_pMatrixBuffer->CreateVariable( p_shader, eFRAME_VARIABLE_TYPE_MAT4X4R, Pipeline::MtxProjectionModelView, 1 );
		l_pMatrixBuffer->CreateVariable( p_shader, eFRAME_VARIABLE_TYPE_MAT4X4R, Pipeline::MtxNormal, 1 );

		for ( uint32_t i = 0; i < C3D_MAX_TEXTURE_MATRICES; ++i )
		{
			l_pMatrixBuffer->CreateVariable( p_shader, eFRAME_VARIABLE_TYPE_MAT4X4R, Pipeline::MtxTexture[i], 1 );
		}

		l_pMatrixBuffer->CreateVariable( p_shader, eFRAME_VARIABLE_TYPE_MAT4X4R, Pipeline::MtxBones, 100 );
		p_shader.AddFrameVariableBuffer( l_pMatrixBuffer, p_shaderMask );
		return l_pMatrixBuffer;
	}

	FrameVariableBufferSPtr ShaderManager::CreateSceneBuffer( ShaderProgramBase & p_shader, uint32_t p_shaderMask )
	{
		auto l_pSceneBuffer = m_renderSystem->CreateFrameVariableBuffer( ShaderProgramBase::BufferScene );
		l_pSceneBuffer->CreateVariable( p_shader, eFRAME_VARIABLE_TYPE_VEC4F, ShaderProgramBase::AmbientLight, 1 );
		l_pSceneBuffer->CreateVariable( p_shader, eFRAME_VARIABLE_TYPE_VEC4F, ShaderProgramBase::BackgroundColour, 1 );
		l_pSceneBuffer->CreateVariable( p_shader, eFRAME_VARIABLE_TYPE_VEC4I, ShaderProgramBase::LightsCount, 1 );
		l_pSceneBuffer->CreateVariable( p_shader, eFRAME_VARIABLE_TYPE_VEC3R, ShaderProgramBase::CameraPos, 1 );
		p_shader.AddFrameVariableBuffer( l_pSceneBuffer, p_shaderMask );
		return l_pSceneBuffer;
	}

	FrameVariableBufferSPtr ShaderManager::CreatePassBuffer( ShaderProgramBase & p_shader, uint32_t p_shaderMask )
	{
		auto l_pPassBuffer = m_renderSystem->CreateFrameVariableBuffer( ShaderProgramBase::BufferPass );
		l_pPassBuffer->CreateVariable( p_shader, eFRAME_VARIABLE_TYPE_VEC4F, ShaderProgramBase::MatAmbient, 1 );
		l_pPassBuffer->CreateVariable( p_shader, eFRAME_VARIABLE_TYPE_VEC4F, ShaderProgramBase::MatDiffuse, 1 );
		l_pPassBuffer->CreateVariable( p_shader, eFRAME_VARIABLE_TYPE_VEC4F, ShaderProgramBase::MatEmissive, 1 );
		l_pPassBuffer->CreateVariable( p_shader, eFRAME_VARIABLE_TYPE_VEC4F, ShaderProgramBase::MatSpecular, 1 );
		l_pPassBuffer->CreateVariable( p_shader, eFRAME_VARIABLE_TYPE_FLOAT, ShaderProgramBase::MatShininess, 1 );
		l_pPassBuffer->CreateVariable( p_shader, eFRAME_VARIABLE_TYPE_FLOAT, ShaderProgramBase::MatOpacity, 1 );
		p_shader.AddFrameVariableBuffer( l_pPassBuffer, p_shaderMask );
		return l_pPassBuffer;
	}

	void ShaderManager::CreateTextureVariables( ShaderProgramBase & p_shader, uint32_t p_uiTextureFlags )
	{
		p_shader.CreateFrameVariable( ShaderProgramBase::Lights, eSHADER_TYPE_PIXEL );

		if ( p_uiTextureFlags & eTEXTURE_CHANNEL_AMBIENT )
		{
			p_shader.CreateFrameVariable( ShaderProgramBase::MapAmbient, eSHADER_TYPE_PIXEL );
		}

		if ( p_uiTextureFlags & eTEXTURE_CHANNEL_COLOUR )
		{
			p_shader.CreateFrameVariable( ShaderProgramBase::MapColour, eSHADER_TYPE_PIXEL );
		}

		if ( p_uiTextureFlags & eTEXTURE_CHANNEL_DIFFUSE )
		{
			p_shader.CreateFrameVariable( ShaderProgramBase::MapDiffuse, eSHADER_TYPE_PIXEL );
		}

		if ( p_uiTextureFlags & eTEXTURE_CHANNEL_NORMAL )
		{
			p_shader.CreateFrameVariable( ShaderProgramBase::MapNormal, eSHADER_TYPE_PIXEL );
		}

		if ( p_uiTextureFlags & eTEXTURE_CHANNEL_SPECULAR )
		{
			p_shader.CreateFrameVariable( ShaderProgramBase::MapSpecular, eSHADER_TYPE_PIXEL );
		}

		if ( p_uiTextureFlags & eTEXTURE_CHANNEL_OPACITY )
		{
			p_shader.CreateFrameVariable( ShaderProgramBase::MapOpacity, eSHADER_TYPE_PIXEL );
		}

		if ( p_uiTextureFlags & eTEXTURE_CHANNEL_GLOSS )
		{
			p_shader.CreateFrameVariable( ShaderProgramBase::MapGloss, eSHADER_TYPE_PIXEL );
		}

		if ( p_uiTextureFlags & eTEXTURE_CHANNEL_HEIGHT )
		{
			p_shader.CreateFrameVariable( ShaderProgramBase::MapHeight, eSHADER_TYPE_PIXEL );
		}
	}
}
