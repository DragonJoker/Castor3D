#include "Castor3D/Cache/ShaderCache.hpp"

#include "Castor3D/Engine.hpp"
#include "Castor3D/Event/Frame/CleanupEvent.hpp"
#include "Castor3D/Event/Frame/InitialiseEvent.hpp"
#include "Castor3D/Render/RenderPass.hpp"
#include "Castor3D/Render/RenderSystem.hpp"
#include "Castor3D/Shader/Program.hpp"

#include <ShaderWriter/Source.hpp>

#include <ashespp/Core/Device.hpp>

namespace castor3d
{
	ShaderProgramCache::ShaderProgramCache( Engine & engine )
		: OwnedBy< Engine >( engine )
	{
	}

	ShaderProgramCache::~ShaderProgramCache()
	{
	}

	void ShaderProgramCache::clear()
	{
		auto lock( castor::makeUniqueLock( m_mutex ) );
		m_autogenerated.clear();
		m_programs.clear();
	}

	ShaderProgramSPtr ShaderProgramCache::getNewProgram( castor::String const & name
		, bool initialise )
	{
		auto result = std::make_shared< ShaderProgram >( name , *getEngine()->getRenderSystem() );
		auto lock( castor::makeUniqueLock( m_mutex ) );
		doAddProgram( result );
		return result;
	}

	ShaderProgramSPtr ShaderProgramCache::doFindAutomaticProgram( PipelineFlags const & flags )
	{
		auto it = std::find_if( m_autogenerated.begin()
			, m_autogenerated.end()
			, [&flags]( AutoGeneratedProgram const & lookup )
			{
				return lookup.flags == flags;
			} );

		if ( it != m_autogenerated.end() )
		{
			return it->program;
		}

		return nullptr;
	}

	ShaderProgramSPtr ShaderProgramCache::getAutomaticProgram( SceneRenderPass const & renderPass
		, PipelineFlags const & flags )
	{
		auto lock( castor::makeUniqueLock( m_mutex ) );
		auto result = doFindAutomaticProgram( flags );

		if ( result )
		{
			return result;
		}

		result = doCreateAutomaticProgram( renderPass, flags );
		CU_Require( result );
		doAddAutomaticProgram( result, flags );
		return result;
	}

	ShaderProgramSPtr ShaderProgramCache::doCreateAutomaticProgram( SceneRenderPass const & renderPass
		, PipelineFlags const & flags )const
	{
		ShaderProgramSPtr result = std::make_shared< ShaderProgram >( renderPass.getName(), *getEngine()->getRenderSystem() );
		result->setSource( VK_SHADER_STAGE_VERTEX_BIT
			, renderPass.getVertexShaderSource( flags ) );
		result->setSource( VK_SHADER_STAGE_FRAGMENT_BIT
			, renderPass.getPixelShaderSource( flags ) );
		auto geometry = renderPass.getGeometryShaderSource( flags );

		if ( geometry )
		{
			result->setSource( VK_SHADER_STAGE_GEOMETRY_BIT
				, std::move( geometry ) );
		}

		return result;
	}

	void ShaderProgramCache::doAddAutomaticProgram( ShaderProgramSPtr program
		, PipelineFlags const & flags )
	{
		m_autogenerated.push_back( { flags, program } );
		doAddProgram( program );
	}

	void ShaderProgramCache::doAddProgram( ShaderProgramSPtr program )
	{
		m_programs.push_back( std::move( program ) );
	}
}
