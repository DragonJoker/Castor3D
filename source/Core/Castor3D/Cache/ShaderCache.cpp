#include "Castor3D/Cache/ShaderCache.hpp"

#include "Castor3D/Engine.hpp"
#include "Castor3D/Render/RenderNodesPass.hpp"
#include "Castor3D/Render/RenderSystem.hpp"
#include "Castor3D/Shader/Program.hpp"

#include <ShaderWriter/Source.hpp>
#include <ShaderWriter/GraphicsPipelineWriter.hpp>

#include <ashespp/Core/Device.hpp>

namespace castor3d
{
	ShaderProgramCache::ShaderProgramCache( Engine & engine )
		: OwnedBy< Engine >( engine )
	{
	}

	void ShaderProgramCache::clear()
	{
		auto lock( castor::makeUniqueLock( m_mutex ) );
		m_autoGenerated.clear();
		m_programs.clear();
	}

	ShaderProgramRPtr ShaderProgramCache::getNewProgram( castor::String const & name
		, bool initialise )
	{
		auto result = castor::makeUnique< ShaderProgram >( name , *getEngine()->getRenderSystem() );
		auto lock( castor::makeUniqueLock( m_mutex ) );
		auto ret = result.get();
		doAddProgram( std::move( result ) );
		return ret;
	}

	ShaderProgramRPtr ShaderProgramCache::getAutomaticProgram( RenderNodesPass const & renderPass
		, PipelineFlags const & flags )
	{
		auto lock( castor::makeUniqueLock( m_mutex ) );

		if ( auto result = doFindAutomaticProgram( renderPass, flags ) )
		{
			return result;
		}

		auto result = doCreateAutomaticProgram( renderPass, flags );
		CU_Require( result );
		auto ret = result.get();
		doAddAutomaticProgram( std::move( result ), renderPass, flags );
		return ret;
	}

	ShaderProgramRPtr ShaderProgramCache::doFindAutomaticProgram( RenderNodesPass const & renderPass
		, PipelineFlags const & flags )
	{
		auto it = std::find_if( m_autoGenerated.begin()
			, m_autoGenerated.end()
			, [&flags, &renderPass]( AutoGeneratedProgram const & lookup )
			{
				return renderPass.getDeferredLightingFilter() == lookup.deferredLightingFilter
					&& renderPass.getParallaxOcclusionFilter() == lookup.parallaxOcclusionFilter
					&& lookup.flags == flags;
			} );

		if ( it != m_autoGenerated.end() )
		{
			return it->program;
		}

		return nullptr;
	}

	ShaderProgramUPtr ShaderProgramCache::doCreateAutomaticProgram( RenderNodesPass const & renderPass
		, PipelineFlags const & flags )const
	{
		auto builderType = ( ( getEngine()->hasMeshShaders() && flags.usesMesh() )
			? ( getEngine()->getRenderDevice()->prefersMeshShaderEXT()
				? sdw::ShaderStage::eModernGraphicsEXT
				: sdw::ShaderStage::eModernGraphicsNV )
			: ast::ShaderStage::eTraditionalGraphics );
		ast::ShaderBuilder builder{ builderType, & getEngine()->getShaderAllocator() };
		renderPass.getSubmeshShaderSource( flags, builder );
		renderPass.getPixelShaderSource( flags, builder );
		auto result = castor::makeUnique< ShaderProgram >( renderPass.getName(), *getEngine()->getRenderSystem() );
		result->setSource( builder.releaseShader() );
		return result;
	}

	void ShaderProgramCache::doAddAutomaticProgram( ShaderProgramUPtr program
		, RenderNodesPass const & renderPass
		, PipelineFlags const & flags )
	{
		m_autoGenerated.push_back( { flags
			, renderPass.getDeferredLightingFilter()
			, renderPass.getParallaxOcclusionFilter()
			, program.get() } );
		doAddProgram( std::move( program ) );
	}

	void ShaderProgramCache::doAddProgram( ShaderProgramUPtr program )
	{
		m_programs.push_back( std::move( program ) );
	}
}
