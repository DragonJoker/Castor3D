#include "Castor3D/Cache/ShaderCache.hpp"

#include "Castor3D/Engine.hpp"
#include "Castor3D/Render/RenderNodesPass.hpp"
#include "Castor3D/Render/RenderSystem.hpp"
#include "Castor3D/Shader/Program.hpp"

#include <ShaderWriter/Source.hpp>

#include <ashespp/Core/Device.hpp>

namespace castor3d
{
	ShaderProgramCache::ShaderProgramCache( Engine & engine )
		: OwnedBy< Engine >( engine )
	{
	}

	ShaderProgramCache::~ShaderProgramCache()
	{
	}

	void ShaderProgramCache::clear()
	{
		auto lock( castor::makeUniqueLock( m_mutex ) );
		m_autogenerated.clear();
		m_programs.clear();
	}

	ShaderProgramSPtr ShaderProgramCache::getNewProgram( castor::String const & name
		, bool initialise )
	{
		auto result = std::make_shared< ShaderProgram >( name , *getEngine()->getRenderSystem() );
		auto lock( castor::makeUniqueLock( m_mutex ) );
		doAddProgram( result );
		return result;
	}

	ShaderProgramSPtr ShaderProgramCache::doFindAutomaticProgram( PipelineFlags const & flags )
	{
		auto it = std::find_if( m_autogenerated.begin()
			, m_autogenerated.end()
			, [&flags]( AutoGeneratedProgram const & lookup )
			{
				return lookup.flags == flags;
			} );

		if ( it != m_autogenerated.end() )
		{
			return it->program;
		}

		return nullptr;
	}

	ShaderProgramSPtr ShaderProgramCache::getAutomaticProgram( RenderNodesPass const & renderPass
		, PipelineFlags const & flags )
	{
		auto lock( castor::makeUniqueLock( m_mutex ) );
		auto result = doFindAutomaticProgram( flags );

		if ( result )
		{
			return result;
		}

		result = doCreateAutomaticProgram( renderPass, flags );
		CU_Require( result );
		doAddAutomaticProgram( result, flags );
		return result;
	}

	ShaderProgramSPtr ShaderProgramCache::doCreateAutomaticProgram( RenderNodesPass const & renderPass
		, PipelineFlags const & flags )const
	{
		ShaderProgramSPtr result = std::make_shared< ShaderProgram >( renderPass.getName(), *getEngine()->getRenderSystem() );

		if ( getEngine()->hasMeshShaders()
			&& checkFlag( flags.programFlags, ProgramFlag::eHasMesh ) )
		{
			if ( checkFlag( flags.programFlags, ProgramFlag::eHasTask ) )
			{
				auto task = renderPass.getTaskShaderSource( flags );

				if ( task )
				{
					result->setSource( VK_SHADER_STAGE_TASK_BIT_NV
						, std::move( task ) );
				}
			}

			result->setSource( VK_SHADER_STAGE_MESH_BIT_NV
				, renderPass.getMeshShaderSource( flags ) );
		}
		else
		{
			result->setSource( VK_SHADER_STAGE_VERTEX_BIT
				, renderPass.getVertexShaderSource( flags ) );

			auto hull = renderPass.getHullShaderSource( flags );

			if ( hull )
			{
				result->setSource( VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT
					, std::move( hull ) );
			}

			auto domain = renderPass.getDomainShaderSource( flags );

			if ( domain )
			{
				result->setSource( VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT
					, std::move( domain ) );
			}

			auto geometry = renderPass.getGeometryShaderSource( flags );

			if ( geometry )
			{
				result->setSource( VK_SHADER_STAGE_GEOMETRY_BIT
					, std::move( geometry ) );
			}
		}

		result->setSource( VK_SHADER_STAGE_FRAGMENT_BIT
			, renderPass.getPixelShaderSource( flags ) );
		return result;
	}

	void ShaderProgramCache::doAddAutomaticProgram( ShaderProgramSPtr program
		, PipelineFlags const & flags )
	{
		m_autogenerated.push_back( { flags, program } );
		doAddProgram( program );
	}

	void ShaderProgramCache::doAddProgram( ShaderProgramSPtr program )
	{
		m_programs.push_back( std::move( program ) );
	}
}
