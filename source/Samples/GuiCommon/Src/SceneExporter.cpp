#include "SceneExporter.hpp"

#include <Engine.hpp>
#include <Cache/CacheView.hpp>
#include <Material/Material.hpp>
#include <Material/LegacyPass.hpp>
#include <Mesh/Mesh.hpp>
#include <Mesh/Submesh.hpp>
#include <Mesh/Vertex.hpp>
#include <Mesh/Buffer/GeometryBuffers.hpp>
#include <Mesh/Buffer/IndexBuffer.hpp>
#include <Mesh/Buffer/VertexBuffer.hpp>
#include <Render/RenderWindow.hpp>
#include <Scene/Scene.hpp>
#include <Texture/Sampler.hpp>
#include <Texture/TextureLayout.hpp>
#include <Texture/TextureUnit.hpp>

#include <Data/BinaryFile.hpp>

#include <iomanip>

using namespace Castor3D;
using namespace Castor;

namespace GuiCommon
{
	namespace
	{
		template< typename TObj, typename TKey >
		bool ParseCollection( Engine * p_engine, Collection< TObj, TKey > & p_collection, BinaryChunk & p_chunk, typename TObj::BinaryParser p_parser )
		{
			bool result = true;
			p_collection.lock();
			auto it = p_collection.begin();

			while ( result && it != p_collection.end() )
			{
				result = p_parser.Fill( *it->second, p_chunk );
				++it;
			}

			p_collection.unlock();
			return result;
		}

		template< typename TObj, typename TKey >
		bool ParseManager( Engine * p_engine, Cache< TKey, TObj > & p_manager, BinaryChunk & p_chunk, typename TObj::BinaryParser p_parser )
		{
			bool result = true;
			auto lock = make_unique_lock( p_manager );
			auto it = p_manager.begin();

			while ( result && it != p_manager.end() )
			{
				result = p_parser.Fill( *it->second, p_chunk );
				++it;
			}

			return result;
		}

		Path GetTextureNewPath( Path const & p_pathSrcFile, Path const & p_pathFolder )
		{
			Path pathReturn( cuT( "Texture" ) );
			pathReturn /= p_pathSrcFile.GetFullFileName();

			if ( !wxDirExists( ( p_pathFolder / cuT( "Texture" ) ).c_str() ) )
			{
				wxMkDir( string::string_cast< char >( p_pathFolder / cuT( "Texture" ) ).c_str(), 0777 );
			}

			if ( wxFileExists( p_pathSrcFile ) )
			{
				Logger::LogDebug( cuT( "Copying [" ) + p_pathSrcFile + cuT( "] to [" ) + p_pathFolder / pathReturn + cuT( "]" ) );
				wxCopyFile( p_pathSrcFile, p_pathFolder / pathReturn );
			}

			return pathReturn;
		}
	}

	//************************************************************************************************

	void ObjSceneExporter::ExportScene( Scene const & p_scene, Path const & p_fileName )
	{
		Path mtlFilePath( p_fileName );
		string::replace( mtlFilePath, mtlFilePath.GetExtension(), cuT( "mtl" ) );
		DoExportMaterials( p_scene, mtlFilePath );
		DoExportMeshes( p_scene, mtlFilePath, p_fileName );
	}

	void ObjSceneExporter::DoExportMaterials( Scene const & p_scene, Path const & p_path )const
	{
		auto const & cache = p_scene.GetMaterialView();
		StringStream streamVersion;
		streamVersion << Version{};
		StringStream mtl;
		mtl << cuT( "################################################################################\n" );
		mtl << cuT( "#" ) << std::setw( 78 ) << std::left << ( cuT( "  MTL File generated by Castor::GuiCommon v" ) + streamVersion.str() ) << cuT( "#\n" );
		mtl << cuT( "################################################################################\n\n" );

		for ( auto const & name : cache )
		{
			auto material = cache.Find( name );
			mtl << DoExportMaterial( p_path.GetPath(), *material ) + cuT( "\n" );
		}

		TextFile fileMtl( p_path, File::OpenMode::eWrite, File::EncodingMode::eASCII );
		fileMtl.WriteText( mtl.str() );
	}

	void ObjSceneExporter::DoExportMeshes( Castor3D::Scene const & p_scene, Castor::Path const & p_mtlpath, Castor::Path const & p_path )const
	{
		StringStream obj;
		StringStream streamVersion;
		streamVersion << Version{};

		Path pathFileObj( p_path );
		string::replace( pathFileObj, pathFileObj.GetExtension(), cuT( "obj" ) );
		obj << cuT( "################################################################################\n" );
		obj << cuT( "#" ) << std::setw( 78 ) << std::left << ( cuT( "  OBJ File generated by Castor::GuiCommon v" ) + streamVersion.str() ) << cuT( "#\n" );
		obj << cuT( "################################################################################\n\n" );
		obj << cuT( "mtllib " ) + p_mtlpath.GetFullFileName() + cuT( "\n\n" );

		uint32_t offset = 1;
		uint32_t count = 0;
		auto const & cache = p_scene.GetMeshCache();
		cache.lock();

		for ( auto const & it : cache )
		{
			auto mesh = it.second;
			obj << DoExportMesh( *mesh, offset, count ) << cuT( "\n" );
		}

		cache.unlock();
		TextFile fileObj( pathFileObj, File::OpenMode::eWrite, File::EncodingMode::eASCII );
		fileObj.WriteText( obj.str() );
	}

	String ObjSceneExporter::DoExportMaterial( Path const & p_pathMtlFolder, Material const & p_material )const
	{
		StringStream strReturn;

		if ( p_material.GetType() == MaterialType::eLegacy )
		{
			auto pass = p_material.GetTypedPass< MaterialType::eLegacy > ( 0u );

			if ( pass )
			{
				strReturn << cuT( "newmtl " ) << p_material.GetName() << cuT( "\n" );
				auto diffuse = pass->GetDiffuse();
				strReturn << cuT( "	Kd " ) << diffuse.red().value() << cuT( " " ) << diffuse.green().value() << cuT( " " ) << diffuse.blue().value() << cuT( "\n" );
				auto specular = pass->GetSpecular();
				strReturn << cuT( "	Ks " ) << specular.red().value() << cuT( " " ) << specular.green().value() << cuT( " " ) << specular.blue().value() << cuT( "\n" );
				strReturn << cuT( "	Ns " ) << pass->GetShininess() << cuT( "\n" );
				strReturn << cuT( "	d " ) << pass->GetOpacity() << cuT( "\n" );

				strReturn << DoExportTexture( p_pathMtlFolder, cuT( "map_Kd" ), pass->GetTextureUnit( TextureChannel::eDiffuse ) );
				strReturn << DoExportTexture( p_pathMtlFolder, cuT( "map_Bump" ), pass->GetTextureUnit( TextureChannel::eNormal ) );
				strReturn << DoExportTexture( p_pathMtlFolder, cuT( "map_d" ), pass->GetTextureUnit( TextureChannel::eOpacity ) );
				strReturn << DoExportTexture( p_pathMtlFolder, cuT( "map_Ks" ), pass->GetTextureUnit( TextureChannel::eSpecular ) );
				strReturn << DoExportTexture( p_pathMtlFolder, cuT( "map_Ns" ), pass->GetTextureUnit( TextureChannel::eGloss ) );
			}
		}

		return strReturn.str();
	}

	Castor::String ObjSceneExporter::DoExportTexture( Castor::Path const & p_pathMtlFolder, Castor::String p_section, TextureUnitSPtr p_unit )const
	{
		StringStream strReturn;

		if ( p_unit )
		{
			Path path{ p_unit->GetTexture()->GetImage().ToString() };

			if ( !path.empty() )
			{
				strReturn << cuT( "	" ) << p_section << cuT( " " ) + GetTextureNewPath( path, p_pathMtlFolder ) << cuT( "\n" );
			}
		}

		return strReturn.str();
	}

	String ObjSceneExporter::DoExportMesh( Mesh const & p_mesh, uint32_t & p_offset, uint32_t & p_count )const
	{
		StringStream strReturn;

		for ( auto const & submesh : p_mesh )
		{
			StringStream strV;
			StringStream strVT;
			StringStream strVN;
			StringStream strF;
			VertexBuffer & vtxBuffer = submesh->GetVertexBuffer();
			IndexBuffer & idxBuffer = submesh->GetIndexBuffer();
			uint32_t stride = vtxBuffer.GetDeclaration().stride();
			uint32_t uiNbPoints = vtxBuffer.GetSize() / stride;
			uint32_t uiNbFaces = idxBuffer.GetSize() / 3;
			uint8_t * pVtx = vtxBuffer.GetData();
			uint32_t * pIdx = idxBuffer.GetData();
			Point3r ptPos;
			Point3r ptNml;
			Point3r ptTex;

			for ( uint32_t j = 0; j < uiNbPoints; j++ )
			{
				real * vertex = reinterpret_cast< real * >( &pVtx[j * stride] );
				Vertex::GetPosition( vertex, ptPos );
				Vertex::GetNormal( vertex, ptNml );
				Vertex::GetTexCoord( vertex, ptTex );
				strV  << cuT( "v " ) << ptPos[0] << " " << ptPos[1] << " " << ptPos[2] << cuT( "\n" );
				strVN << cuT( "vn " ) << ptNml[0] << " " << ptNml[1] << " " << ptNml[2] << cuT( "\n" );
				strVT << cuT( "vt " ) << ptTex[0] << " " << ptTex[1] << cuT( "\n" );
			}

			strF << cuT( "usemtl " ) << submesh->GetDefaultMaterial()->GetName() << cuT( "\ns off\n" );

			for ( uint32_t j = 0; j < uiNbFaces; j++ )
			{
				uint32_t * pFace = &pIdx[j * 3];
				uint32_t v0 = p_offset + pFace[0];
				uint32_t v1 = p_offset + pFace[1];
				uint32_t v2 = p_offset + pFace[2];
				strF << cuT( "f " ) << v0 << cuT( "/" ) << v0 << cuT( "/" ) << v0 << cuT( " " ) << v1 << cuT( "/" ) << v1 << cuT( "/" ) << v1 << cuT( " " ) << v2 << cuT( "/" ) << v2 << cuT( "/" ) << v2 << cuT( "\n" );
			}

			strReturn << cuT( "g mesh" ) << p_count << cuT( "\n" ) << strV.str() << cuT( "\n" ) << strVN.str() << cuT( "\n" ) << strVT.str() << cuT( "\n" ) << strF.str() << cuT( "\n" );
			p_offset += uiNbPoints;
			p_count++;
		}

		return strReturn.str();
	}

	//************************************************************************************************

	void CscnSceneExporter::ExportScene( Scene const & p_scene, Path const & p_fileName )
	{
		bool result = true;
		Path folder = p_fileName.GetPath() / p_fileName.GetFileName();

		if ( !File::DirectoryExists( folder ) )
		{
			File::DirectoryCreate( folder );
		}

		Path filePath = folder / p_fileName.GetFileName();

		if ( result )
		{
			TextFile scnFile( Path{ filePath + cuT( ".cscn" ) }, File::OpenMode::eWrite, File::EncodingMode::eASCII );
			result = Scene::TextWriter( String() )( p_scene, scnFile );
		}

		Path subfolder{ cuT( "Meshes" ) };

		if ( result )
		{
			if ( !File::DirectoryExists( folder / subfolder ) )
			{
				File::DirectoryCreate( folder / subfolder );
			}

			auto lock = make_unique_lock( p_scene.GetMeshCache() );

			for ( auto const & it : p_scene.GetMeshCache() )
			{
				auto mesh = it.second;
				Path path{ folder / subfolder / it.first + cuT( ".cmsh" ) };
				BinaryFile file{ path, File::OpenMode::eWrite };
				result &= BinaryWriter< Mesh > {} .Write( *mesh, file );
			}
		}

		if ( result )
		{
			wxMessageBox( _( "Export successful" ) );
		}
		else
		{
			wxMessageBox( _( "Export failed" ) );
		}
	}
}
