/*
This source file is part of Castor3D (https://sourceforge.net/projects/castor3d/)

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU Lesser General Public License as published by the Free Software
Foundation; either version 2 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License along with
the program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place - Suite 330, Boston, MA 02111-1307, USA, or go to
http://www.gnu.org/copyleft/lesser.txt.
*/
#ifndef ___C3DGL_GlObjects___
#define ___C3DGL_GlObjects___

#include "GlRenderSystemPrerequisites.hpp"

#include <TextureUnit.hpp>

#if !defined( CALLBACK )
#	if defined( _WIN32 )
#		define CALLBACK __stdcall
#	else
#		define CALLBACK
#	endif
#endif

#if defined( __linux__ )
#	include <GL/glx.h>
#	define GLX_GLXEXT_PROTOTYPES
#	include <GL/glxext.h>
#endif

//*************************************************************************************************

namespace GlRender
{
	using Castor::real;

	typedef enum eGL_BUFFER
	{
		eGL_BUFFER_NONE				= 0x0000,
		eGL_BUFFER_FRONT_LEFT		= 0x0400,
		eGL_BUFFER_FRONT_RIGHT		= 0x0401,
		eGL_BUFFER_BACK_LEFT		= 0x0402,
		eGL_BUFFER_BACK_RIGHT		= 0x0403,
		eGL_BUFFER_FRONT			= 0x0404,
		eGL_BUFFER_BACK				= 0x0405,
		eGL_BUFFER_LEFT				= 0x0406,
		eGL_BUFFER_RIGHT			= 0x0407,
		eGL_BUFFER_FRONT_AND_BACK	= 0x0408,
		eGL_BUFFER_COLOR0			= 0x8CE0,
		eGL_BUFFER_COLOR1			= 0x8CE1,
		eGL_BUFFER_COLOR2			= 0x8CE2,
		eGL_BUFFER_COLOR3			= 0x8CE3,
		eGL_BUFFER_COLOR4			= 0x8CE4,
		eGL_BUFFER_COLOR5			= 0x8CE5,
		eGL_BUFFER_COLOR6			= 0x8CE6,
		eGL_BUFFER_COLOR7			= 0x8CE7,
		eGL_BUFFER_COLOR8			= 0x8CE8,
		eGL_BUFFER_COLOR9			= 0x8CE9,
		eGL_BUFFER_COLOR10			= 0x8CEA,
		eGL_BUFFER_COLOR11			= 0x8CEB,
		eGL_BUFFER_COLOR12			= 0x8CEC,
		eGL_BUFFER_COLOR13			= 0x8CED,
		eGL_BUFFER_COLOR14			= 0x8CEE,
		eGL_BUFFER_COLOR15			= 0x8CEF,
	}	eGL_BUFFER;

	typedef enum eGL_PATCH_PARAMETER
	{
		eGL_PATCH_PARAMETER_VERTICES			= 0x8E72,
		eGL_PATCH_PARAMETER_DEFAULT_INNER_LEVEL	= 0x8E73,
		eGL_PATCH_PARAMETER_DEFAULT_OUTER_LEVEL	= 0x8E74,
	}	eGL_PATCH_PARAMETER;

	typedef enum eGL_PRIMITIVE CASTOR_TYPE( uint32_t )
	{
		eGL_PRIMITIVE_POINTS			= 0x0000,
		eGL_PRIMITIVE_LINES				= 0x0001,
		eGL_PRIMITIVE_LINE_LOOP			= 0x0002,
		eGL_PRIMITIVE_LINE_STRIP		= 0x0003,
		eGL_PRIMITIVE_TRIANGLES			= 0x0004,
		eGL_PRIMITIVE_TRIANGLE_STRIP	= 0x0005,
		eGL_PRIMITIVE_TRIANGLE_FAN		= 0x0006,
		eGL_PRIMITIVE_QUADS				= 0x0007,
		eGL_PRIMITIVE_QUAD_STRIP		= 0x0008,
		eGL_PRIMITIVE_POLYGON			= 0x0009,
		eGL_PRIMITIVE_PATCHES			= 0x000E,
	}	eGL_PRIMITIVE;

	typedef enum eGL_INTERNAL_FORMAT				//	Type	Comps	Norm	0	1	2	3
	{
		eGL_INTERNAL_FORMAT_RGBA8		= 0x8058,	//	uint		4	YES		R	G	B	A
		eGL_INTERNAL_FORMAT_RGBA16		= 0x805B,	//	short		4	YES		R	G	B	A
		eGL_INTERNAL_FORMAT_R8			= 0x8229,	//	ubyte		1	YES		R	0	0	1
		eGL_INTERNAL_FORMAT_R16			= 0x822A,	//	ushort		1	YES		R	0	0	1
		eGL_INTERNAL_FORMAT_RG8			= 0x822B,	//	ubyte		2	YES		R	G	0	1
		eGL_INTERNAL_FORMAT_RG16		= 0x822C,	//	ushort		2	YES		R	G	0	1
		eGL_INTERNAL_FORMAT_R16F		= 0x822D,	//	half		1	NO		R	0	0	1
		eGL_INTERNAL_FORMAT_R32F		= 0x822E,	//	float		1	NO		R	0	0	1
		eGL_INTERNAL_FORMAT_RG16F		= 0x822F,	//	half		2	NO		R	G	0	1
		eGL_INTERNAL_FORMAT_RG32F		= 0x8230,	//	float		2	NO		R	G	0	1
		eGL_INTERNAL_FORMAT_R8I			= 0x8231,	//	byte		1	NO		R	0	0	1
		eGL_INTERNAL_FORMAT_R8UI		= 0x8232,	//	ubyte		1	NO		R	0	0	1
		eGL_INTERNAL_FORMAT_R16I		= 0x8233,	//	short		1	NO		R	0	0	1
		eGL_INTERNAL_FORMAT_R16UI		= 0x8234,	//	ushort		1	NO		R	0	0	1
		eGL_INTERNAL_FORMAT_R32I		= 0x8235,	//	int			1	NO		R	0	0	1
		eGL_INTERNAL_FORMAT_R32UI		= 0x8236,	//	uint		1	NO		R	0	0	1
		eGL_INTERNAL_FORMAT_RG8I		= 0x8237,	//	byte		2	NO		R	G	0	1
		eGL_INTERNAL_FORMAT_RG8UI		= 0x8238,	//	ubyte		2	NO		R	G	0	1
		eGL_INTERNAL_FORMAT_RG16I		= 0x8239,	//	short		2	NO		R	G	0	1
		eGL_INTERNAL_FORMAT_RG16UI		= 0x823A,	//	ushort		2	NO		R	G	0	1
		eGL_INTERNAL_FORMAT_RG32I		= 0x823B,	//	int			2	NO		R	G	0	1
		eGL_INTERNAL_FORMAT_RG32UI		= 0x823C,	//	uint		2	NO		R	G	0	1
		eGL_INTERNAL_FORMAT_RGBA32F		= 0x8814,	//	float		4	NO		R	G	B	A
		eGL_INTERNAL_FORMAT_RGBA16F		= 0x881A,	//	half		4	NO		R	G	B	A
		eGL_INTERNAL_FORMAT_RGBA32UI	= 0x8D70,	//	uint		4	NO		R	G	B	A
		eGL_INTERNAL_FORMAT_RGBA16UI	= 0x8D76,	//	ushort		4	NO		R	G	B	A
		eGL_INTERNAL_FORMAT_RGB16UI		= 0x8D77,	//	ushort		3	NO		R	G	B	1
		eGL_INTERNAL_FORMAT_RGBA8UI		= 0x8D7C,	//	ubyte		4	NO		R	G	B	A
		eGL_INTERNAL_FORMAT_RGBA32I		= 0x8D82,	//	int			4	NO		R	G	B	A
		eGL_INTERNAL_FORMAT_RGBA16I		= 0x8D88,	//	short		4	NO		R	G	B	A
		eGL_INTERNAL_FORMAT_RGBA8I		= 0x8D8E,	//	byte		4	NO		R	G	B	A
	}	eGL_INTERNAL_FORMAT;

	typedef enum eGL_TEXDIM
	{
		eGL_TEXDIM_BUFFER = 0x8C2A,
		eGL_TEXDIM_1D = 0x0DE0,
		eGL_TEXDIM_1D_ARRAY = 0x8C18,
		eGL_TEXDIM_2D = 0x0DE1,
		eGL_TEXDIM_2D_ARRAY = 0x8C1A,
		eGL_TEXDIM_2DMS = 0x9100,
		eGL_TEXDIM_2DMS_ARRAY = 0x9102,
		eGL_TEXDIM_3D = 0x806F,
		eGL_TEXDIM_CUBE = 0x8513,
		eGL_TEXDIM_CUBE_ARRAY = 0x9009,
	}	eGL_TEXDIM;

	typedef enum eGL_FUNC
	{
		eGL_FUNC_NEVER		= 0x0200,
		eGL_FUNC_LESS		= 0x0201,
		eGL_FUNC_EQUAL		= 0x0202,
		eGL_FUNC_LEQUAL		= 0x0203,
		eGL_FUNC_GREATER	= 0x0204,
		eGL_FUNC_NOTEQUAL	= 0x0205,
		eGL_FUNC_GEQUAL		= 0x0206,
		eGL_FUNC_ALWAYS		= 0x0207,
	}	eGL_FUNC;

	typedef enum eGL_WRAP_MODE
	{
		eGL_WRAP_MODE_CLAMP				= 0x2900,
		eGL_WRAP_MODE_REPEAT			= 0x2901,
		eGL_WRAP_MODE_CLAMP_TO_BORDER	= 0x812D,
		eGL_WRAP_MODE_CLAMP_TO_EDGE		= 0x812F,
		eGL_WRAP_MODE_MIRRORED_REPEAT	= 0x8370,
	}	eGL_WRAP_MODE;

	typedef enum eGL_INTERPOLATION_MODE
	{
		eGL_INTERPOLATION_MODE_NEAREST					= 0x2600,
		eGL_INTERPOLATION_MODE_LINEAR					= 0x2601,
		eGL_INTERPOLATION_MODE_NEAREST_MIPMAP_NEAREST	= 0x2700,
		eGL_INTERPOLATION_MODE_LINEAR_MIPMAP_NEAREST	= 0x2701,
		eGL_INTERPOLATION_MODE_NEAREST_MIPMAP_LINEAR	= 0x2702,
		eGL_INTERPOLATION_MODE_LINEAR_MIPMAP_LINEAR		= 0x2703,
	}	eGL_INTERPOLATION_MODE;

	typedef enum eGL_LIGHT_INDEX
	{
		eGL_LIGHT_INDEX_INVALID	= 0xFFFFFFFF,
		eGL_LIGHT_INDEX_0		= 0x4000,
		eGL_LIGHT_INDEX_1		= 0x4001,
		eGL_LIGHT_INDEX_2		= 0x4002,
		eGL_LIGHT_INDEX_3		= 0x4003,
		eGL_LIGHT_INDEX_4		= 0x4004,
		eGL_LIGHT_INDEX_5		= 0x4005,
		eGL_LIGHT_INDEX_6		= 0x4006,
		eGL_LIGHT_INDEX_7		= 0x4007,
	}	eGL_LIGHT_INDEX;

	typedef enum eGL_BLEND_FACTOR
	{
		eGL_BLEND_FACTOR_ZERO					= 0x0000,
		eGL_BLEND_FACTOR_ONE					= 0x0001,
		eGL_BLEND_FACTOR_SRC_COLOR				= 0x0300,
		eGL_BLEND_FACTOR_ONE_MINUS_SRC_COLOR	= 0x0301,
		eGL_BLEND_FACTOR_SRC_ALPHA				= 0x0302,
		eGL_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA	= 0x0303,
		eGL_BLEND_FACTOR_DST_ALPHA				= 0x0304,
		eGL_BLEND_FACTOR_ONE_MINUS_DST_ALPHA	= 0x0305,
		eGL_BLEND_FACTOR_DST_COLOR				= 0x0306,
		eGL_BLEND_FACTOR_ONE_MINUS_DST_COLOR	= 0x0307,
		eGL_BLEND_FACTOR_SRC_ALPHA_SATURATE		= 0x0308,
		eGL_BLEND_FACTOR_CONSTANT				= 0x8001,
		eGL_BLEND_FACTOR_ONE_MINUS_CONSTANT		= 0x8002,
		eGL_BLEND_FACTOR_SRC1_ALPHA				= 0x8589,
		eGL_BLEND_FACTOR_SRC1_COLOR				= 0x88F9,
		eGL_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR	= 0x88FA,
		eGL_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA	= 0x88FB,
	}	eGL_BLEND_FACTOR;

	typedef enum eGL_BUFFER_USAGE
	{
		eGL_BUFFER_USAGE_VERTEX_ARRAY					= 0x8074,
		eGL_BUFFER_USAGE_NORMAL_ARRAY					= 0x8075,
		eGL_BUFFER_USAGE_COLOR_ARRAY					= 0x8076,
		eGL_BUFFER_USAGE_INDEX_ARRAY					= 0x8077,
		eGL_BUFFER_USAGE_TEXTURE_COORD_ARRAY			= 0x8078,
		eGL_BUFFER_USAGE_TANGENT_ARRAY					= 0x8439,
		eGL_BUFFER_USAGE_BINORMAL_ARRAY					= 0x843A,
		eGL_BUFFER_USAGE_VERTEX_ATTRIB_ARRAY_UNIFIED	= 0x8F1E,
		eGL_BUFFER_USAGE_ELEMENT_ARRAY_UNIFIED			= 0x8F1F,
	}	eGL_BUFFER_USAGE;

	typedef enum eGL_TEXTURE_INDEX
	{
		eGL_TEXTURE_INDEX_0		= 0x84C0,
		eGL_TEXTURE_INDEX_1		= 0x84C1,
		eGL_TEXTURE_INDEX_2		= 0x84C2,
		eGL_TEXTURE_INDEX_3		= 0x84C3,
		eGL_TEXTURE_INDEX_4		= 0x84C4,
		eGL_TEXTURE_INDEX_5		= 0x84C5,
		eGL_TEXTURE_INDEX_6		= 0x84C6,
		eGL_TEXTURE_INDEX_7		= 0x84C7,
		eGL_TEXTURE_INDEX_8		= 0x84C8,
		eGL_TEXTURE_INDEX_9		= 0x84C9,
		eGL_TEXTURE_INDEX_10	= 0x84CA,
		eGL_TEXTURE_INDEX_11	= 0x84CB,
		eGL_TEXTURE_INDEX_12	= 0x84CC,
		eGL_TEXTURE_INDEX_13	= 0x84CD,
		eGL_TEXTURE_INDEX_14	= 0x84CE,
		eGL_TEXTURE_INDEX_15	= 0x84CF,
		eGL_TEXTURE_INDEX_16	= 0x84D0,
		eGL_TEXTURE_INDEX_17	= 0x84D1,
		eGL_TEXTURE_INDEX_18	= 0x84D2,
		eGL_TEXTURE_INDEX_19	= 0x84D3,
		eGL_TEXTURE_INDEX_20	= 0x84D4,
		eGL_TEXTURE_INDEX_21	= 0x84D5,
		eGL_TEXTURE_INDEX_22	= 0x84D6,
		eGL_TEXTURE_INDEX_23	= 0x84D7,
		eGL_TEXTURE_INDEX_24	= 0x84D8,
		eGL_TEXTURE_INDEX_25	= 0x84D9,
		eGL_TEXTURE_INDEX_26	= 0x84DA,
		eGL_TEXTURE_INDEX_27	= 0x84DB,
		eGL_TEXTURE_INDEX_28	= 0x84DC,
		eGL_TEXTURE_INDEX_29	= 0x84DD,
		eGL_TEXTURE_INDEX_30	= 0x84DE,
		eGL_TEXTURE_INDEX_31	= 0x84DF,
	}	eGL_TEXTURE_INDEX;

	typedef enum eGL_BLEND_SOURCE
	{
		eGL_BLEND_SOURCE_TEXTURE		= 0x1702,
		eGL_BLEND_SOURCE_TEXTURE0		= 0x84C0,
		eGL_BLEND_SOURCE_TEXTURE1		= 0x84C1,
		eGL_BLEND_SOURCE_TEXTURE2		= 0x84C2,
		eGL_BLEND_SOURCE_TEXTURE3		= 0x84C3,
		eGL_BLEND_SOURCE_CONSTANT		= 0x8576,
		eGL_BLEND_SOURCE_PRIMARY_COLOR	= 0x8577,
		eGL_BLEND_SOURCE_PREVIOUS		= 0x8578,
	}	eGL_BLEND_SOURCE;

	typedef enum eGL_BLEND_FUNC
	{
		eGL_BLEND_FUNC_ADD			= 0x0104,
		eGL_BLEND_FUNC_REPLACE		= 0x1E01,
		eGL_BLEND_FUNC_MODULATE		= 0x2100,
		eGL_BLEND_FUNC_SUBTRACT		= 0x84E7,
		eGL_BLEND_FUNC_ADD_SIGNED	= 0x8574,
		eGL_BLEND_FUNC_INTERPOLATE	= 0x8575,
		eGL_BLEND_FUNC_DOT3_RGB		= 0x86AE,
		eGL_BLEND_FUNC_DOT3_RGBA	= 0x86AF,
	}	eGL_BLEND_FUNC;

	typedef enum eGL_BLEND_OP
	{
		eGL_BLEND_OP_ADD			= 0x8006,
		eGL_BLEND_OP_MIN			= 0x8007,
		eGL_BLEND_OP_MAX			= 0x8008,
		eGL_BLEND_OP_SUBTRACT		= 0x800A,
		eGL_BLEND_OP_REV_SUBTRACT	= 0x800B,
	}	eGL_BLEND_OP;

	typedef enum eGL_INTERNAL
	{
		eGL_INTERNAL_1							= 0x0001,
		eGL_INTERNAL_2							= 0x0002,
		eGL_INTERNAL_3							= 0x0003,
		eGL_INTERNAL_4							= 0x0004,
		eGL_INTERNAL_LUMINANCE					= 0x1909,
		eGL_INTERNAL_R3_G3_B2					= 0x2A10,
		eGL_INTERNAL_ALPHA4						= 0x803B,
		eGL_INTERNAL_ALPHA8						= 0x803C,
		eGL_INTERNAL_ALPHA12					= 0x803D,
		eGL_INTERNAL_ALPHA16					= 0x803E,
		eGL_INTERNAL_COMPRESSED_ALPHA			= 0x84E9,
		eGL_INTERNAL_COMPRESSED_LUMINANCE		= 0x84EA,
		eGL_INTERNAL_COMPRESSED_LUMINANCE_ALPHA	= 0x84EB,
		eGL_INTERNAL_COMPRESSED_INTENSITY		= 0x84EC,
		eGL_INTERNAL_COMPRESSED_RGB				= 0x84ED,
		eGL_INTERNAL_COMPRESSED_RGBA			= 0x84EE,
		eGL_INTERNAL_LUMINANCE4					= 0x803F,
		eGL_INTERNAL_LUMINANCE8					= 0x8040,
		eGL_INTERNAL_LUMINANCE12				= 0x8041,
		eGL_INTERNAL_LUMINANCE16				= 0x8042,
		eGL_INTERNAL_LUMINANCE4_ALPHA4			= 0x8043,
		eGL_INTERNAL_LUMINANCE6_ALPHA2			= 0x8044,
		eGL_INTERNAL_LUMINANCE8_ALPHA8			= 0x8045,
		eGL_INTERNAL_LUMINANCE12_ALPHA4			= 0x8046,
		eGL_INTERNAL_LUMINANCE12_ALPHA12		= 0x8047,
		eGL_INTERNAL_LUMINANCE16_ALPHA16		= 0x8048,
		eGL_INTERNAL_INTENSITY					= 0x8049,
		eGL_INTERNAL_INTENSITY4					= 0x804A,
		eGL_INTERNAL_INTENSITY8					= 0x804B,
		eGL_INTERNAL_INTENSITY12				= 0x804C,
		eGL_INTERNAL_INTENSITY16				= 0x804D,
		eGL_INTERNAL_RGB4						= 0x804F,
		eGL_INTERNAL_RGB5						= 0x8050,
		eGL_INTERNAL_RGB8						= 0x8051,
		eGL_INTERNAL_RGB10						= 0x8052,
		eGL_INTERNAL_RGB12						= 0x8053,
		eGL_INTERNAL_RGB16						= 0x8054,
		eGL_INTERNAL_RGBA2						= 0x8055,
		eGL_INTERNAL_RGBA4						= 0x8056,
		eGL_INTERNAL_RGB5_A1					= 0x8057,
		eGL_INTERNAL_RGBA8						= 0x8058,
		eGL_INTERNAL_RGB10_A2					= 0x8059,
		eGL_INTERNAL_RGBA12						= 0x805A,
		eGL_INTERNAL_RGBA16						= 0x805B,
		eGL_INTERNAL_DEPTH_COMPONENT16			= 0x81A5,
		eGL_INTERNAL_DEPTH_COMPONENT24			= 0x81A6,
		eGL_INTERNAL_DEPTH_COMPONENT32			= 0x81A7,
		eGL_INTERNAL_R8							= 0x8229,
		eGL_INTERNAL_RG8						= 0x822B,
		eGL_INTERNAL_RG16						= 0x822C,
		eGL_INTERNAL_R16F						= 0x822D,
		eGL_INTERNAL_R32F						= 0x822E,
		eGL_INTERNAL_RG16F						= 0x822F,
		eGL_INTERNAL_RG32F						= 0x8230,
		eGL_INTERNAL_COMPRESSED_RGBA_S3TC_DXT1	= 0x83F1,
		eGL_INTERNAL_COMPRESSED_RGBA_S3TC_DXT3	= 0x83F2,
		eGL_INTERNAL_COMPRESSED_RGBA_S3TC_DXT5	= 0x83F3,
		eGL_INTERNAL_RGBA32F					= 0x8814,
		eGL_INTERNAL_RGB32F						= 0x8815,
		eGL_INTERNAL_RGBA16F					= 0x881A,
		eGL_INTERNAL_RGB16F						= 0x881B,
		eGL_INTERNAL_DEPTH24_STENCIL8			= 0x88F0,
		eGL_INTERNAL_SRGB						= 0x8C40,
		eGL_INTERNAL_SRGB8						= 0x8C41,
		eGL_INTERNAL_SRGB_ALPHA					= 0x8C42,
		eGL_INTERNAL_SRGB8_ALPHA8				= 0x8C43,
		eGL_INTERNAL_SLUMINANCE_ALPHA			= 0x8C44,
		eGL_INTERNAL_SLUMINANCE8_ALPHA8			= 0x8C45,
		eGL_INTERNAL_SLUMINANCE					= 0x8C46,
		eGL_INTERNAL_SLUMINANCE8				= 0x8C47,
		eGL_INTERNAL_DEPTH_COMPONENT32F			= 0x8CAC,
		eGL_INTERNAL_STENCIL_INDEX1				= 0x8D46,
		eGL_INTERNAL_STENCIL_INDEX4				= 0x8D47,
		eGL_INTERNAL_STENCIL_INDEX8				= 0x8D48,
		eGL_INTERNAL_STENCIL_INDEX16			= 0x8D49,
	}	eGL_INTERNAL;

	typedef enum eGL_BUFFER_MODE
	{
		eGL_BUFFER_MODE_STREAM_DRAW		= 0x88E0,
		eGL_BUFFER_MODE_STREAM_READ		= 0x88E1,
		eGL_BUFFER_MODE_STREAM_COPY		= 0x88E2,
		eGL_BUFFER_MODE_STATIC_DRAW		= 0x88E4,
		eGL_BUFFER_MODE_STATIC_READ		= 0x88E5,
		eGL_BUFFER_MODE_STATIC_COPY		= 0x88E6,
		eGL_BUFFER_MODE_DYNAMIC_DRAW	= 0x88E8,
		eGL_BUFFER_MODE_DYNAMIC_READ	= 0x88E9,
		eGL_BUFFER_MODE_DYNAMIC_COPY	= 0x88EA,
	}	eGL_BUFFER_MODE;

	typedef enum eGL_COMPONENT
	{
//		eGL_COMPONENT_COLOR		= 0x4000,
//		eGL_COMPONENT_STENCIL	= 0x0100,
//		eGL_COMPONENT_DEPTH		= 0x0400,
		eGL_COMPONENT_COLOR		= 0x1900,
		eGL_COMPONENT_STENCIL	= 0x1901,
		eGL_COMPONENT_DEPTH		= 0x1902,
	}	eGL_COMPONENT;

	typedef enum eGL_BUFFER_TARGET
	{
		eGL_BUFFER_TARGET_ARRAY			= 0x8892,
		eGL_BUFFER_TARGET_ELEMENT_ARRAY	= 0x8893,
		eGL_BUFFER_TARGET_PIXEL_PACK	= 0x88EB,
		eGL_BUFFER_TARGET_PIXEL_UNPACK	= 0x88EC,
		eGL_BUFFER_TARGET_TEXTURE		= 0x8C2A,
		eGL_BUFFER_TARGET_UNIFORM		= 0x8A11,//0x8DEE
	}	eGL_BUFFER_TARGET;

	typedef enum eGL_SHADER_TYPE
	{
		eGL_SHADER_TYPE_FRAGMENT		= 0x8B30,
		eGL_SHADER_TYPE_VERTEX			= 0x8B31,
		eGL_SHADER_TYPE_GEOMETRY		= 0x8DD9,
		eGL_SHADER_TYPE_TESS_EVALUATION	= 0x8E87,
		eGL_SHADER_TYPE_TESS_CONTROL	= 0x8E88,
		eGL_SHADER_TYPE_COMPUTE			= 0x91B9,
	}	eGL_SHADER_TYPE;

	typedef enum eGL_LOCK
	{
		eGL_LOCK_READ_ONLY	= 0x88B8,
		eGL_LOCK_WRITE_ONLY	= 0x88B9,
		eGL_LOCK_READ_WRITE	= 0x88BA,
	}	eGL_LOCK;

	typedef enum eGL_LIGHT_COMPONENT
	{
		eGL_LIGHT_COMPONENT_AMBIENT					= 0x1200,
		eGL_LIGHT_COMPONENT_DIFFUSE					= 0x1201,
		eGL_LIGHT_COMPONENT_SPECULAR				= 0x1202,
		eGL_LIGHT_COMPONENT_POSITION				= 0x1203,
		eGL_LIGHT_COMPONENT_SPOT_DIRECTION			= 0x1204,
		eGL_LIGHT_COMPONENT_SPOT_EXPONENT			= 0x1205,
		eGL_LIGHT_COMPONENT_SPOT_CUTOFF				= 0x1206,
		eGL_LIGHT_COMPONENT_CONSTANT_ATTENUATION	= 0x1207,
		eGL_LIGHT_COMPONENT_LINEAR_ATTENUATION		= 0x1208,
		eGL_LIGHT_COMPONENT_QUADRATIC_ATTENUATION	= 0x1209,
	}	eGL_LIGHT_COMPONENT;

	typedef enum eGL_MATERIAL_COMPONENT
	{
		eGL_MATERIAL_COMPONENT_AMBIENT		= 0x1200,
		eGL_MATERIAL_COMPONENT_DIFFUSE		= 0x1201,
		eGL_MATERIAL_COMPONENT_SPECULAR		= 0x1202,
		eGL_MATERIAL_COMPONENT_POSITION		= 0x1203,
		eGL_MATERIAL_COMPONENT_EMISSION		= 0x1600,
		eGL_MATERIAL_COMPONENT_SHININESS	= 0x1601,
	}	eGL_MATERIAL_COMPONENT;

	typedef enum eGL_UNIFORM_NAME
	{
		eGL_UNIFORM_SIZE			= 0x8A38,
		eGL_UNIFORM_OFFSET			= 0x8A3B,
		eGL_UNIFORM_BLOCK_DATA_SIZE	= 0x8A40,
		eGL_UNIFORM_GPU_ADDRESS		= 0x8F34,
	}	eGL_UNIFORM_NAME;

	typedef enum eGL_CREATECONTEXT_ATTRIB
	{
		eGL_CREATECONTEXT_ATTRIB_DEBUG_BIT				= 0x0001,
		eGL_CREATECONTEXT_ATTRIB_FORWARD_COMPATIBLE_BIT	= 0x0002,
		eGL_CREATECONTEXT_ATTRIB_MAJOR_VERSION			= 0x2091,
		eGL_CREATECONTEXT_ATTRIB_MINOR_VERSION			= 0x2092,
		eGL_CREATECONTEXT_ATTRIB_LAYER_PLANE			= 0x2093,
		eGL_CREATECONTEXT_ATTRIB_FLAGS					= 0x2094,
	}	eGL_CREATECONTEXT_ATTRIB;

	typedef enum eGL_PROFILE_ATTRIB
	{
		eGL_PROFILE_ATTRIB_CORE_BIT				= 0x0001,
		eGL_PROFILE_ATTRIB_COMPATIBILITY_BIT	= 0x0002,
		eGL_PROFILE_ATTRIB_MASK					= 0x9126,
	}	eGL_PROFILE_ATTRIB;

	typedef enum eGL_SHADER_STATUS
	{
		eGL_SHADER_STATUS_DELETE			= 0x8B80,
		eGL_SHADER_STATUS_COMPILE			= 0x8B81,
		eGL_SHADER_STATUS_LINK				= 0x8B82,
		eGL_SHADER_STATUS_VALIDATE			= 0x8B83,
		eGL_SHADER_STATUS_INFO_LOG_LENGTH	= 0x8B84,
	}	eGL_SHADER_STATUS;

	typedef enum eGL_TYPE
	{
		eGL_TYPE_DEFAULT						= 0x0000,
		eGL_TYPE_BYTE							= 0x1400,
		eGL_TYPE_UNSIGNED_BYTE					= 0x1401,
		eGL_TYPE_SHORT							= 0x1402,
		eGL_TYPE_UNSIGNED_SHORT					= 0x1403,
		eGL_TYPE_INT							= 0x1404,
		eGL_TYPE_UNSIGNED_INT					= 0x1405,
		eGL_TYPE_FLOAT							= 0x1406,
		eGL_TYPE_DOUBLE							= 0x140A,
		eGL_TYPE_BITMAP							= 0X1A00,
		eGL_TYPE_UNSIGNED_BYTE_3_3_2			= 0x8032,
		eGL_TYPE_UNSIGNED_SHORT_4_4_4_4			= 0x8033,
		eGL_TYPE_UNSIGNED_SHORT_5_5_5_1			= 0x8034,
		eGL_TYPE_UNSIGNED_INT_8_8_8_8			= 0x8035,
		eGL_TYPE_UNSIGNED_INT_10_10_10_2		= 0x8036,
		eGL_TYPE_UNSIGNED_BYTE_2_3_3_REV		= 0x8362,
		eGL_TYPE_UNSIGNED_SHORT_5_6_5			= 0x8363,
		eGL_TYPE_UNSIGNED_SHORT_5_6_5_REV		= 0x8364,
		eGL_TYPE_UNSIGNED_SHORT_4_4_4_4_REV		= 0x8365,
		eGL_TYPE_UNSIGNED_SHORT_1_5_5_5_REV		= 0x8366,
		eGL_TYPE_UNSIGNED_INT_8_8_8_8_REV		= 0x8367,
		eGL_TYPE_UNSIGNED_INT_2_10_10_10_REV	= 0x8368,
		eGL_TYPE_UNSIGNED_INT_24_8				= 0x84FA,
#if CASTOR_USE_DOUBLE
		eGL_TYPE_REAL							= eGL_TYPE_DOUBLE
#else
		eGL_TYPE_REAL							= eGL_TYPE_FLOAT
#endif
	}	eGL_TYPE;

	typedef enum eGL_FORMAT
	{
		eGL_FORMAT_STENCIL			= 0x1901,
		eGL_FORMAT_DEPTH			= 0x1902,
		eGL_FORMAT_RED				= 0x1903,
		eGL_FORMAT_GREEN			= 0x1904,
		eGL_FORMAT_BLUE				= 0x1905,
		eGL_FORMAT_ALPHA			= 0x1906,
		eGL_FORMAT_RGB				= 0x1907,
		eGL_FORMAT_RGBA				= 0x1908,
		eGL_FORMAT_LUMINANCE		= 0x1909,
		eGL_FORMAT_LUMINANCE_ALPHA	= 0x190A,
		eGL_FORMAT_BGR				= 0x80E0,
		eGL_FORMAT_BGRA				= 0x80E1,
		eGL_FORMAT_RG				= 0x8227,
		eGL_FORMAT_DEPTH_STENCIL	= 0x84F9,
	}	eGL_FORMAT;

	typedef enum eGL_TEXTURE_PARAMETER
	{
		eGL_TEXTURE_PARAMETER_BORDERCOLOUR		= 0x1004,
		eGL_TEXTURE_PARAMETER_MAG_FILTER		= 0x2800,
		eGL_TEXTURE_PARAMETER_MIN_FILTER		= 0x2801,
		eGL_TEXTURE_PARAMETER_WRAP_S			= 0x2802,
		eGL_TEXTURE_PARAMETER_WRAP_T			= 0x2803,
		eGL_TEXTURE_PARAMETER_WRAP_R			= 0x8072,
		eGL_TEXTURE_PARAMETER_MINLOD			= 0x813A,
		eGL_TEXTURE_PARAMETER_MAXLOD			= 0x813B,
		eGL_TEXTURE_PARAMETER_GENERATE_MIPMAP	= 0x8191,
		eGL_TEXTURE_PARAMETER_MAX_ANISOTROPY	= 0x84FF,
		eGL_TEXTURE_PARAMETER_LODBIAS			= 0x8501,
	}	eGL_TEXTURE_PARAMETER;

	typedef enum eGL_TEXENV_TARGET
	{
		eGL_TEXENV_TARGET_TEXTURE_ENV		= 0x2300,
		eGL_TEXENV_TARGET_POINT_SPRITE		= 0x8861,
	}	eGL_TEXENV_TARGET;

	typedef enum eGL_TEXENV_ARGNAME
	{
		eGL_TEXENV_ARGNAME_ALPHA_SCALE			= 0x0D1C,
		eGL_TEXENV_ARGNAME_TEXTURE_ENV_MODE		= 0x2200,
		eGL_TEXENV_ARGNAME_TEXTURE_ENV_COLOR	= 0x2201,
		eGL_TEXENV_ARGNAME_COMBINE_RGB			= 0x8571,
		eGL_TEXENV_ARGNAME_COMBINE_ALPHA		= 0x8572,
		eGL_TEXENV_ARGNAME_RGB_SCALE			= 0x8573,
		eGL_TEXENV_ARGNAME_SOURCE0_RGB			= 0x8580,
		eGL_TEXENV_ARGNAME_SOURCE1_RGB			= 0x8581,
		eGL_TEXENV_ARGNAME_SOURCE2_RGB			= 0x8582,
		eGL_TEXENV_ARGNAME_SOURCE0_ALPHA		= 0x8588,
		eGL_TEXENV_ARGNAME_SOURCE1_ALPHA		= 0x8589,
		eGL_TEXENV_ARGNAME_SOURCE2_ALPHA		= 0x858A,
		eGL_TEXENV_ARGNAME_OPERAND0_RGB			= 0x8590,
		eGL_TEXENV_ARGNAME_OPERAND1_RGB			= 0x8591,
		eGL_TEXENV_ARGNAME_OPERAND2_RGB			= 0x8592,
		eGL_TEXENV_ARGNAME_OPERAND0_ALPHA		= 0x8598,
		eGL_TEXENV_ARGNAME_OPERAND1_ALPHA		= 0x8599,
		eGL_TEXENV_ARGNAME_OPERAND2_ALPHA		= 0x859A,
		eGL_TEXENV_ARGNAME_COORD_REPLACE		= 0x8862,
	}	eGL_TEXENV_ARGNAME;

	typedef enum eGL_TEXENV_PARAM
	{
		eGL_TEXENV_PARAM_ADD					= 0x0104,
		eGL_TEXENV_PARAM_BLEND					= 0x0BE2,
		eGL_TEXENV_PARAM_TEXTURE				= 0x1702,
		eGL_TEXENV_PARAM_REPLACE				= 0x1E01,
		eGL_TEXENV_PARAM_MODULATE				= 0x2100,
		eGL_TEXENV_PARAM_DECAL					= 0x2101,
		eGL_TEXENV_PARAM_SRC_COLOR				= 0x0300,
		eGL_TEXENV_PARAM_ONE_MINUS_SRC_COLOR	= 0x0301,
		eGL_TEXENV_PARAM_SRC_ALPHA				= 0x0302,
		eGL_TEXENV_PARAM_ONE_MINUS_SRC_ALPHA	= 0x0303,
		eGL_TEXENV_PARAM_SUBTRACT				= 0x84E7,
		eGL_TEXENV_PARAM_COMBINE				= 0x8570,
		eGL_TEXENV_PARAM_ADD_SIGNED				= 0x8574,
		eGL_TEXENV_PARAM_INTERPOLATE			= 0x8575,
		eGL_TEXENV_PARAM_CONSTANT				= 0x8576,
		eGL_TEXENV_PARAM_PRIMARY_COLOR			= 0x8577,
		eGL_TEXENV_PARAM_PREVIOUS				= 0x8578,
		eGL_TEXENV_PARAM_DOT3_RGB				= 0x86AE,
		eGL_TEXENV_PARAM_DOT3_RGBA				= 0x86AF,
	}	eGL_TEXENV_PARAM;

	typedef enum eGL_TEXGEN_COORD
	{
		eGL_TEXGEN_COORD_S	= 0x2000,
		eGL_TEXGEN_COORD_T	= 0x2001,
		eGL_TEXGEN_COORD_R	= 0x2002,
		eGL_TEXGEN_COORD_Q	= 0x2003,
	}	eGL_TEXGEN_COORD;

	typedef enum eGL_TEXGEN_PARAM
	{
		eGL_TEXGEN_PARAM_TEXTURE_GEN_MODE	= 0x2500,
		eGL_TEXGEN_PARAM_OBJECT_PLANE		= 0x2501,
		eGL_TEXGEN_PARAM_EYE_PLANE			= 0x2502,
	}	eGL_TEXGEN_PARAM;

	typedef enum eGL_TEXGEN_MODE
	{
		eGL_TEXGEN_MODE_SPHERE_MAP		= 0x2402,
		eGL_TEXGEN_MODE_NORMAL_MAP		= 0x8511,
		eGL_TEXGEN_MODE_REFLECTION_MAP	= 0x8512,
		eGL_TEXGEN_MODE_CUBE_MAP		= 0x8513,
	}	eGL_TEXGEN_MODE;

	typedef enum eGL_BOOLEAN
	{
		eGL_FALSE	= 0,
		eGL_TRUE	= 1,
	}	eGL_BOOLEAN;

	typedef enum eGL_LIGHT_MODEL_PARAM
	{
		eGL_LIGHT_MODEL_PARAM_LOCAL_VIEWER				= 0x0B51,
		eGL_LIGHT_MODEL_PARAM_COLOR_CONTROL				= 0x81F8,
		eGL_LIGHT_MODEL_PARAM_SEPARATE_SPECULAR_COLOR	= 0x81FA,
	}	eGL_LIGHT_MODEL_PARAM;

	typedef enum eGL_SHADE_MODEL
	{
		eGL_SHADE_MODEL_FLAT	= 0x1D00,
		eGL_SHADE_MODEL_SMOOTH	= 0x1D01,
	}	eGL_SHADE_MODEL;

	typedef enum eGL_TWEAK
	{
		eGL_TWEAK_LINE_SMOOTH				= 0x0B20,
		eGL_TWEAK_CULL_FACE					= 0x0B44,
		eGL_TWEAK_LIGHTING					= 0x0B50,
		eGL_TWEAK_FOG						= 0x0B60,
		eGL_TWEAK_DEPTH_TEST				= 0x0B71,
		eGL_TWEAK_STENCIL_TEST				= 0x0B90,
		eGL_TWEAK_NORMALIZE					= 0x0BA1,
		eGL_TWEAK_ALPHA_TEST				= 0x0BC0,
		eGL_TWEAK_DITHER					= 0x0BD0,
		eGL_TWEAK_BLEND						= 0x0BE2,
		eGL_TWEAK_SCISSOR_TEST				= 0x0C11,
		eGL_TWEAK_TEXTURE_GEN_S				= 0x0C60,
		eGL_TWEAK_TEXTURE_GEN_T				= 0x0C61,
		eGL_TWEAK_TEXTURE_GEN_R				= 0x0C62,
		eGL_TWEAK_TEXTURE_GEN_Q				= 0x0C63,
		eGL_TWEAK_MULTISAMPLE				= 0x809D,
		eGL_TWEAK_ALPHA_TO_COVERAGE			= 0x809E,
		eGL_TWEAK_DEBUG_OUTPUT_SYNCHRONOUS	= 0x8242,
		eGL_TWEAK_DEPTH_CLAMP				= 0x864F,
	}	eGL_TWEAK;

	typedef enum eGL_RENDER_MODE
	{
		eGL_RENDER_MODE_RENDER		= 0x1C00,
		eGL_RENDER_MODE_FEEDBACK	= 0x1C01,
		eGL_RENDER_MODE_SELECT		= 0x1C02,
	}	eGL_RENDER_MODE;

	typedef enum eGL_FRAMEBUFFER_STATUS
	{
		eGL_FRAMEBUFFER_COMPLETE						= 0x8CD5,
		eGL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT			= 0x8CD6,
		eGL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT	= 0x8CD7,
		eGL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER			= 0x8CDB,
		eGL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER			= 0x8CDC,
		eGL_FRAMEBUFFER_UNSUPPORTED						= 0x8CDD,
		eGL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE			= 0x8D56,
		eGL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS		= 0x8DA8,
	}	eGL_FRAMEBUFFER_STATUS;

	typedef enum eGL_TEXTURE_ATTACHMENT
	{
		eGL_TEXTURE_ATTACHMENT_NONE		= 0x0000,
		eGL_TEXTURE_ATTACHMENT_COLOR0	= 0x8CE0,
		eGL_TEXTURE_ATTACHMENT_DEPTH	= 0x8D00,
		eGL_TEXTURE_ATTACHMENT_STENCIL	= 0x8D20,
	}	eGL_TEXTURE_ATTACHMENT;

	typedef enum eGL_FRAMEBUFFER_MODE
	{
		eGL_FRAMEBUFFER_MODE_READ		= 0x8CA8,
		eGL_FRAMEBUFFER_MODE_DRAW		= 0x8CA9,
		eGL_FRAMEBUFFER_MODE_DEFAULT	= 0x8D40,
	}	eGL_FRAMEBUFFER_MODE;

	typedef enum eGL_RENDERBUFFER_MODE
	{
		eGL_RENDERBUFFER_MODE_DEFAULT	= 0x8D41
	}	eGL_RENDERBUFFER_MODE;

	typedef enum eGL_RENDERBUFFER_ATTACHMENT
	{
		eGL_RENDERBUFFER_ATTACHMENT_NONE	= 0x0000,
		eGL_RENDERBUFFER_ATTACHMENT_COLOR0	= 0x8CE0,
		eGL_RENDERBUFFER_ATTACHMENT_COLOR1	= 0x8CE1,
		eGL_RENDERBUFFER_ATTACHMENT_COLOR2	= 0x8CE2,
		eGL_RENDERBUFFER_ATTACHMENT_COLOR3	= 0x8CE3,
		eGL_RENDERBUFFER_ATTACHMENT_COLOR4	= 0x8CE4,
		eGL_RENDERBUFFER_ATTACHMENT_COLOR5	= 0x8CE5,
		eGL_RENDERBUFFER_ATTACHMENT_COLOR6	= 0x8CE6,
		eGL_RENDERBUFFER_ATTACHMENT_COLOR7	= 0x8CE7,
		eGL_RENDERBUFFER_ATTACHMENT_COLOR8	= 0x8CE8,
		eGL_RENDERBUFFER_ATTACHMENT_COLOR9	= 0x8CE9,
		eGL_RENDERBUFFER_ATTACHMENT_COLOR10	= 0x8CEA,
		eGL_RENDERBUFFER_ATTACHMENT_COLOR11	= 0x8CEB,
		eGL_RENDERBUFFER_ATTACHMENT_COLOR12	= 0x8CEC,
		eGL_RENDERBUFFER_ATTACHMENT_COLOR13	= 0x8CED,
		eGL_RENDERBUFFER_ATTACHMENT_COLOR14	= 0x8CEE,
		eGL_RENDERBUFFER_ATTACHMENT_COLOR15	= 0x8CEF,
		eGL_RENDERBUFFER_ATTACHMENT_DEPTH	= 0x8D00,
		eGL_RENDERBUFFER_ATTACHMENT_STENCIL	= 0x8D20,
	}	eGL_RENDERBUFFER_ATTACHMENT;

	typedef enum eGL_RENDERBUFFER_PARAMETER
	{
		eGL_RENDERBUFFER_PARAMETER_WIDTH			= 0x8D42,
		eGL_RENDERBUFFER_PARAMETER_HEIGHT			= 0x8D43,
		eGL_RENDERBUFFER_PARAMETER_INTERNAL_FORMAT	= 0x8D44,
		eGL_RENDERBUFFER_PARAMETER_RED_SIZE			= 0x8D50,
		eGL_RENDERBUFFER_PARAMETER_GREEN_SIZE		= 0x8D51,
		eGL_RENDERBUFFER_PARAMETER_BLUE_SIZE		= 0x8D52,
		eGL_RENDERBUFFER_PARAMETER_ALPHA_SIZE		= 0x8D53,
		eGL_RENDERBUFFER_PARAMETER_DEPTH_SIZE		= 0x8D54,
		eGL_RENDERBUFFER_PARAMETER_STENCIL_SIZE		= 0x8D55,
	}	eGL_RENDERBUFFER_PARAMETER;

	typedef enum eGL_RENDERBUFFER_STORAGE
	{
		eGL_RENDERBUFFER_STORAGE_L8					= 0x8229,
		eGL_RENDERBUFFER_STORAGE_L16F				= 0x822D,
		eGL_RENDERBUFFER_STORAGE_L32F				= 0x822E,
		eGL_RENDERBUFFER_STORAGE_A8L8				= 0x822C,
		eGL_RENDERBUFFER_STORAGE_AL16F				= 0x822F,
		eGL_RENDERBUFFER_STORAGE_AL32F				= 0x8230,
		eGL_RENDERBUFFER_STORAGE_RGB5_A1			= 0x8057,
		eGL_RENDERBUFFER_STORAGE_RGBA4				= 0x8056,
		eGL_RENDERBUFFER_STORAGE_RGB565				= 0x8D62,
		eGL_RENDERBUFFER_STORAGE_RGB8				= 0x8051,
		eGL_RENDERBUFFER_STORAGE_RGBA8				= 0x8058,
		eGL_RENDERBUFFER_STORAGE_DXTC1				= 0x83F1,
		eGL_RENDERBUFFER_STORAGE_DXTC3				= 0x83F2,
		eGL_RENDERBUFFER_STORAGE_DXTC5				= 0x83F3,
		eGL_RENDERBUFFER_STORAGE_RGB16F				= 0x881B,
		eGL_RENDERBUFFER_STORAGE_RGBA16F			= 0x881A,
		eGL_RENDERBUFFER_STORAGE_RGB32F				= 0x8815,
		eGL_RENDERBUFFER_STORAGE_RGBA32F			= 0x8814,
		eGL_RENDERBUFFER_STORAGE_DEPTH24_STENCIL8	= 0x88F0,
		eGL_RENDERBUFFER_STORAGE_DEPTH16			= 0x81A5,
		eGL_RENDERBUFFER_STORAGE_DEPTH24			= 0x81A6,
		eGL_RENDERBUFFER_STORAGE_DEPTH32			= 0x81A7,
		eGL_RENDERBUFFER_STORAGE_STENCIL1			= 0x8D46,
		eGL_RENDERBUFFER_STORAGE_STENCIL4			= 0x8D47,
		eGL_RENDERBUFFER_STORAGE_STENCIL8			= 0x8D48,
		eGL_RENDERBUFFER_STORAGE_STENCIL16			= 0x8D49,
	}	eGL_RENDERBUFFER_STORAGE;

	typedef enum eGL_FRONT_FACE_DIRECTION
	{
		eGL_FRONT_FACE_DIRECTION_CW		= 0x0900,
		eGL_FRONT_FACE_DIRECTION_CCW	= 0x0901,
	}	eGL_FRONT_FACE_DIRECTION;

	typedef enum eGL_DRAW_BUFFER_MODE
	{
		eGL_DRAW_BUFFER_MODE_NONE			= 0x0000,
		eGL_DRAW_BUFFER_MODE_FRONT_LEFT 	= 0x0400,
		eGL_DRAW_BUFFER_MODE_FRONT_RIGHT	= 0x0401,
		eGL_DRAW_BUFFER_MODE_BACK_LEFT		= 0x0402,
		eGL_DRAW_BUFFER_MODE_BACK_RIGHT		= 0x0403,
		eGL_DRAW_BUFFER_MODE_FRONT			= 0x0404,
		eGL_DRAW_BUFFER_MODE_BACK			= 0x0405,
		eGL_DRAW_BUFFER_MODE_LEFT			= 0x0406,
		eGL_DRAW_BUFFER_MODE_RIGHT			= 0x0407,
		eGL_DRAW_BUFFER_MODE_FRONT_AND_BACK	= 0x0408,
		eGL_DRAW_BUFFER_MODE_AUX0			= 0x0409,
		eGL_DRAW_BUFFER_MODE_AUX1			= 0x040A,
		eGL_DRAW_BUFFER_MODE_AUX2			= 0x040B,
		eGL_DRAW_BUFFER_MODE_AUX3			= 0x040C,
	}	eGL_DRAW_BUFFER_MODE;

	typedef enum eGL_MATRIX_TYPE CASTOR_TYPE( uint32_t )
	{
		eGL_MATRIX_TYPE_MODELVIEW	= 0x1700,
		  eGL_MATRIX_TYPE_PROJECTION	= 0x1701,
		   eGL_MATRIX_TYPE_TEXTURE		= 0x1702,
	}	eGL_MATRIX_TYPE;

	typedef enum eGL_MATRIX CASTOR_TYPE( uint32_t )
	{
		eGL_MATRIX_MODELVIEW	= 0x0BA6,
		   eGL_MATRIX_PROJECTION	= 0x0BA7,
			 eGL_MATRIX_TEXTURE		= 0x0BA8,
	}	eGL_MATRIX;

	typedef enum eGL_GETINTEGER_PARAM
	{
		eGL_GETINTEGER_PARAM_VIEWPORT						= 0x0BA2,
		eGL_GETINTEGER_PARAM_MAX_GEOMETRY_OUTPUT_VERTICES	= 0x8DE0,
	}	eGL_GETINTEGER_PARAM;

	typedef enum eGL_PROGRAM_PARAM
	{
		eGL_PROGRAM_PARAM_GEOMETRY_VERTICES_OUT	= 0x8DDA,//0x8916
		eGL_PROGRAM_PARAM_GEOMETRY_INPUT_TYPE	= 0x8DDB,//0x8917
		eGL_PROGRAM_PARAM_GEOMETRY_OUTPUT_TYPE	= 0x8DDC,//0x8918
	}	eGL_PROGRAM_PARAM;

	typedef enum eGL_BUFFER_BIT
	{
		eGL_BUFFER_BIT_COLOR	= 0x00004000,
		eGL_BUFFER_BIT_DEPTH	= 0x00000100,
		eGL_BUFFER_BIT_STENCIL	= 0x00000400,
	}	eGL_BUFFER_BIT;

	typedef enum eGL_OTHERS CASTOR_TYPE( uint32_t )
	{
		eGL_INVALID_INDEX	= 0xFFFFFFFF,
	}	eGL_OTHERS;

	typedef enum eGL_BUFFER_MAPPING_BIT
	{
		eGL_BUFFER_MAPPING_BIT_READ					= 0x0001,
		eGL_BUFFER_MAPPING_BIT_WRITE				= 0x0002,
		eGL_BUFFER_MAPPING_BIT_INVALIDATE_RANGE		= 0x0004,
		eGL_BUFFER_MAPPING_BIT_INVALIDATE_BUFFER	= 0x0008,
		eGL_BUFFER_MAPPING_BIT_FLUSH_EXPLICIT		= 0x0010,
		eGL_BUFFER_MAPPING_BIT_UNSYNCHRONIZED		= 0x0020,
	}	eGL_BUFFER_MAPPING_BIT;

	typedef enum eGL_FACE
	{
		eGL_FACE_FRONT			= 0x0404,
		eGL_FACE_BACK			= 0x0405,
		eGL_FACE_FRONT_AND_BACK	= 0x0408,
	}	eGL_FACE;

	typedef enum eGL_STENCIL_OP
	{
		eGL_STENCIL_OP_ZERO			= 0x0000,
		eGL_STENCIL_OP_INVERT		= 0x150A,
		eGL_STENCIL_OP_KEEP			= 0x1E00,
		eGL_STENCIL_OP_REPLACE		= 0x1E01,
		eGL_STENCIL_OP_INCR			= 0x1E02,
		eGL_STENCIL_OP_DECR			= 0x1E03,
		eGL_STENCIL_OP_INCR_WRAP	= 0x8507,
		eGL_STENCIL_OP_DECR_WRAP	= 0x8508,
	}	eGL_STENCIL_OP;

	typedef enum eGL_FILL_MODE
	{
		eGL_FILL_MODE_POINT	= 0x1B00,
		eGL_FILL_MODE_LINE	= 0x1B01,
		eGL_FILL_MODE_FILL	= 0x1B02,
	}	eGL_FILL_MODE;

	typedef enum eGL_SAMPLER_PARAMETER
	{
		eGL_SAMPLER_PARAMETER_BORDERCOLOUR	= 0x1004,
		eGL_SAMPLER_PARAMETER_MAGFILTER		= 0x2800,
		eGL_SAMPLER_PARAMETER_MINFILTER		= 0x2801,
		eGL_SAMPLER_PARAMETER_UWRAP			= 0x2802,
		eGL_SAMPLER_PARAMETER_VWRAP			= 0x2803,
		eGL_SAMPLER_PARAMETER_WWRAP			= 0x8072,
		eGL_SAMPLER_PARAMETER_MINLOD		= 0x813A,
		eGL_SAMPLER_PARAMETER_MAXLOD		= 0x813B,
		eGL_SAMPLER_PARAMETER_MAXANISOTROPY	= 0x84FE,
		eGL_SAMPLER_PARAMETER_LODBIAS		= 0x8501,
	}	eGL_SAMPLER_PARAMETER;

	typedef enum eGL_DEBUG_TYPE CASTOR_TYPE( uint32_t )
	{
		eGL_DEBUG_TYPE_ERROR				= 0x824C,
		eGL_DEBUG_TYPE_DEPRECATED_BEHAVIOR	= 0x824D,
		eGL_DEBUG_TYPE_UNDEFINED_BEHAVIOR	= 0x824E,
		eGL_DEBUG_TYPE_PORTABILITY			= 0x824F,
		eGL_DEBUG_TYPE_PERFORMANCE			= 0x8250,
		eGL_DEBUG_TYPE_OTHER				= 0x8251,
	}	eGL_DEBUG_TYPE;

	typedef enum eGL_DEBUG_SOURCE CASTOR_TYPE( uint32_t )
	{
		eGL_DEBUG_SOURCE_API				= 0x8246,
		eGL_DEBUG_SOURCE_WINDOW_SYSTEM		= 0x8247,
		eGL_DEBUG_SOURCE_SHADER_COMPILER	= 0x8248,
		eGL_DEBUG_SOURCE_THIRD_PARTY		= 0x8249,
		eGL_DEBUG_SOURCE_APPLICATION		= 0x824A,
		eGL_DEBUG_SOURCE_OTHER				= 0x824B,
	}	eGL_DEBUG_SOURCE;

	typedef enum eGL_DEBUG_CATEGORY CASTOR_TYPE( uint32_t )
	{
		eGL_DEBUG_CATEGORY_API_ERROR			= 0x9149,
		eGL_DEBUG_CATEGORY_WINDOW_SYSTEM		= 0x914A,
		eGL_DEBUG_CATEGORY_DEPRECATION			= 0x914B,
		eGL_DEBUG_CATEGORY_UNDEFINED_BEHAVIOR	= 0x914C,
		eGL_DEBUG_CATEGORY_PERFORMANCE			= 0x914D,
		eGL_DEBUG_CATEGORY_SHADER_COMPILER		= 0x914E,
		eGL_DEBUG_CATEGORY_APPLICATION			= 0x914F,
		eGL_DEBUG_CATEGORY_OTHER				= 0x9150,
	}	eGL_DEBUG_CATEGORY;

	typedef enum eGL_DEBUG_SEVERITY CASTOR_TYPE( uint32_t )
	{
		eGL_DEBUG_SEVERITY_HIGH		= 0x9146,
		eGL_DEBUG_SEVERITY_MEDIUM	= 0x9147,
		eGL_DEBUG_SEVERITY_LOW		= 0x9148,
	}	eGL_DEBUG_SEVERITY;

	typedef enum eGL_MAX CASTOR_TYPE( uint32_t )
	{
		eGL_MAX_TEXTURE_SIZE						= 0x0D33,
						  eGL_MAX_ELEMENTS_VERTICES					= 0x80E8,
										eGL_MAX_ELEMENTS_INDICES					= 0x80E9,
													   eGL_MAX_COMPUTE_SHARED_MEMORY_SIZE			= 0x8262,
															  eGL_MAX_COMPUTE_UNIFORM_COMPONENTS			= 0x8263,
																	 eGL_MAX_COMPUTE_ATOMIC_COUNTER_BUFFERS		= 0x8264,
																		 eGL_MAX_COMPUTE_ATOMIC_COUNTERS				= 0x8265,
																				  eGL_MAX_COMBINED_COMPUTE_UNIFORM_COMPONENTS = 0x8266,
																				  eGL_MAX_RENDERBUFFER_SIZE					= 0x84E8,
																								eGL_MAX_TEXTURE_LOD_BIAS					= 0x84FD,
																											   eGL_MAX_RECTANGLE_TEXTURE_SIZE				= 0x84F8,
																														 eGL_MAX_TEXTURE_UNITS						= 0x84E2,
																																		  eGL_MAX_CUBE_MAP_TEXTURE_SIZE				= 0x851C,
																																					 eGL_MAX_DRAW_BUFFERS						= 0x8824,
																																									   eGL_MAX_VERTEX_ATTRIBS						= 0x8869,
																																													   eGL_MAX_TEXTURE_COORDS						= 0x8871,
																																																	   eGL_MAX_TEXTURE_IMAGE_UNITS					= 0x8872,
																																																				   eGL_MAX_UNIFORM_BUFFER_BINDINGS				= 0x8A2F,
																																																							eGL_MAX_FRAGMENT_UNIFORM_COMPONENTS			= 0x8B49,
																																																								  eGL_MAX_VERTEX_UNIFORM_COMPONENTS			= 0x8B4A,
																																																										  eGL_MAX_VARYING_FLOATS						= 0x8B4B,
																																																														  eGL_MAX_VERTEX_TEXTURE_IMAGE_UNITS			= 0x8B4C,
																																																																 eGL_MAX_COMBINED_TEXTURE_IMAGE_UNITS		= 0x8B4D,
																																																																	   eGL_MAX_TEXTURE_BUFFER_SIZE					= 0x8C2B,
																																																																				   eGL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS		= 0x8C29,
																																																																						 eGL_MAX_COLOR_ATTACHMENTS					= 0x8CDF,
																																																																									   eGL_MAX_SAMPLES								= 0x8D57,
																																																																															eGL_MAX_GEOMETRY_UNIFORM_COMPONENTS			= 0x8DDF,
																																																																																  eGL_MAX_GEOMETRY_OUTPUT_VERTICES			= 0x8DE0,
																																																																																		   eGL_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS	= 0x8DE1,
																																																																																			  eGL_MAX_VERTEX_OUTPUT_COMPONENTS			= 0x9122,
																																																																																					   eGL_MAX_GEOMETRY_INPUT_COMPONENTS			= 0x9123,
																																																																																							   eGL_MAX_GEOMETRY_OUTPUT_COMPONENTS			= 0x9124,
																																																																																									  eGL_MAX_FRAGMENT_INPUT_COMPONENTS			= 0x9125,
																																																																																											  eGL_MAX_DEBUG_MESSAGE_LENGTH_ARB			= 0x9143,
																																																																																													   eGL_MAX_DEBUG_LOGGED_MESSAGES_ARB			= 0x9144,
																																																																																															   eGL_MAX_COMPUTE_UNIFORM_BLOCKS				= 0x91BB,
																																																																																																		 eGL_MAX_COMPUTE_TEXTURE_IMAGE_UNITS			= 0x91BC,
																																																																																																			   eGL_MAX_COMPUTE_IMAGE_UNIFORMS				= 0x91BD,
																																																																																																						 eGL_MAX_COMPUTE_WORK_GROUP_COUNT			= 0x91BE,
																																																																																																								  eGL_MAX_COMPUTE_WORK_GROUP_SIZE				= 0x91BF,
																																																																																																										   eGL_MAX_FRAMEBUFFER_WIDTH					= 0x9315,
																																																																																																														 eGL_MAX_FRAMEBUFFER_HEIGHT					= 0x9316,
																																																																																																																	  eGL_MAX_FRAMEBUFFER_LAYERS					= 0x9317,
																																																																																																																				   eGL_MAX_FRAMEBUFFER_SAMPLES					= 0x9318,
	}	eGL_MAX;

	typedef enum eGL_HINT
	{
		eGL_HINT_LINE_SMOOTH			= 0x0C52,
		eGL_HINT_POLYGON_SMOOTH			= 0x0C53,
		eGL_HINT_VOLUME_CLIPPING		= 0x80F0,
		eGL_HINT_TEXTURE_COMPRESSION	= 0x84EF,
		eGL_HINT_SHADER_DERIVATIVE		= 0x8B8B,
	}	eGL_HINT;

	typedef enum eGL_HINT_VALUE
	{
		eGL_HINT_VALUE_DONTCARE	= 0x1100,
		eGL_HINT_VALUE_FASTEST	= 0x1101,
		eGL_HINT_VALUE_NICEST	= 0x1102,
	}	eGL_HINT_VALUE;

	typedef enum eGL_STORAGE_MODE CASTOR_TYPE( uint32_t )
	{
		eGL_STORAGE_MODE_UNPACK_SWAP_BYTES		= 0x0CF0,
			eGL_STORAGE_MODE_UNPACK_LSB_FIRST		= 0x0CF1,
				 eGL_STORAGE_MODE_UNPACK_ROW_LENGTH		= 0x0CF2,
					 eGL_STORAGE_MODE_UNPACK_SKIP_ROWS		= 0x0CF3,
						  eGL_STORAGE_MODE_UNPACK_SKIP_PIXELS		= 0x0CF4,
							 eGL_STORAGE_MODE_UNPACK_ALIGNMENT		= 0x0CF5,
								  eGL_STORAGE_MODE_PACK_SWAP_BYTES		= 0x0D00,
										eGL_STORAGE_MODE_PACK_LSB_FIRST			= 0x0D01,
											  eGL_STORAGE_MODE_PACK_ROW_LENGTH		= 0x0D02,
													eGL_STORAGE_MODE_PACK_SKIP_ROWS			= 0x0D03,
														  eGL_STORAGE_MODE_PACK_SKIP_PIXELS		= 0x0D04,
															   eGL_STORAGE_MODE_PACK_ALIGNMENT			= 0x0D05,
																	 eGL_STORAGE_MODE_PACK_IMAGE_HEIGHT		= 0x806C,
																		 eGL_STORAGE_MODE_UNPACK_IMAGE_HEIGHT	= 0x806E,
	}	eGL_STORAGE_MODE;

	typedef enum eGL_BUFFER_PARAMETER CASTOR_TYPE( uint32_t )
	{
		eGL_BUFFER_PARAMETER_SIZE			= 0x8764,
				eGL_BUFFER_PARAMETER_USAGE			= 0x8765,
					   eGL_BUFFER_PARAMETER_ACCESS			= 0x88BB,
							 eGL_BUFFER_PARAMETER_MAPPED			= 0x88BD,
								   eGL_BUFFER_PARAMETER_GPU_ADDRESS	= 0x8F1D,
	}	eGL_BUFFER_PARAMETER;

	typedef enum eGL_RESIDENT_BUFFER_ACCESS CASTOR_TYPE( uint32_t )
	{
		eGL_RESIDENT_BUFFER_ACCESS_READ_ONLY	= 0x88B8
	}	eGL_RESIDENT_BUFFER_ACCESS;

	typedef enum eGL_ADDRESS CASTOR_TYPE( uint32_t )
	{
		eGL_ADDRESS_VERTEX_ATTRIB_ARRAY		= 0x8F20,
		eGL_ADDRESS_TEXTURE_COORD_ARRAY		= 0x8F25,
		eGL_ADDRESS_VERTEX_ARRAY			= 0x8F21,
		eGL_ADDRESS_NORMAL_ARRAY			= 0x8F22,
		eGL_ADDRESS_COLOR_ARRAY				= 0x8F23,
		eGL_ADDRESS_INDEX_ARRAY				= 0x8F24,
		eGL_ADDRESS_EDGE_FLAG_ARRAY			= 0x8F26,
		eGL_ADDRESS_SECONDARY_COLOR_ARRAY	= 0x8F27,
		eGL_ADDRESS_FOG_COORD_ARRAY			= 0x8F28,
		eGL_ADDRESS_ELEMENT_ARRAY			= 0x8F29,
	}	eGL_ADDRESS;

	class OpenGl;

	class MtxFunctionsBase
	{
	public:
		MtxFunctionsBase( OpenGl & p_gl );
		virtual bool MatrixMode( eGL_MATRIX_TYPE mode ) = 0;
		virtual bool LoadIdentity() = 0;
		virtual bool Ortho( double left, double right, double bottom, double top, double zNear, double zFar ) = 0;
		virtual bool Frustum( double left, double right, double bottom, double top, double zNear, double zFar ) = 0;
		virtual bool PushMatrix() = 0;
		virtual bool PopMatrix() = 0;
		virtual bool Translate( real x, real y, real z ) = 0;
		virtual bool Rotate( real angle, real x, real y, real z ) = 0;
		virtual bool Scale( real x, real y, real z ) = 0;
		virtual bool MultMatrix( real const * matrix ) = 0;

	protected:
		OpenGl & m_gl;
	};

	class MtxFunctions : public MtxFunctionsBase
	{
	public:
		MtxFunctions( OpenGl & p_gl );
		virtual bool MatrixMode( eGL_MATRIX_TYPE mode );
		virtual bool LoadIdentity();
		virtual bool Ortho( double left, double right, double bottom, double top, double zNear, double zFar );
		virtual bool Frustum( double left, double right, double bottom, double top, double zNear, double zFar );
		virtual bool PushMatrix();
		virtual bool PopMatrix();
		virtual bool Translate( real x, real y, real z );
		virtual bool Rotate( real angle, real x, real y, real z );
		virtual bool Scale( real x, real y, real z );
		virtual bool MultMatrix( real const * matrix );

		std::function< void( uint32_t mode ) > m_pfnMatrixMode;
		std::function< void() > m_pfnLoadIdentity;
#if CASTOR_HAS_VARIADIC_TEMPLATES
		std::function< void( double left, double right, double bottom, double top, double zNear, double zFar ) > m_pfnOrtho;
		std::function< void( double left, double right, double bottom, double top, double zNear, double zFar ) > m_pfnFrustum;
#else
		void ( CALLBACK * m_pfnOrtho )( double left, double right, double bottom, double top, double zNear, double zFar );
		void ( CALLBACK * m_pfnFrustum )( double left, double right, double bottom, double top, double zNear, double zFar );
#endif
		std::function< void() > m_pfnPushMatrix;
		std::function< void() > m_pfnPopMatrix;
		std::function< void( real x, real y, real z ) > m_pfnTranslate;
		std::function< void( real angle, real x, real y, real z ) > m_pfnRotate;
		std::function< void( real x, real y, real z ) > m_pfnScale;
		std::function< void( real const * matrix ) > m_pfnMultMatrix;
	};

	class MtxFunctionsDSA : public MtxFunctionsBase
	{
	public:
		MtxFunctionsDSA( OpenGl & p_gl );
		virtual bool MatrixMode( eGL_MATRIX_TYPE mode )
		{
			m_eMatrixMode = mode;
			return true;
		}
		virtual bool LoadIdentity();
		virtual bool Ortho( double left, double right, double bottom, double top, double zNear, double zFar );
		virtual bool Frustum( double left, double right, double bottom, double top, double zNear, double zFar );
		virtual bool PushMatrix();
		virtual bool PopMatrix();
		virtual bool Translate( real x, real y, real z );
		virtual bool Rotate( real angle, real x, real y, real z );
		virtual bool Scale( real x, real y, real z );
		virtual bool MultMatrix( real const * matrix );

		eGL_MATRIX_TYPE m_eMatrixMode;
		std::function< void( uint32_t mtxMode ) > m_pfnMatrixLoadIdentity;
#if CASTOR_HAS_VARIADIC_TEMPLATES
		std::function< void( uint32_t mtxMode, double left, double right, double bottom, double top, double zNear, double zFar ) > m_pfnMatrixOrtho;
		std::function< void( uint32_t mtxMode, double left, double right, double bottom, double top, double zNear, double zFar ) > m_pfnMatrixFrustum;
#else
		void ( CALLBACK * m_pfnMatrixOrtho )( uint32_t mtxMode, double left, double right, double bottom, double top, double zNear, double zFar );
		void ( CALLBACK * m_pfnMatrixFrustum )( uint32_t mtxMode, double left, double right, double bottom, double top, double zNear, double zFar );
#endif
		std::function< void( uint32_t mtxMode ) > m_pfnMatrixPush;
		std::function< void( uint32_t mtxMode ) > m_pfnMatrixPop;
#if CASTOR_USE_DOUBLE
		std::function< void( uint32_t mtxMode, real x, real y, real z ) > m_pfnMatrixTranslated;
		std::function< void( uint32_t mtxMode, real angle, real x, real y, real z ) > m_pfnMatrixRotated;
		std::function< void( uint32_t mtxMode, real x, real y, real z ) > m_pfnMatrixScaled;
		std::function< void( uint32_t mtxMode, real const * matrix ) > m_pfnMatrixMultd;
#else
		std::function< void( uint32_t mtxMode, real x, real y, real z ) > m_pfnMatrixTranslatef;
		std::function< void( uint32_t mtxMode, real angle, real x, real y, real z ) > m_pfnMatrixRotatef;
		std::function< void( uint32_t mtxMode, real x, real y, real z ) > m_pfnMatrixScalef;
		std::function< void( uint32_t mtxMode, real const * matrix ) > m_pfnMatrixMultf;
#endif
	};

	class TexFunctionsBase
	{
	public:
		TexFunctionsBase( OpenGl & p_gl );
		virtual bool GenerateMipmap( eGL_TEXDIM p_eTarget ) = 0;
		virtual bool BindTexture( eGL_TEXDIM p_eTarget, uint32_t texture ) = 0;
		virtual bool TexSubImage1D( eGL_TEXDIM p_eTarget, int level, int xoffset, int width, eGL_FORMAT format, eGL_TYPE type, void const * data ) = 0;
		virtual bool TexSubImage2D( eGL_TEXDIM p_eTarget, int level, int xoffset, int yoffset, int width, int height, eGL_FORMAT format, eGL_TYPE type, void const * data ) = 0;
		virtual bool TexSubImage2D( eGL_TEXDIM p_eTarget, int level, Castor::Position const & p_position, Castor::Size const & p_size, eGL_FORMAT format, eGL_TYPE type, void const * data ) = 0;
		virtual bool TexSubImage2D( eGL_TEXDIM p_eTarget, int level, Castor::Rectangle const & p_rect, eGL_FORMAT format, eGL_TYPE type, void const * data ) = 0;
		virtual bool TexSubImage3D( eGL_TEXDIM p_eTarget, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, eGL_FORMAT format, eGL_TYPE type, void const * data ) = 0;
		virtual bool TexImage1D( eGL_TEXDIM p_eTarget, int level, eGL_INTERNAL internalFormat, int width, int border, eGL_FORMAT format, uint32_t type, void const * data ) = 0;
		virtual bool TexImage2D( eGL_TEXDIM p_eTarget, int level, eGL_INTERNAL internalFormat, int width, int height, int border, eGL_FORMAT format, uint32_t type, void const * data ) = 0;
		virtual bool TexImage2D( eGL_TEXDIM p_eTarget, int level, eGL_INTERNAL internalFormat, Castor::Size const & p_size, int border, eGL_FORMAT format, uint32_t type, void const * data ) = 0;
		virtual bool TexImage3D( eGL_TEXDIM p_eTarget, int level, eGL_INTERNAL internalFormat, int width, int height, int depth, int border, eGL_FORMAT format, uint32_t type, void const * data ) = 0;
		virtual bool TexParameter( eGL_TEXDIM p_eTarget, eGL_TEXTURE_PARAMETER pname, int param ) = 0;
		virtual bool TexParameter( eGL_TEXDIM p_eTarget, eGL_TEXTURE_PARAMETER pname, float param ) = 0;
		virtual bool TexParameter( eGL_TEXDIM p_eTarget, eGL_TEXTURE_PARAMETER pname, const int * params ) = 0;
		virtual bool TexParameter( eGL_TEXDIM p_eTarget, eGL_TEXTURE_PARAMETER pname, const float * params ) = 0;
		virtual bool GetTexImage( eGL_TEXDIM p_eTarget, int level, eGL_FORMAT format, eGL_TYPE type, void * img ) = 0;

	protected:
		OpenGl & m_gl;
	};

	class TexFunctions : public TexFunctionsBase
	{
	public:
		TexFunctions( OpenGl & p_gl );
		virtual bool BindTexture( eGL_TEXDIM p_eTarget, uint32_t texture );
		virtual bool GenerateMipmap( eGL_TEXDIM p_eTarget );
		virtual bool TexSubImage1D( eGL_TEXDIM p_eTarget, int level, int xoffset, int width, eGL_FORMAT format, eGL_TYPE type, void const * data );
		virtual bool TexSubImage2D( eGL_TEXDIM p_eTarget, int level, int xoffset, int yoffset, int width, int height, eGL_FORMAT format, eGL_TYPE type, void const * data );
		virtual bool TexSubImage2D( eGL_TEXDIM p_eTarget, int level, Castor::Position const & p_position, Castor::Size const & p_size, eGL_FORMAT format, eGL_TYPE type, void const * data );
		virtual bool TexSubImage2D( eGL_TEXDIM p_eTarget, int level, Castor::Rectangle const & p_rect, eGL_FORMAT format, eGL_TYPE type, void const * data );
		virtual bool TexSubImage3D( eGL_TEXDIM p_eTarget, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, eGL_FORMAT format, eGL_TYPE type, void const * data );
		virtual bool TexImage1D( eGL_TEXDIM p_eTarget, int level, eGL_INTERNAL internalFormat, int width, int border, eGL_FORMAT format, uint32_t type, void const * data );
		virtual bool TexImage2D( eGL_TEXDIM p_eTarget, int level, eGL_INTERNAL internalFormat, int width, int height, int border, eGL_FORMAT format, uint32_t type, void const * data );
		virtual bool TexImage2D( eGL_TEXDIM p_eTarget, int level, eGL_INTERNAL internalFormat, Castor::Size const & p_size, int border, eGL_FORMAT format, uint32_t type, void const * data );
		virtual bool TexImage3D( eGL_TEXDIM p_eTarget, int level, eGL_INTERNAL internalFormat, int width, int height, int depth, int border, eGL_FORMAT format, uint32_t type, void const * data );
		virtual bool TexParameter( eGL_TEXDIM p_eTarget, eGL_TEXTURE_PARAMETER pname, int param );
		virtual bool TexParameter( eGL_TEXDIM p_eTarget, eGL_TEXTURE_PARAMETER pname, float param );
		virtual bool TexParameter( eGL_TEXDIM p_eTarget, eGL_TEXTURE_PARAMETER pname, const int * params );
		virtual bool TexParameter( eGL_TEXDIM p_eTarget, eGL_TEXTURE_PARAMETER pname, const float * params );
		virtual bool GetTexImage( eGL_TEXDIM p_eTarget, int level, eGL_FORMAT format, eGL_TYPE type, void * img );

		std::function< void( uint32_t mode, uint32_t texture ) > m_pfnBindTexture;
#if CASTOR_HAS_VARIADIC_TEMPLATES
		std::function< void( uint32_t target, int level, int xoffset, int width, uint32_t format, uint32_t type, void const * data ) > m_pfnTexSubImage1D;
		std::function< void( uint32_t target, int level, int xoffset, int yoffset, int width, int height, uint32_t format, uint32_t type, void const * data ) > m_pfnTexSubImage2D;
		std::function< void( uint32_t target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, uint32_t format, uint32_t type, void const * data ) > m_pfnTexSubImage3D;
		std::function< void( uint32_t target, int level, int internalFormat, int width, int border, uint32_t format, uint32_t type, void const * data ) > m_pfnTexImage1D;
		std::function< void( uint32_t target, int level, int internalFormat, int width, int height, int border, uint32_t format, uint32_t type, void const * data ) > m_pfnTexImage2D;
		std::function< void( uint32_t target, int level, int internalFormat, int width, int height, int depth, int border, uint32_t format, uint32_t type, void const * data ) > m_pfnTexImage3D;
#else
		void ( CALLBACK * m_pfnTexSubImage1D )( uint32_t target, int level, int xoffset, int width, uint32_t format, uint32_t type, void const * data );
		void ( CALLBACK * m_pfnTexSubImage2D )( uint32_t target, int level, int xoffset, int yoffset, int width, int height, uint32_t format, uint32_t type, void const * data );
		void ( CALLBACK * m_pfnTexSubImage3D )( uint32_t target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, uint32_t format, uint32_t type, void const * data );
		void ( CALLBACK * m_pfnTexImage1D )( uint32_t target, int level, int internalFormat, int width, int border, uint32_t format, uint32_t type, void const * data );
		void ( CALLBACK * m_pfnTexImage2D )( uint32_t target, int level, int internalFormat, int width, int height, int border, uint32_t format, uint32_t type, void const * data );
		void ( CALLBACK * m_pfnTexImage3D )( uint32_t target, int level, int internalFormat, int width, int height, int depth, int border, uint32_t format, uint32_t type, void const * data );
#endif
		std::function< void( uint32_t target, int level, uint32_t format, uint32_t type, void * pixels ) > m_pfnGetTexImage;
		std::function< void( uint32_t target, uint32_t pname, int param ) > m_pfnTexParameteri;
		std::function< void( uint32_t target, uint32_t pname, float param ) > m_pfnTexParameterf;
		std::function< void( uint32_t target, uint32_t pname, const int * params ) > m_pfnTexParameteriv;
		std::function< void( uint32_t target, uint32_t pname, const float * param ) > m_pfnTexParameterfv;
		std::function< void( uint32_t target ) > m_pfnGenerateMipmap;
	};

	class TexFunctionsDSA : public TexFunctionsBase
	{
	public:
		TexFunctionsDSA( OpenGl & p_gl );
		virtual bool BindTexture( eGL_TEXDIM /*p_eTarget*/, uint32_t texture )
		{
			m_uiTexture = texture;
			return true;
		}
		virtual bool GenerateMipmap( eGL_TEXDIM p_eTarget );
		virtual bool TexSubImage1D( eGL_TEXDIM p_eTarget, int level, int xoffset, int width, eGL_FORMAT format, eGL_TYPE type, void const * data );
		virtual bool TexSubImage2D( eGL_TEXDIM p_eTarget, int level, int xoffset, int yoffset, int width, int height, eGL_FORMAT format, eGL_TYPE type, void const * data );
		virtual bool TexSubImage2D( eGL_TEXDIM p_eTarget, int level, Castor::Position const & p_position, Castor::Size const & p_size, eGL_FORMAT format, eGL_TYPE type, void const * data );
		virtual bool TexSubImage2D( eGL_TEXDIM p_eTarget, int level, Castor::Rectangle const & p_rect, eGL_FORMAT format, eGL_TYPE type, void const * data );
		virtual bool TexSubImage3D( eGL_TEXDIM p_eTarget, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, eGL_FORMAT format, eGL_TYPE type, void const * data );
		virtual bool TexImage1D( eGL_TEXDIM p_eTarget, int level, eGL_INTERNAL internalFormat, int width, int border, eGL_FORMAT format, uint32_t type, void const * data );
		virtual bool TexImage2D( eGL_TEXDIM p_eTarget, int level, eGL_INTERNAL internalFormat, int width, int height, int border, eGL_FORMAT format, uint32_t type, void const * data );
		virtual bool TexImage2D( eGL_TEXDIM p_eTarget, int level, eGL_INTERNAL internalFormat, Castor::Size const & p_size, int border, eGL_FORMAT format, uint32_t type, void const * data );
		virtual bool TexImage3D( eGL_TEXDIM p_eTarget, int level, eGL_INTERNAL internalFormat, int width, int height, int depth, int border, eGL_FORMAT format, uint32_t type, void const * data );
		virtual bool TexParameter( eGL_TEXDIM p_eTarget, eGL_TEXTURE_PARAMETER pname, int param );
		virtual bool TexParameter( eGL_TEXDIM p_eTarget, eGL_TEXTURE_PARAMETER pname, float param );
		virtual bool TexParameter( eGL_TEXDIM p_eTarget, eGL_TEXTURE_PARAMETER pname, const int * params );
		virtual bool TexParameter( eGL_TEXDIM p_eTarget, eGL_TEXTURE_PARAMETER pname, const float * params );
		virtual bool GetTexImage( eGL_TEXDIM p_eTarget, int level, eGL_FORMAT format, eGL_TYPE type, void * img );

		uint32_t m_uiTexture;
#if CASTOR_HAS_VARIADIC_TEMPLATES
		std::function< void( uint32_t texture, uint32_t target, int level, int xoffset, int width, uint32_t format, uint32_t type, void const * data ) > m_pfnTextureSubImage1D;
		std::function< void( uint32_t texture, uint32_t target, int level, int xoffset, int yoffset, int width, int height, uint32_t format, uint32_t type, void const * data ) > m_pfnTextureSubImage2D;
		std::function< void( uint32_t texture, uint32_t target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, uint32_t format, uint32_t type, void const * data ) > m_pfnTextureSubImage3D;
		std::function< void( uint32_t texture, uint32_t target, int level, int internalFormat, int width, int border, uint32_t format, uint32_t type, void const * data ) > m_pfnTextureImage1D;
		std::function< void( uint32_t texture, uint32_t target, int level, int internalFormat, int width, int height, int border, uint32_t format, uint32_t type, void const * data ) > m_pfnTextureImage2D;
		std::function< void( uint32_t texture, uint32_t target, int level, int internalFormat, int width, int height, int depth, int border, uint32_t format, uint32_t type, void const * data ) > m_pfnTextureImage3D;
		std::function< void( uint32_t texture, uint32_t target, int level, uint32_t format, uint32_t type, void * pixels ) > m_pfnGetTextureImage;
#else
		void ( CALLBACK * m_pfnTextureSubImage1D )( uint32_t texture, uint32_t target, int level, int xoffset, int width, uint32_t format, uint32_t type, void const * data );
		void ( CALLBACK * m_pfnTextureSubImage2D )( uint32_t texture, uint32_t target, int level, int xoffset, int yoffset, int width, int height, uint32_t format, uint32_t type, void const * data );
		void ( CALLBACK * m_pfnTextureSubImage3D )( uint32_t texture, uint32_t target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, uint32_t format, uint32_t type, void const * data );
		void ( CALLBACK * m_pfnTextureImage1D )( uint32_t texture, uint32_t target, int level, int internalFormat, int width, int border, uint32_t format, uint32_t type, void const * data );
		void ( CALLBACK * m_pfnTextureImage2D )( uint32_t texture, uint32_t target, int level, int internalFormat, int width, int height, int border, uint32_t format, uint32_t type, void const * data );
		void ( CALLBACK * m_pfnTextureImage3D )( uint32_t texture, uint32_t target, int level, int internalFormat, int width, int height, int depth, int border, uint32_t format, uint32_t type, void const * data );
		void ( CALLBACK * m_pfnGetTextureImage )( uint32_t texture, uint32_t target, int level, uint32_t format, uint32_t type, void * pixels );
#endif
		std::function< void( uint32_t texture, uint32_t target, uint32_t pname, int param ) > m_pfnTextureParameteri;
		std::function< void( uint32_t texture, uint32_t target, uint32_t pname, float param ) > m_pfnTextureParameterf;
		std::function< void( uint32_t texture, uint32_t target, uint32_t pname, const int * params ) > m_pfnTextureParameteriv;
		std::function< void( uint32_t texture, uint32_t target, uint32_t pname, const float * param ) > m_pfnTextureParameterfv;
		std::function< void( uint32_t texture, uint32_t target ) > m_pfnGenerateTextureMipmap;
	};

	class BufFunctionsBase
	{
	public:
		BufFunctionsBase( OpenGl & p_gl );
		virtual bool EnableClientState( eGL_BUFFER_USAGE p_eArray );
		virtual bool DisableClientState( eGL_BUFFER_USAGE p_eArray );
		virtual bool BindBuffer( eGL_BUFFER_TARGET target, uint32_t buffer ) = 0;
		virtual bool BufferData( eGL_BUFFER_TARGET target, ptrdiff_t size, void const * data, eGL_BUFFER_MODE usage ) = 0;
		virtual bool BufferSubData( eGL_BUFFER_TARGET target, ptrdiff_t offset, ptrdiff_t size, void const * data ) = 0;
		virtual void * MapBuffer( eGL_BUFFER_TARGET target, eGL_LOCK access ) = 0;
		virtual bool UnmapBuffer( eGL_BUFFER_TARGET target ) = 0;
		virtual void * MapBufferRange( eGL_BUFFER_TARGET target, ptrdiff_t offset, ptrdiff_t length, uint32_t access ) = 0;
		virtual bool GetBufferParameter( eGL_BUFFER_TARGET target, eGL_BUFFER_PARAMETER pname, int * params ) = 0;
		virtual bool FlushMappedBufferRange( eGL_BUFFER_TARGET target, ptrdiff_t offset, ptrdiff_t length ) = 0;

		/*@name NV_vertex_buffer_unified_memory extension */
		//@{

		virtual bool BufferAddressRange( eGL_ADDRESS pname, uint32_t index, uint64_t address, size_t length );
		virtual bool VertexFormat( int size, eGL_TYPE type, int stride );
		virtual bool NormalFormat( eGL_TYPE type, int stride );
		virtual bool ColorFormat( int size, eGL_TYPE type, int stride );
		virtual bool IndexFormat( eGL_TYPE type, int stride );
		virtual bool TexCoordFormat( int size, eGL_TYPE type, int stride );
		virtual bool EdgeFlagFormat( int stride );
		virtual bool SecondaryColorFormat( int size, eGL_TYPE type, int stride );
		virtual bool FogCoordFormat( uint32_t type, int stride );
		virtual bool VertexAttribFormat( uint32_t index, int size, eGL_TYPE type, bool normalized, int stride );
		virtual bool VertexAttribIFormat( uint32_t index, int size, eGL_TYPE type, int stride );

		//@}
		/*@name NV_shader_buffer_load extension */
		//@{

		virtual bool MakeBufferResident( eGL_BUFFER_TARGET target, eGL_RESIDENT_BUFFER_ACCESS access );
		virtual bool MakeBufferNonResident( eGL_BUFFER_TARGET target );
		virtual bool IsBufferResident( eGL_BUFFER_TARGET target );
		virtual bool MakeNamedBufferResident( uint32_t buffer, eGL_RESIDENT_BUFFER_ACCESS access );
		virtual bool MakeNamedBufferNonResident( uint32_t buffer );
		virtual bool IsNamedBufferResident( uint32_t buffer );
		virtual bool GetBufferParameter( eGL_BUFFER_TARGET target, eGL_BUFFER_PARAMETER pname, uint64_t * params );
		virtual bool GetNamedBufferParameter( uint32_t buffer, eGL_BUFFER_PARAMETER pname,  uint64_t * params );

		//@}

		std::function< void( uint32_t array ) > m_pfnEnableClientState;
		std::function< void( uint32_t array ) > m_pfnDisableClientState;

		/*@name NV_vertex_buffer_unified_memory extension */
		//@{

		std::function< void( uint32_t pname, uint32_t index, uint64_t address, size_t length ) > m_pfnBufferAddressRange;
		std::function< void( int size, uint32_t type, int stride ) > m_pfnVertexFormat;
		std::function< void( uint32_t type, int stride ) > m_pfnNormalFormat;
		std::function< void( int size, uint32_t type, int stride ) > m_pfnColorFormat;
		std::function< void( uint32_t type, int stride ) > m_pfnIndexFormat;
		std::function< void( int size, uint32_t type, int stride ) > m_pfnTexCoordFormat;
		std::function< void( int stride ) > m_pfnEdgeFlagFormat;
		std::function< void( int size, uint32_t type, int stride ) > m_pfnSecondaryColorFormat;
		std::function< void( uint32_t type, int stride ) > m_pfnFogCoordFormat;
		std::function< void( uint32_t index, int size, uint32_t type, bool normalized, int stride ) > m_pfnVertexAttribFormat;
		std::function< void( uint32_t index, int size, uint32_t type, int stride ) > m_pfnVertexAttribIFormat;

		//@}
		/*@name NV_vertex_buffer_unified_memory extension */
		//@{

		std::function< void( uint32_t target, uint32_t access ) > m_pfnMakeBufferResident;
		std::function< void( uint32_t target ) > m_pfnMakeBufferNonResident;
		std::function< bool( uint32_t target ) > m_pfnIsBufferResident;
		std::function< void( uint32_t buffer, uint32_t access ) > m_pfnMakeNamedBufferResident;
		std::function< void( uint32_t buffer ) > m_pfnMakeNamedBufferNonResident;
		std::function< bool( uint32_t buffer ) > m_pfnIsNamedBufferResident;
		std::function< void( uint32_t target, uint32_t pname, uint64_t * params ) > m_pfnGetBufferParameterui64v;
		std::function< void( uint32_t buffer, uint32_t pname,  uint64_t * params ) > m_pfnGetNamedBufferParameterui64v;

	protected:
		OpenGl & m_gl;

		//@}
	};

	class BufFunctions : public BufFunctionsBase
	{
	public:
		BufFunctions( OpenGl & p_gl );
		virtual bool BindBuffer( eGL_BUFFER_TARGET target, uint32_t buffer );
		virtual bool BufferData( eGL_BUFFER_TARGET target, ptrdiff_t size, void const * data, eGL_BUFFER_MODE usage );
		virtual bool BufferSubData( eGL_BUFFER_TARGET target, ptrdiff_t offset, ptrdiff_t size, void const * data );
		virtual void * MapBuffer( eGL_BUFFER_TARGET target, eGL_LOCK access );
		virtual bool UnmapBuffer( eGL_BUFFER_TARGET target );
		virtual void * MapBufferRange( eGL_BUFFER_TARGET target, ptrdiff_t offset, ptrdiff_t length, uint32_t access );
		virtual bool GetBufferParameter( eGL_BUFFER_TARGET target, eGL_BUFFER_PARAMETER pname, int * params );
		virtual bool FlushMappedBufferRange( eGL_BUFFER_TARGET target, ptrdiff_t offset, ptrdiff_t length );

		std::function< void( uint32_t target, uint32_t buffer ) > m_pfnBindBuffer;
		std::function< void( uint32_t target, ptrdiff_t size, void const * data, uint32_t usage ) > m_pfnBufferData;
		std::function< void( uint32_t target, ptrdiff_t offset, ptrdiff_t size, void const * data ) > m_pfnBufferSubData;
		std::function< void * ( uint32_t target, uint32_t access ) > m_pfnMapBuffer;
		std::function< uint8_t( uint32_t target ) > m_pfnUnmapBuffer;
		std::function< void * ( uint32_t target, ptrdiff_t offset, ptrdiff_t length, uint32_t access ) > m_pfnMapBufferRange;
		std::function< void( uint32_t target, ptrdiff_t offset, ptrdiff_t length ) > m_pfnFlushMappedBufferRange;
		std::function< void( uint32_t target, uint32_t pname, int * params ) > m_pfnGetBufferParameteriv;
	};

	class BufFunctionsDSA : public BufFunctionsBase
	{
	public:
		BufFunctionsDSA( OpenGl & p_gl );
		virtual bool	BindBuffer( eGL_BUFFER_TARGET /*target*/, uint32_t buffer )
		{
			m_uiBuffer = buffer;
			return true;
		}
		virtual bool BufferData( eGL_BUFFER_TARGET target, ptrdiff_t size, void const * data, eGL_BUFFER_MODE usage );
		virtual bool BufferSubData( eGL_BUFFER_TARGET target, ptrdiff_t offset, ptrdiff_t size, void const * data );
		virtual void * MapBuffer( eGL_BUFFER_TARGET target, eGL_LOCK access );
		virtual bool UnmapBuffer( eGL_BUFFER_TARGET target );
		virtual void * MapBufferRange( eGL_BUFFER_TARGET target, ptrdiff_t offset, ptrdiff_t length, uint32_t access );
		virtual bool GetBufferParameter( eGL_BUFFER_TARGET target, eGL_BUFFER_PARAMETER pname, int * params );
		virtual bool FlushMappedBufferRange( eGL_BUFFER_TARGET target, ptrdiff_t offset, ptrdiff_t length );

		uint32_t m_uiBuffer;
		std::function< void( uint32_t buffer, ptrdiff_t size, void const * data, uint32_t usage ) > m_pfnNamedBufferData;
		std::function< void( uint32_t buffer, ptrdiff_t offset, ptrdiff_t size, void const * data ) > m_pfnNamedBufferSubData;
		std::function< void * ( uint32_t buffer, uint32_t access ) > m_pfnMapNamedBuffer;
		std::function< uint8_t ( uint32_t buffer ) > m_pfnUnmapNamedBuffer;
		std::function< void * ( uint32_t buffer, ptrdiff_t offset, ptrdiff_t length, uint32_t access ) > m_pfnMapNamedBufferRange;
		std::function< void( uint32_t buffer, ptrdiff_t offset, ptrdiff_t length ) > m_pfnFlushMappedNamedBufferRange;
		std::function< void( uint32_t buffer, uint32_t pname, int * params ) > m_pfnGetNamedBufferParameteriv;
	};

	class OpenGl
		: public Castor::NonCopyable
	{
	public:
		struct PixelFmt
		{
			eGL_FORMAT Format;
			eGL_INTERNAL Internal;
			eGL_TYPE Type;

			PixelFmt() {}

			PixelFmt( eGL_FORMAT p_eFormat, eGL_INTERNAL p_eInternal, eGL_TYPE p_type )
				: Format( p_eFormat )
				, Internal( p_eInternal )
				, Type( p_type )
			{
			}
		};

		typedef void ( CALLBACK * PFNGLDEBUGPROC )( uint32_t source, uint32_t type, uint32_t id, uint32_t severity, int length, const char * message, void * userParam );
		typedef void ( CALLBACK * PFNGLDEBUGAMDPROC )( uint32_t id, uint32_t category, uint32_t severity, int length, const char * message, void * userParam );

	public:
		C3D_Gl_API OpenGl( GlRenderSystem & p_renderSystem );
		C3D_Gl_API ~OpenGl();

		C3D_Gl_API bool PreInitialise( Castor::String const & p_strExtensions );
		C3D_Gl_API bool Initialise();
		C3D_Gl_API void Cleanup();
		C3D_Gl_API bool HasMultiTexturing()const;

		inline bool HasVao()const
		{
			return m_bHasVao;
		}
		inline bool HasUbo()const
		{
			return m_bHasUbo;
		}
		inline bool HasPbo()const
		{
			return m_bHasPbo;
		}
		inline bool HasTbo()const
		{
			return m_bHasTbo;
		}
		inline bool HasFbo()const
		{
			return m_bHasFbo;
		}
		inline bool HasVSh()const
		{
			return m_bHasVSh;
		}
		inline bool HasPSh()const
		{
			return m_bHasPSh;
		}
		inline bool HasGSh()const
		{
			return m_bHasGSh;
		}
		inline bool HasTSh()const
		{
			return m_bHasTSh;
		}
		inline bool HasCSh()const
		{
			return m_bHasCSh;
		}
		inline bool HasSpl()const
		{
			return m_bHasSpl;
		}
		inline bool HasVbo()const
		{
			return m_bHasVbo;
		}
		inline bool HasDepthClipping()const
		{
			return m_bHasDepthClipping;
		}
		inline bool HasInstancing()const
		{
			return m_bHasInstancedDraw && m_bHasInstancedArrays;
		}
		inline bool HasNonPowerOfTwoTextures()const
		{
			return m_bHasNonPowerOfTwoTextures;
		}
		inline bool CanBindVboToGpuAddress()const
		{
			return m_bBindVboToGpuAddress;
		}

		/**@name General Functions */
		//@{

		C3D_Gl_API uint32_t GetError()const;
		C3D_Gl_API bool ClearColor( float red, float green, float blue, float alpha );
		C3D_Gl_API bool ClearColor( Castor::Colour const & p_colour );
		C3D_Gl_API bool ShadeModel( eGL_SHADE_MODEL mode );
		C3D_Gl_API bool Clear( uint32_t mask );
		C3D_Gl_API bool Enable( eGL_TWEAK mode );
		C3D_Gl_API bool Disable( eGL_TWEAK mode );
		C3D_Gl_API bool Enable( eGL_LIGHT_INDEX light );
		C3D_Gl_API bool Disable( eGL_LIGHT_INDEX light );
		C3D_Gl_API bool Enable( eGL_TEXDIM texture );
		C3D_Gl_API bool Disable( eGL_TEXDIM texture );
		C3D_Gl_API bool SelectBuffer( int size, uint32_t * buffer );
		C3D_Gl_API bool GetIntegerv( uint32_t pname, int * params );
		C3D_Gl_API bool GetIntegerv( uint32_t pname, uint64_t * params );
		C3D_Gl_API int RenderMode( eGL_RENDER_MODE mode );
		C3D_Gl_API bool DepthFunc( eGL_FUNC p_eFunc );
		C3D_Gl_API bool DepthMask( bool p_bFlag );
		C3D_Gl_API bool ColorMask( bool p_r, bool p_g, bool p_b, bool p_a );
		C3D_Gl_API bool DebugMessageCallback( PFNGLDEBUGPROC pfnProc, void * p_pThis );
		C3D_Gl_API bool DebugMessageCallback( PFNGLDEBUGAMDPROC pfnProc, void * p_pThis );
		C3D_Gl_API bool PolygonMode( eGL_FACE p_eFacing, eGL_FILL_MODE p_mode );
		C3D_Gl_API bool StencilOp( eGL_STENCIL_OP p_eStencilFail, eGL_STENCIL_OP p_eDepthFail, eGL_STENCIL_OP p_eStencilPass );
		C3D_Gl_API bool StencilFunc( eGL_FUNC p_eFunc, int p_iRef, uint32_t p_uiMask );
		C3D_Gl_API bool StencilMask( uint32_t p_uiMask );
		C3D_Gl_API bool StencilOpSeparate( eGL_FACE p_eFacing, eGL_STENCIL_OP p_eStencilFail, eGL_STENCIL_OP p_eDepthFail, eGL_STENCIL_OP p_eStencilPass );
		C3D_Gl_API bool StencilFuncSeparate( eGL_FACE p_eFacing, eGL_FUNC p_eFunc, int p_iRef, uint32_t p_uiMask );
		C3D_Gl_API bool StencilMaskSeparate( eGL_FACE p_eFacing, uint32_t p_uiMask );
		C3D_Gl_API bool Hint( eGL_HINT p_eHint, eGL_HINT_VALUE p_eValue );
		C3D_Gl_API bool PolygonOffset( float p_fFactor, float p_fUnits );
		C3D_Gl_API bool BlendColor( Castor::Colour const & p_clrFactors );
		C3D_Gl_API bool SampleCoverage( float fValue, bool invert );

		//@}
		/**@name Draw Functions */
		//@{

		C3D_Gl_API bool DrawArrays( eGL_PRIMITIVE mode, int first, int count );
		C3D_Gl_API bool DrawElements( eGL_PRIMITIVE mode, int count, eGL_TYPE type, const void * indices );
		C3D_Gl_API bool DrawArraysInstanced( eGL_PRIMITIVE mode, int first, int count, int primcount );
		C3D_Gl_API bool DrawElementsInstanced( eGL_PRIMITIVE mode, int count, eGL_TYPE type, const void * indices, int primcount );

		//@}
		/**@name Instanciation Functions */
		//@{

		C3D_Gl_API bool VertexAttribDivisor( uint32_t index, uint32_t divisor );

		//@}
		/**@name Light Functions */
		//@{

		C3D_Gl_API bool Light( eGL_LIGHT_INDEX light, uint32_t pname, float param );
		C3D_Gl_API bool Light( eGL_LIGHT_INDEX light, uint32_t pname, float const * param );
		C3D_Gl_API bool LightModel( uint32_t pname, int param );
		C3D_Gl_API bool LightModel( uint32_t pname, int const * param );
		C3D_Gl_API bool LightModel( uint32_t pname, float param );
		C3D_Gl_API bool LightModel( uint32_t pname, float const * param );

		//@}
		/**@name Context functions */
		//@{

#if defined( _WIN32 )
		C3D_Gl_API bool MakeCurrent( HDC hdc, HGLRC hglrc );
		C3D_Gl_API bool SwapBuffers( HDC hdc );
		C3D_Gl_API bool SwapInterval( int interval );
		C3D_Gl_API HGLRC CreateContext( HDC hdc );
		C3D_Gl_API HGLRC CreateContextAttribs( HDC hDC, HGLRC hShareContext, int const * attribList );
		C3D_Gl_API bool DeleteContext( HGLRC hContext );
		C3D_Gl_API bool HasCreateContextAttribs();
#elif defined( __linux__ )
		C3D_Gl_API bool MakeCurrent( Display * pDisplay, GLXDrawable drawable, GLXContext context );
		C3D_Gl_API bool SwapBuffers( Display * pDisplay, GLXDrawable drawable );
		C3D_Gl_API bool SwapInterval( Display * pDisplay, GLXDrawable drawable, int interval );
		C3D_Gl_API GLXContext CreateContext( Display * pDisplay, XVisualInfo * pVisualInfo, GLXContext shareList, Bool direct );
		C3D_Gl_API GLXContext CreateContextAttribs( Display * pDisplay, GLXFBConfig fbconfig, GLXContext shareList, Bool direct, int const * attribList );
		C3D_Gl_API bool DeleteContext( Display * pDisplay, GLXContext context );
		C3D_Gl_API bool HasCreateContextAttribs();
#else
#	error "Yet unsupported OS"
#endif

		//@}
		/**@name Matrix functions */
		//@{

		C3D_Gl_API bool Viewport( int x, int y, int width, int height );
		C3D_Gl_API bool MatrixMode( eGL_MATRIX_TYPE mode );
		C3D_Gl_API bool LoadIdentity( );
		C3D_Gl_API bool Ortho( double left, double right, double bottom, double top, double zNear, double zFar );
		C3D_Gl_API bool Frustum( double left, double right, double bottom, double top, double zNear, double zFar );
		C3D_Gl_API bool PushMatrix( );
		C3D_Gl_API bool PopMatrix( );
		C3D_Gl_API bool Translate( real x, real y, real z );
		C3D_Gl_API bool Rotate( real angle, real x, real y, real z );
		C3D_Gl_API bool Scale( real x, real y, real z );
		C3D_Gl_API bool MultMatrix( real const * matrix );

		//@}
		/**@name Material functions */
		//@{

		C3D_Gl_API bool CullFace( eGL_FACE face );
		C3D_Gl_API bool FrontFace( eGL_FRONT_FACE_DIRECTION face );
		C3D_Gl_API bool Material( eGL_DRAW_BUFFER_MODE face, eGL_MATERIAL_COMPONENT pname, float param );
		C3D_Gl_API bool Material( eGL_DRAW_BUFFER_MODE face, eGL_MATERIAL_COMPONENT pname, float const * param );
		C3D_Gl_API bool BlendFunc( eGL_BLEND_FACTOR sfactor, eGL_BLEND_FACTOR dfactor );
		C3D_Gl_API bool BlendFunc( eGL_BLEND_FACTOR p_eRgbSrc, eGL_BLEND_FACTOR p_eRgbDst, eGL_BLEND_FACTOR p_eAlphaSrc, eGL_BLEND_FACTOR p_eAlphaDst );
		C3D_Gl_API bool BlendFunc( uint32_t p_index, eGL_BLEND_FACTOR p_eRgbSrc, eGL_BLEND_FACTOR p_eRgbDst, eGL_BLEND_FACTOR p_eAlphaSrc, eGL_BLEND_FACTOR p_eAlphaDst );
		C3D_Gl_API bool BlendEquation( eGL_BLEND_OP p_eOp );
		C3D_Gl_API bool BlendEquation( uint32_t p_uiBuffer, eGL_BLEND_OP p_eOp );
		C3D_Gl_API bool AlphaFunc( eGL_FUNC func, float ref );

		//@}
		/**@name Texture functions */
		//@{

		C3D_Gl_API bool GenTextures( int n, uint32_t * textures );
		C3D_Gl_API bool DeleteTextures( int n, uint32_t const * textures );
		C3D_Gl_API bool ActiveTexture( eGL_TEXTURE_INDEX target );
		C3D_Gl_API bool ClientActiveTexture( eGL_TEXTURE_INDEX target );
		C3D_Gl_API bool BindTexture( eGL_TEXDIM p_eTarget, uint32_t texture );
		C3D_Gl_API bool EnableClientState( eGL_BUFFER_USAGE p_eArray );
		C3D_Gl_API bool DisableClientState( eGL_BUFFER_USAGE p_eArray );
		C3D_Gl_API bool GenerateMipmap( eGL_TEXDIM p_eTarget );
		C3D_Gl_API bool TexSubImage1D( eGL_TEXDIM p_eTarget, int level, int xoffset, int width, eGL_FORMAT format, eGL_TYPE type, void const * data );
		C3D_Gl_API bool TexSubImage2D( eGL_TEXDIM p_eTarget, int level, int xoffset, int yoffset, int width, int height, eGL_FORMAT format, eGL_TYPE type, void const * data );
		C3D_Gl_API bool TexSubImage2D( eGL_TEXDIM p_eTarget, int level, Castor::Position const & p_position, Castor::Size const & p_size, eGL_FORMAT format, eGL_TYPE type, void const * data );
		C3D_Gl_API bool TexSubImage2D( eGL_TEXDIM p_eTarget, int level, Castor::Rectangle const & p_rect, eGL_FORMAT format, eGL_TYPE type, void const * data );
		C3D_Gl_API bool TexSubImage3D( eGL_TEXDIM p_eTarget, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, eGL_FORMAT format, eGL_TYPE type, void const * data );
		C3D_Gl_API bool TexImage1D( eGL_TEXDIM p_eTarget, int level, eGL_INTERNAL internalFormat, int width, int border, eGL_FORMAT format, uint32_t type, void const * data );
		C3D_Gl_API bool TexImage2D( eGL_TEXDIM p_eTarget, int level, eGL_INTERNAL internalFormat, int width, int height, int border, eGL_FORMAT format, uint32_t type, void const * data );
		C3D_Gl_API bool TexImage2D( eGL_TEXDIM p_eTarget, int level, eGL_INTERNAL internalFormat, Castor::Size const & p_size, int border, eGL_FORMAT format, uint32_t type, void const * data );
		C3D_Gl_API bool TexImage3D( eGL_TEXDIM p_eTarget, int level, eGL_INTERNAL internalFormat, int width, int height, int depth, int border, eGL_FORMAT format, uint32_t type, void const * data );
		C3D_Gl_API bool TexImage2DMultisample( eGL_TEXDIM p_eTarget, int p_iSamples, eGL_INTERNAL p_eInternalFormat, int p_iWidth, int p_iHeight, bool p_bFixedSampleLocations );
		C3D_Gl_API bool TexImage2DMultisample( eGL_TEXDIM p_eTarget, int p_iSamples, eGL_INTERNAL p_eInternalFormat, Castor::Size const & p_size, bool p_bFixedSampleLocations );
		C3D_Gl_API bool TexParameter( eGL_TEXDIM p_eTarget, eGL_TEXTURE_PARAMETER pname, int param );
		C3D_Gl_API bool TexParameter( eGL_TEXDIM p_eTarget, eGL_TEXTURE_PARAMETER pname, float param );
		C3D_Gl_API bool TexParameter( eGL_TEXDIM p_eTarget, eGL_TEXTURE_PARAMETER pname, const int * params );
		C3D_Gl_API bool TexParameter( eGL_TEXDIM p_eTarget, eGL_TEXTURE_PARAMETER pname, const float * params );
		C3D_Gl_API bool GetTexImage( eGL_TEXDIM p_eTarget, int level, eGL_FORMAT format, eGL_TYPE type, void * img );
		C3D_Gl_API bool TexEnvi( eGL_TEXENV_TARGET target, eGL_TEXENV_ARGNAME pname, int param );
		C3D_Gl_API bool TexEnviv( eGL_TEXENV_TARGET target, eGL_TEXENV_ARGNAME pname, int const * param );
		C3D_Gl_API bool TexEnvf( eGL_TEXENV_TARGET target, eGL_TEXENV_ARGNAME pname, float param );
		C3D_Gl_API bool TexEnvfv( eGL_TEXENV_TARGET target, eGL_TEXENV_ARGNAME pname, float const * param );
		C3D_Gl_API bool IsTexture( uint32_t texture );
		C3D_Gl_API bool TexGeni( eGL_TEXGEN_COORD coord, eGL_TEXGEN_PARAM param, eGL_TEXGEN_MODE mode );
		C3D_Gl_API bool ReadBuffer( eGL_BUFFER p_eBuffer );
		C3D_Gl_API bool ReadPixels( int x, int y, int width, int height, eGL_FORMAT format, eGL_TYPE type, void * pixels );
		C3D_Gl_API bool ReadPixels( Castor::Position const & p_position, Castor::Size const & p_size, eGL_FORMAT format, eGL_TYPE type, void * pixels );
		C3D_Gl_API bool ReadPixels( Castor::Rectangle const & p_rect, eGL_FORMAT format, eGL_TYPE type, void * pixels );
		C3D_Gl_API bool DrawBuffer( eGL_BUFFER p_eBuffer );
		C3D_Gl_API bool DrawPixels( int width, int height, eGL_FORMAT format, eGL_TYPE type, void const * data );
		C3D_Gl_API bool PixelStore( eGL_STORAGE_MODE p_mode, int p_iParam );
		C3D_Gl_API bool PixelStore( eGL_STORAGE_MODE p_mode, float p_fParam );

		//@}
		/**@name Sampler functions */
		//@{

		C3D_Gl_API bool BindSampler( uint32_t unit, uint32_t sampler );
		C3D_Gl_API bool DeleteSamplers( int count, const uint32_t * samplers );
		C3D_Gl_API bool GenSamplers( int count, uint32_t * samplers );
		C3D_Gl_API bool GetSamplerParameter( uint32_t sampler, eGL_SAMPLER_PARAMETER pname, uint32_t * params );
		C3D_Gl_API bool GetSamplerParameter( uint32_t sampler, eGL_SAMPLER_PARAMETER pname, float * params );
		C3D_Gl_API bool GetSamplerParameter( uint32_t sampler, eGL_SAMPLER_PARAMETER pname, int * params );
		C3D_Gl_API bool IsSampler( uint32_t sampler );
		C3D_Gl_API bool SetSamplerParameter( uint32_t sampler, eGL_SAMPLER_PARAMETER pname, float param );
		C3D_Gl_API bool SetSamplerParameter( uint32_t sampler, eGL_SAMPLER_PARAMETER pname, const float * params );
		C3D_Gl_API bool SetSamplerParameter( uint32_t sampler, eGL_SAMPLER_PARAMETER pname, int param );
		C3D_Gl_API bool SetSamplerParameter( uint32_t sampler, eGL_SAMPLER_PARAMETER pname, const int * params );
		C3D_Gl_API bool SetSamplerParameter( uint32_t sampler, eGL_SAMPLER_PARAMETER pname, const uint32_t * params );

		//@}
		/**@name Texture Buffer objects functions */
		//@{

		C3D_Gl_API bool TexBuffer( eGL_TEXDIM p_eTarget, eGL_INTERNAL_FORMAT p_eInternalFormat, uint32_t buffer );

		//@}
		/**@name Buffer objects functions */
		//@{

		C3D_Gl_API bool GenBuffers( int n, uint32_t * buffers );
		C3D_Gl_API bool DeleteBuffers( int n, uint32_t const * buffers );
		C3D_Gl_API bool IsBuffer( uint32_t buffer );
		C3D_Gl_API bool BindBuffer( eGL_BUFFER_TARGET target, uint32_t buffer );
		C3D_Gl_API bool BufferData( eGL_BUFFER_TARGET target, ptrdiff_t size, void const * data, eGL_BUFFER_MODE usage );
		C3D_Gl_API bool BufferSubData( eGL_BUFFER_TARGET target, ptrdiff_t offset, ptrdiff_t size, void const * data );
		C3D_Gl_API void * MapBuffer( eGL_BUFFER_TARGET target, eGL_LOCK access );
		C3D_Gl_API bool UnmapBuffer( eGL_BUFFER_TARGET target );
		C3D_Gl_API void * MapBufferRange( eGL_BUFFER_TARGET target, ptrdiff_t offset, ptrdiff_t length, uint32_t access );
		C3D_Gl_API bool GetBufferParameter( eGL_BUFFER_TARGET target, eGL_BUFFER_PARAMETER pname, int * params );
		C3D_Gl_API bool GetBufferParameter( eGL_BUFFER_TARGET target, eGL_BUFFER_PARAMETER pname, uint64_t * params );
		C3D_Gl_API bool FlushMappedBufferRange( eGL_BUFFER_TARGET target, ptrdiff_t offset, ptrdiff_t length );
		C3D_Gl_API bool VertexPointer( int size, uint32_t type, uint32_t stride, void const * pointer );
		C3D_Gl_API bool NormalPointer( uint32_t type, uint32_t stride, void const * pointer );
		C3D_Gl_API bool TangentPointer( uint32_t type, uint32_t stride, void const * pointer );
		C3D_Gl_API bool BinormalPointer( uint32_t type, uint32_t stride, void const * pointer );
		C3D_Gl_API bool HasTangentPointer();
		C3D_Gl_API bool HasBinormalPointer();
		C3D_Gl_API bool ColorPointer( int size, uint32_t type, uint32_t stride, void const * pointer );
		C3D_Gl_API bool TexCoordPointer( int size, uint32_t type, uint32_t stride, void const * pointer );
		C3D_Gl_API bool BufferAddressRange( eGL_ADDRESS pname, uint32_t index, uint64_t address, size_t length );
		C3D_Gl_API bool VertexFormat( int size, eGL_TYPE type, int stride );
		C3D_Gl_API bool NormalFormat( eGL_TYPE type, int stride );
		C3D_Gl_API bool ColorFormat( int size, eGL_TYPE type, int stride );
		C3D_Gl_API bool IndexFormat( eGL_TYPE type, int stride );
		C3D_Gl_API bool TexCoordFormat( int size, eGL_TYPE type, int stride );
		C3D_Gl_API bool EdgeFlagFormat( int stride );
		C3D_Gl_API bool SecondaryColorFormat( int size, eGL_TYPE type, int stride );
		C3D_Gl_API bool FogCoordFormat( uint32_t type, int stride );
		C3D_Gl_API bool VertexAttribFormat( uint32_t index, int size, eGL_TYPE type, bool normalized, int stride );
		C3D_Gl_API bool VertexAttribIFormat( uint32_t index, int size, eGL_TYPE type, int stride );
		C3D_Gl_API bool MakeBufferResident( eGL_BUFFER_TARGET target, eGL_RESIDENT_BUFFER_ACCESS access );
		C3D_Gl_API bool MakeBufferNonResident( eGL_BUFFER_TARGET target );
		C3D_Gl_API bool IsBufferResident( eGL_BUFFER_TARGET target );
		C3D_Gl_API bool MakeNamedBufferResident( uint32_t buffer, eGL_RESIDENT_BUFFER_ACCESS access );
		C3D_Gl_API bool MakeNamedBufferNonResident( uint32_t buffer );
		C3D_Gl_API bool IsNamedBufferResident( uint32_t buffer );
		C3D_Gl_API bool GetNamedBufferParameter( uint32_t buffer, eGL_BUFFER_PARAMETER pname, uint64_t * params );

		//@}
		/**@name FBO functions */
		//@{

		C3D_Gl_API bool GenFramebuffers( int n, uint32_t * framebuffers );
		C3D_Gl_API bool DeleteFramebuffers( int n, uint32_t const * framebuffers );
		C3D_Gl_API bool BindFramebuffer( eGL_FRAMEBUFFER_MODE p_eBindingMode, uint32_t framebuffer );
		C3D_Gl_API bool FramebufferTexture( eGL_FRAMEBUFFER_MODE p_eBindingMode, eGL_TEXTURE_ATTACHMENT p_eAttachment, uint32_t texture, int level );
		C3D_Gl_API bool FramebufferTexture1D( eGL_FRAMEBUFFER_MODE p_eBindingMode, eGL_TEXTURE_ATTACHMENT p_eAttachment, eGL_TEXDIM textarget, uint32_t texture, int level );
		C3D_Gl_API bool FramebufferTexture2D( eGL_FRAMEBUFFER_MODE p_eBindingMode, eGL_TEXTURE_ATTACHMENT p_eAttachment, eGL_TEXDIM textarget, uint32_t texture, int level );
		C3D_Gl_API bool FramebufferTexture3D( eGL_FRAMEBUFFER_MODE p_eBindingMode, eGL_TEXTURE_ATTACHMENT p_eAttachment, eGL_TEXDIM textarget, uint32_t texture, int level, int layer );
		C3D_Gl_API bool FramebufferTextureLayer( eGL_FRAMEBUFFER_MODE p_eBindingMode, eGL_TEXTURE_ATTACHMENT p_eAttachment, uint32_t texture, int level, int layer );
		C3D_Gl_API bool FramebufferRenderbuffer( eGL_FRAMEBUFFER_MODE p_eBindingMode, eGL_RENDERBUFFER_ATTACHMENT p_eAttachment, eGL_RENDERBUFFER_MODE p_eRboTarget, uint32_t renderbufferId );
		C3D_Gl_API uint32_t CheckFramebufferStatus( eGL_FRAMEBUFFER_MODE p_eBindingMode );
		C3D_Gl_API bool GenRenderbuffers( int n, uint32_t * ids );
		C3D_Gl_API bool DeleteRenderbuffers( int n, uint32_t const * ids );
		C3D_Gl_API bool BindRenderbuffer( eGL_RENDERBUFFER_MODE p_eBindingMode, uint32_t id );
		C3D_Gl_API bool RenderbufferStorage( eGL_RENDERBUFFER_MODE p_eBindingMode, eGL_RENDERBUFFER_STORAGE internalFormat, int width, int height );
		C3D_Gl_API bool RenderbufferStorageMultisample( eGL_RENDERBUFFER_MODE p_eBindingMode, int p_iSamples, eGL_RENDERBUFFER_STORAGE internalFormat, int width, int height );
		C3D_Gl_API bool RenderbufferStorage( eGL_RENDERBUFFER_MODE p_eBindingMode, eGL_RENDERBUFFER_STORAGE internalFormat, Castor::Size const & size );
		C3D_Gl_API bool RenderbufferStorageMultisample( eGL_RENDERBUFFER_MODE p_eBindingMode, int p_iSamples, eGL_RENDERBUFFER_STORAGE internalFormat, Castor::Size const & size );
		C3D_Gl_API bool GetRenderbufferParameteriv( eGL_RENDERBUFFER_MODE p_eBindingMode, eGL_RENDERBUFFER_PARAMETER param, int * value );
		C3D_Gl_API bool BlitFramebuffer( int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, uint32_t mask, uint32_t filter );
		C3D_Gl_API bool BlitFramebuffer( Castor::Rectangle const & rcSrc, Castor::Rectangle const & rcDst, uint32_t mask, uint32_t filter );
		C3D_Gl_API bool DrawBuffers( int n, const uint32_t * bufs );

		//@}
		/**@name Uniform variable Functions */
		//@{

		C3D_Gl_API int GetUniformLocation( uint32_t program, char const * name );
		C3D_Gl_API bool SetUniform( int location, int v0 );
		C3D_Gl_API bool SetUniform( int location, uint32_t v0 );
		C3D_Gl_API bool SetUniform( int location, float v0 );
		C3D_Gl_API bool SetUniform( int location, double v0 );
		C3D_Gl_API bool SetUniform( int location, int v0, int v1 );
		C3D_Gl_API bool SetUniform( int location, int v0, int v1, int v2 );
		C3D_Gl_API bool SetUniform( int location, int v0, int v1, int v2, int v3 );
		C3D_Gl_API bool SetUniform( int location, uint32_t v0, uint32_t v1 );
		C3D_Gl_API bool SetUniform( int location, uint32_t v0, uint32_t v1, uint32_t v2 );
		C3D_Gl_API bool SetUniform( int location, uint32_t v0, uint32_t v1, uint32_t v2, uint32_t v3 );
		C3D_Gl_API bool SetUniform( int location, float v0, float v1 );
		C3D_Gl_API bool SetUniform( int location, float v0, float v1, float v2 );
		C3D_Gl_API bool SetUniform( int location, float v0, float v1, float v2, float v3 );
		C3D_Gl_API bool SetUniform( int location, double v0, double v1 );
		C3D_Gl_API bool SetUniform( int location, double v0, double v1, double v2 );
		C3D_Gl_API bool SetUniform( int location, double v0, double v1, double v2, double v3 );
		C3D_Gl_API bool SetUniform1v( int location, int count, int const * params );
		C3D_Gl_API bool SetUniform2v( int location, int count, int const * params );
		C3D_Gl_API bool SetUniform3v( int location, int count, int const * params );
		C3D_Gl_API bool SetUniform4v( int location, int count, int const * params );
		C3D_Gl_API bool SetUniform1v( int location, int count, uint32_t const * params );
		C3D_Gl_API bool SetUniform2v( int location, int count, uint32_t const * params );
		C3D_Gl_API bool SetUniform3v( int location, int count, uint32_t const * params );
		C3D_Gl_API bool SetUniform4v( int location, int count, uint32_t const * params );
		C3D_Gl_API bool SetUniform1v( int location, int count, float const * params );
		C3D_Gl_API bool SetUniform2v( int location, int count, float const * params );
		C3D_Gl_API bool SetUniform3v( int location, int count, float const * params );
		C3D_Gl_API bool SetUniform4v( int location, int count, float const * params );
		C3D_Gl_API bool SetUniform1v( int location, int count, double const * params );
		C3D_Gl_API bool SetUniform2v( int location, int count, double const * params );
		C3D_Gl_API bool SetUniform3v( int location, int count, double const * params );
		C3D_Gl_API bool SetUniform4v( int location, int count, double const * params );
		C3D_Gl_API bool SetUniformMatrix2x2v( int location, int count, bool transpose, float const * value );
		C3D_Gl_API bool SetUniformMatrix2x3v( int location, int count, bool transpose, float const * value );
		C3D_Gl_API bool SetUniformMatrix2x4v( int location, int count, bool transpose, float const * value );
		C3D_Gl_API bool SetUniformMatrix3x3v( int location, int count, bool transpose, float const * value );
		C3D_Gl_API bool SetUniformMatrix3x2v( int location, int count, bool transpose, float const * value );
		C3D_Gl_API bool SetUniformMatrix3x4v( int location, int count, bool transpose, float const * value );
		C3D_Gl_API bool SetUniformMatrix4x4v( int location, int count, bool transpose, float const * value );
		C3D_Gl_API bool SetUniformMatrix4x2v( int location, int count, bool transpose, float const * value );
		C3D_Gl_API bool SetUniformMatrix4x3v( int location, int count, bool transpose, float const * value );
		C3D_Gl_API bool SetUniformMatrix2x2v( int location, int count, bool transpose, double const * value );
		C3D_Gl_API bool SetUniformMatrix2x3v( int location, int count, bool transpose, double const * value );
		C3D_Gl_API bool SetUniformMatrix2x4v( int location, int count, bool transpose, double const * value );
		C3D_Gl_API bool SetUniformMatrix3x3v( int location, int count, bool transpose, double const * value );
		C3D_Gl_API bool SetUniformMatrix3x2v( int location, int count, bool transpose, double const * value );
		C3D_Gl_API bool SetUniformMatrix3x4v( int location, int count, bool transpose, double const * value );
		C3D_Gl_API bool SetUniformMatrix4x4v( int location, int count, bool transpose, double const * value );
		C3D_Gl_API bool SetUniformMatrix4x2v( int location, int count, bool transpose, double const * value );
		C3D_Gl_API bool SetUniformMatrix4x3v( int location, int count, bool transpose, double const * value );

		//@}
		/**@name Uniform Buffer Objects Functions */
		//@{

		C3D_Gl_API uint32_t GetUniformBlockIndex( uint32_t program, char const * uniformBlockName );
		C3D_Gl_API bool BindBufferBase( uint32_t target, uint32_t index, uint32_t buffer );
		C3D_Gl_API bool UniformBlockBinding( uint32_t program, uint32_t uniformBlockIndex, uint32_t uniformBlockBinding );
		C3D_Gl_API bool GetUniformIndices( uint32_t program, int uniformCount, char const ** uniformNames, uint32_t * uniformIndices );
		C3D_Gl_API bool GetActiveUniformsiv( uint32_t program, int uniformCount, uint32_t const * uniformIndices, eGL_UNIFORM_NAME pname, int * params );
		C3D_Gl_API bool GetActiveUniformBlockiv( uint32_t program, uint32_t uniformBlockIndex, eGL_UNIFORM_NAME pname, int * params );

		//@}
		/**@name Shader object Functions */
		//@{

		C3D_Gl_API uint32_t CreateShader( eGL_SHADER_TYPE type );
		C3D_Gl_API bool DeleteShader( uint32_t shader );
		C3D_Gl_API bool AttachShader( uint32_t program, uint32_t shader );
		C3D_Gl_API bool DetachShader( uint32_t program, uint32_t shader );
		C3D_Gl_API bool CompileShader( uint32_t shader );
		C3D_Gl_API bool GetShaderiv( uint32_t shader, uint32_t pname, int * param );
		C3D_Gl_API bool GetShaderInfoLog( uint32_t shader, int bufSize, int * length, char * infoLog );
		C3D_Gl_API bool ShaderSource( uint32_t shader, int count, char const ** strings, int const * lengths );

		//@}
		/**@name Shader program Functions */
		//@{

		C3D_Gl_API uint32_t CreateProgram();
		C3D_Gl_API bool DeleteProgram( uint32_t program );
		C3D_Gl_API bool LinkProgram( uint32_t program );
		C3D_Gl_API bool UseProgram( uint32_t program );
		C3D_Gl_API bool GetProgramiv( uint32_t program, uint32_t pname, int * param );
		C3D_Gl_API bool GetProgramInfoLog( uint32_t program, int bufSize, int * length, char * infoLog );
		C3D_Gl_API int GetAttribLocation( uint32_t program, char const * name );
		C3D_Gl_API bool IsProgram( uint32_t program );
		C3D_Gl_API bool ProgramParameteri( uint32_t program, uint32_t pname, int value );

		//@}
		/**@name Vertex Attribute Pointer functions */
		//@{

		C3D_Gl_API bool EnableVertexAttribArray( uint32_t index );
		C3D_Gl_API bool VertexAttribPointer( uint32_t index, int size, eGL_TYPE type, bool normalized, int stride, void const * pointer );
		C3D_Gl_API bool VertexAttribPointer( uint32_t index, int size, eGL_TYPE type, int stride, void const * pointer );
		C3D_Gl_API bool DisableVertexAttribArray( uint32_t index );

		//@}
		/**@name Vertex Array Objects */
		//@{

		C3D_Gl_API bool GenVertexArrays( int n, uint32_t * arrays );
		C3D_Gl_API bool BindVertexArray( uint32_t array );
		C3D_Gl_API bool DeleteVertexArrays( int n, uint32_t * arrays );

		//@}
		/**@name Tesselation functions */
		//@{

		C3D_Gl_API bool PatchParameter( eGL_PATCH_PARAMETER p_eParam, int p_iValue );

		//@}
		/**@name Other functions */
		//@{

		C3D_Gl_API bool GlCheckError( std::string const & p_strText )const;
		C3D_Gl_API bool GlCheckError( std::wstring const & p_strText )const;
		C3D_Gl_API eGL_LOCK GetLockFlags( uint32_t p_uiFlags )const;
		C3D_Gl_API uint32_t GetBitfieldFlags( uint32_t p_uiFlags )const;

#if !defined( NDEBUG )

		C3D_Gl_API void Track( void * p_object, std::string const & p_name, std::string const & p_file, int line );
		C3D_Gl_API void UnTrack( void * p_object );

#endif

		Castor::String GetGlslErrorString( int p_index )const
		{
			return GlslStrings[p_index];
		}
		inline eGL_PRIMITIVE Get( Castor3D::eTOPOLOGY p_index )const
		{
			return PrimitiveTypes[p_index];
		}
		inline eGL_TEXDIM Get( Castor3D::eTEXTURE_DIMENSION p_index )const
		{
			return TextureDimensions[p_index];
		}
		inline eGL_LIGHT_INDEX Get( Castor3D::eLIGHT_INDEXES p_index )const
		{
			return LightIndexes[p_index];
		}
		inline eGL_FUNC Get( Castor3D::eALPHA_FUNC p_eAlphaFunc )const
		{
			return AlphaFuncs[p_eAlphaFunc];
		}
		inline eGL_WRAP_MODE Get( Castor3D::eWRAP_MODE p_eWrapMode )const
		{
			return TextureWrapMode[p_eWrapMode];
		}
		inline eGL_INTERPOLATION_MODE Get( Castor3D::eINTERPOLATION_MODE p_eInterpolationMode )const
		{
			return TextureInterpolation[p_eInterpolationMode];
		}
		inline int Get( Castor3D::eBLEND_SOURCE p_eArgument )const
		{
			return TextureArguments[p_eArgument];
		}
		inline eGL_BLEND_FUNC Get( Castor3D::eRGB_BLEND_FUNC p_mode )const
		{
			return RgbBlendFuncs[p_mode];
		}
		inline eGL_BLEND_FUNC Get( Castor3D::eALPHA_BLEND_FUNC p_mode )const
		{
			return AlphaBlendFuncs[p_mode];
		}
		inline eGL_BLEND_FACTOR Get( Castor3D::eBLEND p_eBlendFactor )const
		{
			return BlendFactors[p_eBlendFactor];
		}
		inline PixelFmt Get( Castor::ePIXEL_FORMAT p_pixelFormat )const
		{
			return PixelFormats[p_pixelFormat];
		}
		inline eGL_BUFFER_USAGE Get( Castor3D::eELEMENT_USAGE p_eUsage )const
		{
			return Usages[p_eUsage];
		}
		inline eGL_SHADER_TYPE Get( Castor3D::eSHADER_TYPE p_type )const
		{
			return ShaderTypes[p_type];
		}
		inline eGL_INTERNAL_FORMAT GetInternal( Castor::ePIXEL_FORMAT p_eFormat )const
		{
			return Internals[p_eFormat];
		}
		inline uint32_t GetComponents( uint32_t p_uiComponents )const
		{
			return ( p_uiComponents & Castor3D::eBUFFER_COMPONENT_COLOUR ? eGL_BUFFER_BIT_COLOR : 0 ) | ( p_uiComponents & Castor3D::eBUFFER_COMPONENT_DEPTH ? eGL_BUFFER_BIT_DEPTH : 0 ) | ( p_uiComponents & Castor3D::eBUFFER_COMPONENT_STENCIL ? eGL_BUFFER_BIT_STENCIL : 0 );
		}
		inline eGL_TEXTURE_ATTACHMENT Get( Castor3D::eATTACHMENT_POINT p_eAttachment )const
		{
			return Attachments[p_eAttachment];
		}
		inline eGL_FRAMEBUFFER_MODE Get( Castor3D::eFRAMEBUFFER_TARGET p_eTarget )const
		{
			return FramebufferModes[p_eTarget];
		}
		inline eGL_RENDERBUFFER_ATTACHMENT GetRboAttachment( Castor3D::eATTACHMENT_POINT p_eAttachment )const
		{
			return RboAttachments[p_eAttachment];
		}
		inline eGL_RENDERBUFFER_STORAGE GetRboStorage( Castor::ePIXEL_FORMAT p_pixelFormat )const
		{
			return RboStorages[p_pixelFormat];
		}
		inline eGL_TWEAK Get( Castor3D::eTWEAK p_eTweak )const
		{
			return Tweaks[p_eTweak];
		}
		inline eGL_BUFFER Get( Castor3D::eBUFFER p_eBuffer )const
		{
			return Buffers[p_eBuffer];
		}
		inline eGL_BUFFER Get( eGL_TEXTURE_ATTACHMENT p_eBuffer )
		{
			return BuffersTA[p_eBuffer];
		}
		inline eGL_BUFFER Get( eGL_RENDERBUFFER_ATTACHMENT p_eBuffer )
		{
			return BuffersRBA[p_eBuffer];
		}
		inline eGL_FACE Get( Castor3D::eFACE p_eFace )const
		{
			return Faces[p_eFace];
		}
		inline eGL_FILL_MODE Get( Castor3D::eFILL_MODE p_mode )const
		{
			return FillModes[p_mode];
		}
		inline eGL_FUNC Get( Castor3D::eSTENCIL_FUNC p_eFunc )const
		{
			return StencilFuncs[p_eFunc];
		}
		inline eGL_STENCIL_OP Get( Castor3D::eSTENCIL_OP p_eOp )const
		{
			return StencilOps[p_eOp];
		}
		inline eGL_BLEND_OP Get( Castor3D::eBLEND_OP p_eOp )const
		{
			return BlendOps[p_eOp];
		}
		inline eGL_FUNC Get( Castor3D::eDEPTH_FUNC p_eFunc )const
		{
			return DepthFuncs[p_eFunc];
		}
		inline bool Get( Castor3D::eWRITING_MASK p_eMask )const
		{
			return WriteMasks[p_eMask];
		}
		inline bool HasDebugOutput()const
		{
			return ( m_pfnDebugMessageCallback || m_pfnDebugMessageCallbackAMD );
		}
		inline Castor::String const & GetVendor()const
		{
			return m_strVendor;
		}
		inline Castor::String const & GetRenderer()const
		{
			return m_strRenderer;
		}
		inline Castor::String const & GetStrVersion()const
		{
			return m_strVersion;
		}
		inline int GetVersion()const
		{
			return m_iVersion;
		}
		inline int GetGlslVersion()const
		{
			return m_iGlslVersion;
		}
		C3D_Gl_API bool HasExtension( Castor::String const & p_strExtName )const;
		inline eGL_BUFFER_MODE GetBufferFlags( uint32_t p_uiFlags )const
		{
			eGL_BUFFER_MODE l_eReturn = eGL_BUFFER_MODE( 0 );

			if ( p_uiFlags & Castor3D::eBUFFER_ACCESS_TYPE_DYNAMIC )
			{
				if ( p_uiFlags & Castor3D::eBUFFER_ACCESS_NATURE_READ )
				{
					l_eReturn = eGL_BUFFER_MODE_DYNAMIC_READ;
				}
				else if ( p_uiFlags & Castor3D::eBUFFER_ACCESS_NATURE_DRAW )
				{
					l_eReturn = eGL_BUFFER_MODE_DYNAMIC_DRAW;
				}
				else if ( p_uiFlags & Castor3D::eBUFFER_ACCESS_NATURE_COPY )
				{
					l_eReturn = eGL_BUFFER_MODE_DYNAMIC_COPY;
				}
			}
			else if ( p_uiFlags & Castor3D::eBUFFER_ACCESS_TYPE_STATIC )
			{
				if ( p_uiFlags & Castor3D::eBUFFER_ACCESS_NATURE_READ )
				{
					l_eReturn = eGL_BUFFER_MODE_STATIC_READ;
				}
				else if ( p_uiFlags & Castor3D::eBUFFER_ACCESS_NATURE_DRAW )
				{
					l_eReturn = eGL_BUFFER_MODE_STATIC_DRAW;
				}
				else if ( p_uiFlags & Castor3D::eBUFFER_ACCESS_NATURE_COPY )
				{
					l_eReturn = eGL_BUFFER_MODE_STATIC_COPY;
				}
			}
			else if ( p_uiFlags & Castor3D::eBUFFER_ACCESS_TYPE_STREAM )
			{
				if ( p_uiFlags & Castor3D::eBUFFER_ACCESS_NATURE_READ )
				{
					l_eReturn = eGL_BUFFER_MODE_STREAM_READ;
				}
				else if ( p_uiFlags & Castor3D::eBUFFER_ACCESS_NATURE_DRAW )
				{
					l_eReturn = eGL_BUFFER_MODE_STREAM_DRAW;
				}
				else if ( p_uiFlags & Castor3D::eBUFFER_ACCESS_NATURE_COPY )
				{
					l_eReturn = eGL_BUFFER_MODE_STREAM_COPY;
				}
			}

			return l_eReturn;
		}
		//@}

		C3D_Gl_API static void CALLBACK StDebugLog( eGL_DEBUG_SOURCE source, eGL_DEBUG_TYPE type, uint32_t id, eGL_DEBUG_SEVERITY severity, int length, const char * message, void * userParam );
		C3D_Gl_API static void CALLBACK StDebugLogAMD( uint32_t id, eGL_DEBUG_CATEGORY category, eGL_DEBUG_SEVERITY severity, int length, const char * message, void * userParam );

	private:
		bool DoGlCheckError( Castor::String const & p_strText )const;
		void DebugLog( eGL_DEBUG_SOURCE source, eGL_DEBUG_TYPE type, uint32_t id, eGL_DEBUG_SEVERITY severity, int length, const char * message );
		void DebugLogAMD( uint32_t id, eGL_DEBUG_CATEGORY category, eGL_DEBUG_SEVERITY severity, int length, const char * message );

	private:
		Castor::String GlslStrings[8];
		Castor::String GlslErrors[8];
		eGL_PRIMITIVE PrimitiveTypes[Castor3D::eTOPOLOGY_COUNT];
		eGL_TEXDIM TextureDimensions[Castor3D::eTEXTURE_DIMENSION_COUNT];
		eGL_FUNC AlphaFuncs[Castor3D::eALPHA_FUNC_COUNT];
		eGL_WRAP_MODE TextureWrapMode[Castor3D::eWRAP_MODE_COUNT];
		eGL_INTERPOLATION_MODE TextureInterpolation[Castor3D::eINTERPOLATION_MODE_COUNT];
		eGL_LIGHT_INDEX LightIndexes[Castor3D::eLIGHT_INDEXES_COUNT];
		eGL_BLEND_FACTOR BlendFactors[Castor3D::eBLEND_COUNT];
		eGL_BUFFER_USAGE Usages[Castor3D::eELEMENT_USAGE_COUNT];
		eGL_BLEND_SOURCE TextureArguments[Castor3D::eBLEND_SOURCE_COUNT];
		eGL_BLEND_FUNC RgbBlendFuncs[Castor3D::eRGB_BLEND_FUNC_COUNT];
		eGL_BLEND_FUNC AlphaBlendFuncs[Castor3D::eALPHA_BLEND_FUNC_COUNT];
		eGL_BLEND_OP BlendOps[Castor3D::eBLEND_OP_COUNT];
		PixelFmt PixelFormats[Castor::ePIXEL_FORMAT_COUNT];
		eGL_SHADER_TYPE ShaderTypes[Castor3D::eSHADER_TYPE_COUNT];
		eGL_INTERNAL_FORMAT Internals[Castor::ePIXEL_FORMAT_COUNT];
		eGL_TEXTURE_ATTACHMENT Attachments[Castor3D::eATTACHMENT_POINT_COUNT];
		eGL_FRAMEBUFFER_MODE FramebufferModes[Castor3D::eFRAMEBUFFER_MODE_COUNT];
		eGL_RENDERBUFFER_ATTACHMENT RboAttachments[Castor3D::eATTACHMENT_POINT_COUNT];
		eGL_RENDERBUFFER_STORAGE RboStorages[Castor::ePIXEL_FORMAT_COUNT];
		eGL_TWEAK Tweaks[Castor3D::eTWEAK_COUNT];
		eGL_BUFFER Buffers[Castor3D::eBUFFER_COUNT];
		eGL_FACE Faces[Castor3D::eFACE_COUNT];
		eGL_FILL_MODE FillModes[3];
		eGL_STENCIL_OP StencilOps[Castor3D::eSTENCIL_OP_COUNT];
		eGL_FUNC StencilFuncs[Castor3D::eSTENCIL_FUNC_COUNT];
		bool WriteMasks[Castor3D::eWRITING_MASK_COUNT];
		eGL_FUNC DepthFuncs[Castor3D::eDEPTH_FUNC_COUNT];
		std::map< eGL_TEXTURE_ATTACHMENT, eGL_BUFFER > BuffersTA;
		std::map< eGL_RENDERBUFFER_ATTACHMENT, eGL_BUFFER > BuffersRBA;

		bool m_bHasVao;
		bool m_bHasUbo;
		bool m_bHasPbo;
		bool m_bHasTbo;
		bool m_bHasFbo;
		bool m_bHasVbo;
		bool m_bHasVSh;
		bool m_bHasPSh;
		bool m_bHasGSh;
		bool m_bHasTSh;
		bool m_bHasCSh;
		bool m_bHasSpl;
		bool m_bHasDepthClipping;
		bool m_bHasAnisotropic;
		bool m_bBindVboToGpuAddress;
		Castor::String m_strExtensions;
		Castor::String m_strVendor;
		Castor::String m_strRenderer;
		Castor::String m_strVersion;
		int m_iVersion;
		int m_iGlslVersion;
		bool m_bHasInstancedDraw;
		bool m_bHasInstancedArrays;
		bool m_bHasDirectStateAccess;
		bool m_bHasNonPowerOfTwoTextures;
		MtxFunctionsBase * m_pMtxFunctions;
		TexFunctionsBase * m_pTexFunctions;
		BufFunctionsBase * m_pBufFunctions;
		GlRenderSystem & m_renderSystem;

		/**@name General */
		//@{

		std::function< uint32_t() > m_pfnGetError;
		std::function< void( float red, float green, float blue, float alpha ) > m_pfnClearColor;
		std::function< void( uint32_t mode ) > m_pfnShadeModel;
		std::function< void( uint32_t mask ) > m_pfnClear;
		std::function< void( uint32_t mode ) > m_pfnEnable;
		std::function< void( uint32_t mode ) > m_pfnDisable;
		std::function< void( int size, uint32_t * buffer ) > m_pfnSelectBuffer;
		std::function< void( uint32_t pname, int * params ) > m_pfnGetIntegerv;
		std::function< int( uint32_t mode ) > m_pfnRenderMode;
		std::function< void( PFNGLDEBUGPROC callback, void * userParam ) > m_pfnDebugMessageCallback;
		std::function< void( PFNGLDEBUGAMDPROC callback, void * userParam ) > m_pfnDebugMessageCallbackAMD;

		//@}
		/**@name Depth stencil state */
		//@{

		std::function< void( uint32_t func ) >m_pfnDepthFunc;
		std::function< void( uint8_t flag ) > m_pfnDepthMask;
		std::function< void( uint8_t r, uint8_t g, uint8_t b, uint8_t a ) > m_pfnColorMask;
		std::function< void( uint32_t sfail, uint32_t dpfail, uint32_t dppass ) > m_pfnStencilOp;
		std::function< void( uint32_t func, int ref, uint32_t mask ) > m_pfnStencilFunc;
		std::function< void( uint32_t mask ) > m_pfnStencilMask;
		std::function< void( uint32_t face, uint32_t sfail, uint32_t dpfail, uint32_t dppass ) > m_pfnStencilOpSeparate;
		std::function< void( uint32_t frontFunc, uint32_t backFunc, int ref, uint32_t mask ) > m_pfnStencilFuncSeparate;
		std::function< void( uint32_t face, uint32_t mask ) > m_pfnStencilMaskSeparate;

		//@}
		/**@name Rasterizer state */
		//@{

		std::function< void( uint32_t face, uint32_t mode ) > m_pfnPolygonMode;
		std::function< void( uint32_t face ) > m_pfnCullFace;
		std::function< void( uint32_t face ) > m_pfnFrontFace;
		std::function< void( uint32_t target, uint32_t mode ) > m_pfnHint;
		std::function< void( float factor, float units ) >m_pfnPolygonOffset;

		//@}
		/**@name Blend state */
		//@{

		std::function< void( float red, float green, float blue, float alpha ) > m_pfnBlendColor;
		std::function< void( uint32_t srcRGB, uint32_t dstRGB, uint32_t srcAlpha, uint32_t dstAlpha ) > m_pfnBlendFuncSeparate;
		std::function< void( uint32_t buf, uint32_t srcRGB, uint32_t dstRGB, uint32_t srcAlpha, uint32_t dstAlpha ) > m_pfnBlendFuncSeparatei;
		std::function< void( uint32_t mode ) > m_pfnBlendEquation;
		std::function< void( uint32_t buf, uint32_t mode ) > m_pfnBlendEquationi;
		std::function< void( float value, uint8_t invert ) > m_pfnSampleCoverage;

		//@}
		/**@name Buffer rendering */
		//@{

		std::function< void( uint32_t mode, int first, int count ) > m_pfnDrawArrays;
		std::function< void( uint32_t mode, int count, uint32_t type, void const * indices ) > m_pfnDrawElements;
		std::function< void( uint32_t mode, int first, int count, int primcount ) > m_pfnDrawArraysInstanced;
		std::function< void( uint32_t mode, int count, uint32_t type, const void * indices, int primcount ) > m_pfnDrawElementsInstanced;
		std::function< void( uint32_t index, uint32_t divisor ) > m_pfnVertexAttribDivisor;

		//@}
		/**@name Light */
		//@{

		std::function< void( uint32_t light, uint32_t pname, float param ) > m_pfnLightf;
		std::function< void( uint32_t light, uint32_t pname, float const * params ) > m_pfnLightfv;
		std::function< void( uint32_t pname, int param ) > m_pfnLightModeli;
		std::function< void( uint32_t pname, int const * param ) > m_pfnLightModeliv;
		std::function< void( uint32_t pname, float param ) > m_pfnLightModelf;
		std::function< void( uint32_t pname, float const * param ) > m_pfnLightModelfv;

		//@}
		/**@name Context */
		//@{

#if defined( _WIN32 )
		std::function< BOOL( HDC hdc, HGLRC hglrc ) > m_pfnMakeCurrent;
		std::function< BOOL( HDC hdc ) > m_pfnSwapBuffers;
		std::function< HGLRC( HDC hdc ) > m_pfnCreateContext;
		std::function< BOOL( HGLRC hContext ) > m_pfnDeleteContext;
		std::function< HGLRC( HDC hDC, HGLRC hShareContext, int const * attribList ) > m_pfnCreateContextAttribs;
		std::function< BOOL( int interval ) > m_pfnSwapInterval;
#elif defined ( __linux__ )
		std::function< int( Display * pDisplay, GLXDrawable drawable, GLXContext context ) > m_pfnMakeCurrent;
		std::function< void( Display * pDisplay, GLXDrawable drawable ) > m_pfnSwapBuffers;
		std::function< GLXContext( Display * pDisplay, XVisualInfo * pVisualInfo, GLXContext shareList, Bool direct ) > m_pfnCreateContext;
		std::function< void( Display * pDisplay, GLXContext context ) > m_pfnDeleteContext;
		std::function< GLXContext( Display * pDisplay, GLXFBConfig fbconfig, GLXContext shareList, Bool direct, int const * attribList ) > m_pfnCreateContextAttribs;
		std::function< void( Display * pDisplay, GLXDrawable drawable, int interval ) > m_pfnSwapInterval;
#else
#	error "Yet unsupported OS"
#endif

		//@}
		/**@name Matrix */
		//@{

		std::function< void( int x, int y, int width, int height ) > m_pfnViewport;

		//@}
		/**@name Material */
		//@{

		std::function< void( uint32_t sfactor, uint32_t dfactor ) > m_pfnBlendFunc;
		std::function< void( uint32_t func, float ref ) > m_pfnAlphaFunc;
		std::function< void( uint32_t face, uint32_t pname, float param ) > m_pfnMaterialf;
		std::function< void( uint32_t face, uint32_t pname, float const * params ) > m_pfnMaterialfv;

		//@}
		/**@name Texture */
		//@{

		std::function< void( int n, uint32_t * textures ) > m_pfnGenTextures;
		std::function< void( int n, uint32_t const * textures ) > m_pfnDeleteTextures;
		std::function< void( uint32_t texture ) > m_pfnActiveTexture;
		std::function< void( uint32_t texture ) > m_pfnClientActiveTexture;
		std::function< void( uint32_t target, uint32_t pname, int param ) > m_pfnTexEnvi;
		std::function< void( uint32_t target, uint32_t pname, int const * param ) > m_pfnTexEnviv;
		std::function< void( uint32_t target, uint32_t pname, float param ) > m_pfnTexEnvf;
		std::function< void( uint32_t target, uint32_t pname, float const * param ) > m_pfnTexEnvfv;
		std::function< uint8_t( uint32_t texture ) > m_pfnIsTexture;
		std::function< void( uint32_t coord, uint32_t pname, int param ) > m_pfnTexGeni;
		std::function< void( uint32_t mode ) > m_pfnReadBuffer;
#if CASTOR_HAS_VARIADIC_TEMPLATES
		std::function< void( int x, int y, int width, int height, uint32_t format, uint32_t type, void * pixels ) > m_pfnReadPixels;
#else
		void ( CALLBACK * m_pfnReadPixels )( int x, int y, int width, int height, uint32_t format, uint32_t type, void * pixels );
#endif
		std::function< void( uint32_t mode ) > m_pfnDrawBuffer;
		std::function< void( int width, int height, uint32_t format, uint32_t type, void const * data ) > m_pfnDrawPixels;
		std::function< void( uint32_t pname, int param ) > m_pfnPixelStorei;
		std::function< void( uint32_t pname, float param ) > m_pfnPixelStoref;

		//@}
		/**@name Sampler */
		//@{

		std::function< void( int count, const uint32_t * samplers ) > m_pfnDeleteSamplers;
		std::function< void( int count, uint32_t * samplers ) > m_pfnGenSamplers;
		std::function< uint8_t( uint32_t sampler ) > m_pfnIsSampler;
		std::function< void( uint32_t unit, uint32_t sampler ) > m_pfnBindSampler;
		std::function< void( uint32_t sampler, uint32_t pname, uint32_t * params ) > m_pfnGetSamplerParameteruiv;
		std::function< void( uint32_t sampler, uint32_t pname, float * params ) > m_pfnGetSamplerParameterfv;
		std::function< void( uint32_t sampler, uint32_t pname, int * params ) > m_pfnGetSamplerParameteriv;
		std::function< void( uint32_t sampler, uint32_t pname, const uint32_t * params ) > m_pfnSamplerParameteruiv;
		std::function< void( uint32_t sampler, uint32_t pname, float param ) > m_pfnSamplerParameterf;
		std::function< void( uint32_t sampler, uint32_t pname, const float * params ) > m_pfnSamplerParameterfv;
		std::function< void( uint32_t sampler, uint32_t pname, int param ) > m_pfnSamplerParameteri;
		std::function< void( uint32_t sampler, uint32_t pname, const int * params ) > m_pfnSamplerParameteriv;

		//@}
		/**@name Texture Buffer Objects */
		//@{

		std::function< void( uint32_t target, uint32_t internalFormat, uint32_t buffer ) > m_pfnTexBuffer;

		//@}
		/**@name Buffer Objects */
		//@{

		std::function< void( int n, uint32_t * buffers ) > m_pfnGenBuffers;
		std::function< void( int n, uint32_t const * buffers ) > m_pfnDeleteBuffers;
		std::function< uint8_t( uint32_t buffer ) > m_pfnIsBuffer;
		std::function< void( int size, uint32_t type, int stride, void const * pointer ) > m_pfnVertexPointer;
		std::function< void( uint32_t type, int stride, void const * pointer ) > m_pfnNormalPointer;
		std::function< void( uint32_t type, int stride, void * pointer ) > m_pfnTangentPointer;
		std::function< void( uint32_t type, int stride, void * pointer ) > m_pfnBinormalPointer;
		std::function< void( int size, uint32_t type, int stride, void const * pointer ) > m_pfnColorPointer;
		std::function< void( int size, uint32_t type, int stride, void  const * pointer ) > m_pfnTexCoordPointer;

		//@}
		/**@name FBO */
		//@{

		std::function< void( int n, uint32_t * framebuffers ) > m_pfnGenFramebuffers;
		std::function< void( int n, uint32_t const * framebuffers ) > m_pfnDeleteFramebuffers;
		std::function< void( uint32_t target, uint32_t framebuffer ) > m_pfnBindFramebuffer;
		std::function< uint32_t( uint32_t target ) > m_pfnCheckFramebufferStatus;
		std::function< void( uint32_t target, uint32_t attachment, uint32_t texture, int level ) > m_pfnFramebufferTexture;
		std::function< void( uint32_t target, uint32_t attachment, uint32_t textarget, uint32_t texture, int level ) > m_pfnFramebufferTexture1D;
		std::function< void( uint32_t target, uint32_t attachment, uint32_t textarget, uint32_t texture, int level ) > m_pfnFramebufferTexture2D;
		std::function< void( uint32_t target, uint32_t attachment, uint32_t texture, int level, int layer ) > m_pfnFramebufferTextureLayer;
#if CASTOR_HAS_VARIADIC_TEMPLATES
		std::function< void( uint32_t target, uint32_t attachment, uint32_t textarget, uint32_t texture, int level, int layer ) > m_pfnFramebufferTexture3D;
		std::function< void( int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, uint32_t mask, uint32_t filter ) > m_pfnBlitFramebuffer;
#else
		void ( CALLBACK * m_pfnFramebufferTexture3D )( uint32_t target, uint32_t attachment, uint32_t textarget, uint32_t texture, int level, int layer );
		void ( CALLBACK * m_pfnBlitFramebuffer )( int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, uint32_t mask, uint32_t filter );
#endif
		std::function< void( int n, uint32_t const * bufs ) > m_pfnDrawBuffers;

		//@}
		/**@name RBO */
		//@{

		std::function< void( uint32_t target, uint32_t attachmentPoint, uint32_t renderbufferTarget, uint32_t renderbufferId ) > m_pfnFramebufferRenderbuffer;
		std::function< void( int n, uint32_t * ids ) > m_pfnGenRenderbuffers;
		std::function< void( int n, uint32_t const * ids ) > m_pfnDeleteRenderbuffers;
		std::function< void( uint32_t target, uint32_t id ) > m_pfnBindRenderbuffer;
		std::function< void( uint32_t target, uint32_t internalFormat, int width, int height ) > m_pfnRenderbufferStorage;
		std::function< void( uint32_t target, int isamples, uint32_t internalFormat, int width, int height ) > m_pfnRenderbufferStorageMultisample;
#if CASTOR_HAS_VARIADIC_TEMPLATES
		std::function< void( uint32_t target, int samples, int internalformat, int width, int height, uint8_t fixedsamplelocations ) > m_pfnTexImage2DMultisample;
#else
		void ( CALLBACK * m_pfnTexImage2DMultisample )( uint32_t target, int samples, int internalformat, int width, int height, uint8_t fixedsamplelocations );
#endif
		std::function< void( uint32_t target, uint32_t param, int * value ) > m_pfnGetRenderbufferParameteriv;

		//@}
		/**@name Uniform variables */
		//@{

		std::function< int( uint32_t program, char const * name ) > m_pfnGetUniformLocation;
#if CASTOR_HAS_VARIADIC_TEMPLATES
		std::function< void( uint32_t program, uint32_t index, int maxLength, int * length, int * size, uint32_t * type, char * name ) > m_pfnGetActiveUniform;
#else
		void ( CALLBACK * m_pfnGetActiveUniform )( uint32_t program, uint32_t index, int maxLength, int * length, int * size, uint32_t * type, char * name );
#endif
		std::function< void( int location, int v0 ) > m_pfnUniform1i;
		std::function< void( int location, int v0, int v1 ) > m_pfnUniform2i;
		std::function< void( int location, int v0, int v1, int v2 ) > m_pfnUniform3i;
		std::function< void( int location, int v0, int v1, int v2, int v3 ) > m_pfnUniform4i;
		std::function< void( int location, int count, int const * value ) > m_pfnUniform1iv;
		std::function< void( int location, int count, int const * value ) > m_pfnUniform2iv;
		std::function< void( int location, int count, int const * value ) > m_pfnUniform3iv;
		std::function< void( int location, int count, int const * value ) > m_pfnUniform4iv;
		std::function< void( int, uint32_t ) > m_pfnUniform1ui;
		std::function< void( int, uint32_t, uint32_t ) > m_pfnUniform2ui;
		std::function< void( int, uint32_t, uint32_t, uint32_t ) > m_pfnUniform3ui;
		std::function< void( int, uint32_t, uint32_t, uint32_t, uint32_t ) > m_pfnUniform4ui;
		std::function< void( int, int, uint32_t const * ) > m_pfnUniform1uiv;
		std::function< void( int, int, uint32_t const * ) > m_pfnUniform2uiv;
		std::function< void( int, int, uint32_t const * ) > m_pfnUniform3uiv;
		std::function< void( int, int, uint32_t const * ) > m_pfnUniform4uiv;
		std::function< void( int location, float v0 ) > m_pfnUniform1f;
		std::function< void( int location, float v0, float v1 ) > m_pfnUniform2f;
		std::function< void( int location, float v0, float v1, float v2 ) > m_pfnUniform3f;
		std::function< void( int location, float v0, float v1, float v2, float v3 ) > m_pfnUniform4f;
		std::function< void( int location, int count, float const * value ) > m_pfnUniform1fv;
		std::function< void( int location, int count, float const * value ) > m_pfnUniform2fv;
		std::function< void( int location, int count, float const * value ) > m_pfnUniform3fv;
		std::function< void( int location, int count, float const * value ) > m_pfnUniform4fv;
		std::function< void( int location, double x ) > m_pfnUniform1d;
		std::function< void( int location, double x, double y ) > m_pfnUniform2d;
		std::function< void( int location, double x, double y, double z ) > m_pfnUniform3d;
		std::function< void( int location, double x, double y, double z, double w ) > m_pfnUniform4d;
		std::function< void( int location, int count, double const * value ) > m_pfnUniform1dv;
		std::function< void( int location, int count, double const * value ) > m_pfnUniform2dv;
		std::function< void( int location, int count, double const * value ) > m_pfnUniform3dv;
		std::function< void( int location, int count, double const * value ) > m_pfnUniform4dv;
		std::function< void( int location, int count, uint8_t transpose, float const * value ) >m_pfnUniformMatrix2fv;
		std::function< void( int location, int count, uint8_t transpose, float const * value ) >m_pfnUniformMatrix2x3fv;
		std::function< void( int location, int count, uint8_t transpose, float const * value ) >m_pfnUniformMatrix2x4fv;
		std::function< void( int location, int count, uint8_t transpose, float const * value ) >m_pfnUniformMatrix3fv;
		std::function< void( int location, int count, uint8_t transpose, float const * value ) >m_pfnUniformMatrix3x2fv;
		std::function< void( int location, int count, uint8_t transpose, float const * value ) >m_pfnUniformMatrix3x4fv;
		std::function< void( int location, int count, uint8_t transpose, float const * value ) >m_pfnUniformMatrix4fv;
		std::function< void( int location, int count, uint8_t transpose, float const * value ) >m_pfnUniformMatrix4x2fv;
		std::function< void( int location, int count, uint8_t transpose, float const * value ) >m_pfnUniformMatrix4x3fv;
		std::function< void( int location, int count, uint8_t transpose, double const * value ) > m_pfnUniformMatrix2dv;
		std::function< void( int location, int count, uint8_t transpose, double const * value ) > m_pfnUniformMatrix2x3dv;
		std::function< void( int location, int count, uint8_t transpose, double const * value ) > m_pfnUniformMatrix2x4dv;
		std::function< void( int location, int count, uint8_t transpose, double const * value ) > m_pfnUniformMatrix3dv;
		std::function< void( int location, int count, uint8_t transpose, double const * value ) > m_pfnUniformMatrix3x2dv;
		std::function< void( int location, int count, uint8_t transpose, double const * value ) > m_pfnUniformMatrix3x4dv;
		std::function< void( int location, int count, uint8_t transpose, double const * value ) > m_pfnUniformMatrix4dv;
		std::function< void( int location, int count, uint8_t transpose, double const * value ) > m_pfnUniformMatrix4x2dv;
		std::function< void( int location, int count, uint8_t transpose, double const * value ) > m_pfnUniformMatrix4x3dv;

		//@}
		/**@name Uniform buffer object */
		//@{

		std::function< uint32_t( uint32_t program, char const * uniformBlockName ) > m_pfnGetUniformBlockIndex;
		std::function< void( uint32_t target, uint32_t index, uint32_t buffer ) > m_pfnBindBufferBase;
		std::function< void( uint32_t program, uint32_t uniformBlockIndex, uint32_t uniformBlockBinding ) > m_pfnUniformBlockBinding;
		std::function< void( uint32_t program, int uniformCount, char const ** uniformNames, uint32_t * uniformIndices ) > m_pfnGetUniformIndices;
		std::function< void( uint32_t program, int uniformCount, uint32_t const * uniformIndices, uint32_t pname, int * params ) > m_pfnGetActiveUniformsiv;
		std::function< void( uint32_t program, uint32_t uniformBlockIndex, uint32_t pname, int * params ) > m_pfnGetActiveUniformBlockiv;

		//@}
		/**@name Shader object */
		//@{

		std::function< uint32_t( uint32_t type ) > m_pfnCreateShader;
		std::function< void( uint32_t shader ) > m_pfnDeleteShader;
		std::function< void( uint32_t program, uint32_t shader ) > m_pfnAttachShader;
		std::function< void( uint32_t program, uint32_t shader ) > m_pfnDetachShader;
		std::function< void( uint32_t shader ) > m_pfnCompileShader;
		std::function< void( uint32_t shader, uint32_t pname, int * param ) > m_pfnGetShaderiv;
		std::function< void( uint32_t shader, int bufSize, int * length, char * infoLog ) > m_pfnGetShaderInfoLog;
		std::function< void( uint32_t shader, int count, const char ** string, const int * length ) > m_pfnShaderSource;

		//@}
		/**@name Shader program */
		//@{

		std::function< uint32_t() > m_pfnCreateProgram;
		std::function< void( uint32_t program ) > m_pfnDeleteProgram;
		std::function< uint8_t( uint32_t program ) > m_pfnIsProgram;
		std::function< void( uint32_t program ) > m_pfnLinkProgram;
		std::function< void( uint32_t program ) > m_pfnValidateProgram;
		std::function< void( uint32_t program ) > m_pfnUseProgram;
		std::function< void( uint32_t program, uint32_t pname, int * param ) > m_pfnGetProgramiv;
		std::function< void( uint32_t program, int bufSize, int * length, char * infoLog ) > m_pfnGetProgramInfoLog;
		std::function< int( uint32_t program, char const * name ) > m_pfnGetAttribLocation;
		std::function< void( uint32_t program, uint32_t pname, int value ) > m_pfnProgramParameteri;

		//@}
		/**@name Vertex Attribute Pointer */
		//@{

		std::function< void( uint32_t ) > m_pfnEnableVertexAttribArray;
#if CASTOR_HAS_VARIADIC_TEMPLATES
		std::function< void( uint32_t index, int size, uint32_t type, uint8_t normalized, int stride, void const * pointer ) > m_pfnVertexAttribPointer;
#else
		void ( CALLBACK * m_pfnVertexAttribPointer )( uint32_t index, int size, uint32_t type, uint8_t normalized, int stride, void const * pointer );
#endif
		std::function< void( uint32_t index, int size, uint32_t type, int stride, void const * pointer ) > m_pfnVertexAttribIPointer;
		std::function< void( uint32_t ) > m_pfnDisableVertexAttribArray;

		//@}
		/**@name Vertex Array Object */
		//@{

		std::function< void( int n, uint32_t * arrays ) > m_pfnGenVertexArrays;
		std::function< void( int n, uint32_t const * arrays ) > m_pfnDeleteVertexArrays;
		std::function< void( uint32_t array ) > m_pfnBindVertexArray;

		//@}
		/*@name NV_vertex_buffer_unified_memory extension */
		//@{

		std::function< void( uint32_t value, uint64_t * result ) > m_pfnGetIntegerui64v;

		//@}

		std::function< void( uint32_t p_param, int p_value ) > m_pfnPatchParameteri;
	};

	namespace gl_api
	{
		template< typename Func >
		bool GetFunction( Castor::String const & p_name, Func & p_func )
		{
#if defined( _WIN32 )
			p_func = reinterpret_cast< Func >( wglGetProcAddress( Castor::string::string_cast< char >( p_name ).c_str() ) );
#else
			p_func = reinterpret_cast< Func >( glXGetProcAddressARB( ( GLubyte const * )Castor::string::string_cast< char >( p_name ).c_str() ) );
#endif
			return p_func != NULL;
		}

#if CASTOR_HAS_VARIADIC_TEMPLATES
		template< typename Ret, typename ... Arguments >
		bool GetFunction( Castor::String const & p_name, std::function< Ret( Arguments... ) > & p_func )
		{
			typedef Ret( CALLBACK * PFNType )( Arguments... );
			PFNType l_pfnResult = NULL;

			if ( GetFunction( p_name, l_pfnResult ) )
			{
				p_func = l_pfnResult;
			}

			return l_pfnResult != NULL;
		}
#else
		template< typename Ret >
		bool GetFunction( Castor::String const & p_name, std::function< Ret() > & p_func )
		{
			typedef Ret( CALLBACK * PFNType )();
			PFNType l_pfnResult = NULL;

			if ( GetFunction( p_name, l_pfnResult ) )
			{
				p_func = l_pfnResult;
			}

			return l_pfnResult != NULL;
		}

		template< typename Ret, typename T1 >
		bool GetFunction( Castor::String const & p_name, std::function< Ret( T1 ) > & p_func )
		{
			typedef Ret( CALLBACK * PFNType )( T1 );
			PFNType l_pfnResult = NULL;

			if ( GetFunction( p_name, l_pfnResult ) )
			{
				p_func = l_pfnResult;
			}

			return l_pfnResult != NULL;
		}

		template< typename Ret, typename T1, typename T2 >
		bool GetFunction( Castor::String const & p_name, std::function< Ret( T1, T2 ) > & p_func )
		{
			typedef Ret( CALLBACK * PFNType )( T1, T2 );
			PFNType l_pfnResult = NULL;

			if ( GetFunction( p_name, l_pfnResult ) )
			{
				p_func = l_pfnResult;
			}

			return l_pfnResult != NULL;
		}

		template< typename Ret, typename T1, typename T2, typename T3 >
		bool GetFunction( Castor::String const & p_name, std::function< Ret( T1, T2, T3 ) > & p_func )
		{
			typedef Ret( CALLBACK * PFNType )( T1, T2, T3 );
			PFNType l_pfnResult = NULL;

			if ( GetFunction( p_name, l_pfnResult ) )
			{
				p_func = l_pfnResult;
			}

			return l_pfnResult != NULL;
		}

		template< typename Ret, typename T1, typename T2, typename T3, typename T4 >
		bool GetFunction( Castor::String const & p_name, std::function< Ret( T1, T2, T3, T4 ) > & p_func )
		{
			typedef Ret( CALLBACK * PFNType )( T1, T2, T3, T4 );
			PFNType l_pfnResult = NULL;

			if ( GetFunction( p_name, l_pfnResult ) )
			{
				p_func = l_pfnResult;
			}

			return l_pfnResult != NULL;
		}

		template< typename Ret, typename T1, typename T2, typename T3, typename T4, typename T5 >
		bool GetFunction( Castor::String const & p_name, std::function< Ret( T1, T2, T3, T4, T5 ) > & p_func )
		{
			typedef Ret( CALLBACK * PFNType )( T1, T2, T3, T4, T5 );
			PFNType l_pfnResult = NULL;

			if ( GetFunction( p_name, l_pfnResult ) )
			{
				p_func = l_pfnResult;
			}

			return l_pfnResult != NULL;
		}

		template< typename Ret, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6 >
		bool GetFunction( Castor::String const & p_name, std::function< Ret( T1, T2, T3, T4, T5, T6 ) > & p_func )
		{
			typedef Ret( CALLBACK * PFNType )( T1, T2, T3, T4, T5, T6 );
			PFNType l_pfnResult = NULL;

			if ( GetFunction( p_name, l_pfnResult ) )
			{
				p_func = l_pfnResult;
			}

			return l_pfnResult != NULL;
		}

		template< typename Ret, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7 >
		bool GetFunction( Castor::String const & p_name, std::function< Ret( T1, T2, T3, T4, T5, T6, T7 ) > & p_func )
		{
			typedef Ret( CALLBACK * PFNType )( T1, T2, T3, T4, T5, T6, T7 );
			PFNType l_pfnResult = NULL;

			if ( GetFunction( p_name, l_pfnResult ) )
			{
				p_func = l_pfnResult;
			}

			return l_pfnResult != NULL;
		}

		template< typename Ret, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8 >
		bool GetFunction( Castor::String const & p_name, std::function< Ret( T1, T2, T3, T4, T5, T6, T7, T8 ) > & p_func )
		{
			typedef Ret( CALLBACK * PFNType )( T1, T2, T3, T4, T5, T6, T7, T8 );
			PFNType l_pfnResult = NULL;

			if ( GetFunction( p_name, l_pfnResult ) )
			{
				p_func = l_pfnResult;
			}

			return l_pfnResult != NULL;
		}

		template< typename Ret, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9 >
		bool GetFunction( Castor::String const & p_name, std::function< Ret( T1, T2, T3, T4, T5, T6, T7, T8, T9 ) > & p_func )
		{
			typedef Ret( CALLBACK * PFNType )( T1, T2, T3, T4, T5, T6, T7, T8, T9 );
			PFNType l_pfnResult = NULL;

			if ( GetFunction( p_name, l_pfnResult ) )
			{
				p_func = l_pfnResult;
			}

			return l_pfnResult != NULL;
		}

		template< typename Ret, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10 >
		bool GetFunction( Castor::String const & p_name, std::function< Ret( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10 ) > & p_func )
		{
			typedef Ret( CALLBACK * PFNType )( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10 );
			PFNType l_pfnResult = NULL;

			if ( GetFunction( p_name, l_pfnResult ) )
			{
				p_func = l_pfnResult;
			}

			return l_pfnResult != NULL;
		}
#endif
	}

#	define MAKE_GL_EXTENSION( x )	static const Castor::String x = cuT( "GL_" ) cuT( #x );
#	define MAKE_WGL_EXTENSION( x )	static const Castor::String x = cuT( "WGL_" ) cuT( #x );
#	define MAKE_GLX_EXTENSION( x )	static const Castor::String x = cuT( "GLX_" ) cuT( #x );

	MAKE_GL_EXTENSION( ARB_draw_buffers_blend	)
	MAKE_GL_EXTENSION( AMD_draw_buffers_blend	)
	MAKE_GL_EXTENSION( EXT_clip_volume_hint	)
	MAKE_GL_EXTENSION( ARB_texture_multisample	)
	MAKE_GL_EXTENSION( ARB_imaging	)
	MAKE_GL_EXTENSION( ARB_debug_output	)
	MAKE_GL_EXTENSION( AMDX_debug_output	)
	MAKE_GL_EXTENSION( ARB_vertex_buffer_object	)
	MAKE_GL_EXTENSION( EXT_coordinate_frame	)
	MAKE_GL_EXTENSION( ARB_pixel_buffer_object	)
	MAKE_GL_EXTENSION( ARB_vertex_array_object	)
	MAKE_GL_EXTENSION( ARB_texture_buffer_object	)
	MAKE_GL_EXTENSION( EXT_framebuffer_object	)
	MAKE_GL_EXTENSION( ARB_framebuffer_object	)
	MAKE_GL_EXTENSION( ARB_sampler_objects	)
	MAKE_GL_EXTENSION( EXT_texture_filter_anisotropic	)
	MAKE_GL_EXTENSION( ARB_vertex_program	)
	MAKE_GL_EXTENSION( ARB_fragment_program	)
	MAKE_GL_EXTENSION( ARB_uniform_buffer_object	)
	MAKE_GL_EXTENSION( ARB_geometry_shader4	)
	MAKE_GL_EXTENSION( EXT_geometry_shader4	)
	MAKE_GL_EXTENSION( ARB_tessellation_shader	)
	MAKE_GL_EXTENSION( ARB_compute_shader	)
	MAKE_GL_EXTENSION( ARB_draw_instanced	)
	MAKE_GL_EXTENSION( ARB_instanced_arrays	)
	MAKE_GL_EXTENSION( EXT_draw_instanced	)
	MAKE_GL_EXTENSION( EXT_instanced_arrays	)
	MAKE_GL_EXTENSION( EXT_direct_state_access	)
	MAKE_GL_EXTENSION( ARB_texture_non_power_of_two	)
	MAKE_GL_EXTENSION( NV_vertex_buffer_unified_memory	)
	MAKE_GL_EXTENSION( NV_shader_buffer_load	)

#	if defined( _WIN32 )
	MAKE_WGL_EXTENSION( ARB_create_context	)
	MAKE_WGL_EXTENSION( ARB_pixel_format	)
	MAKE_WGL_EXTENSION( EXT_swap_control	)
#	elif defined( __linux__ )
	MAKE_GLX_EXTENSION( ARB_create_context	)
	MAKE_GLX_EXTENSION( EXT_swap_control	)
#	else
#		error "Yet unsupported OS"
#	endif
}

#	if !defined( NDEBUG )
#		define glCheckError( gl, txt )			( gl ).GlCheckError( txt )
#		define glTrack( gl, type, object )		( gl ).Track( object, #type, __FILE__, __LINE__ )
#		define glUntrack( gl, object )			( gl ).UnTrack( object )
#	else
#		define glCheckError( gl, txt )			true
#		define glTrack( gl, type, object )
#		define glUntrack( gl, object )
#	endif

#endif
