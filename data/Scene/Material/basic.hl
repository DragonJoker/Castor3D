uniform float4x4 	c3d_mtxProjection;
uniform float4x4 	c3d_mtxProjectionModelView;
uniform float4x4 	c3d_mtxModelView;
uniform float4x4 	c3d_mtxModel;
uniform float4x4 	c3d_mtxNormal;
float4 				c3d_v4AmbientLight;
float4 				c3d_v4MatAmbient;
float4 				c3d_v4MatEmissive;
float4 				c3d_v4MatDiffuse;
float4 				c3d_v4MatSpecular;
float 				c3d_fMatShininess;
uniform int 		c3d_iLightsCount;
texture LightsTexture : c3d_Lights;
sampler2D LightsSampler = sampler_state
{
    Texture = (c3d_sLights);
    MagFilter = NEAREST;
    MinFilter = NEAREST;
    Mipfilter = NEAREST;
};

struct VtxInput
{
	float4 Position	:	POSITION;
	float3 Normal	:	NORMAL;
};

struct VtxOuput
{
	float4 Position	:	POSITION0;
	float3 Normal	:	NORMAL;
	float3 Coin		:	POSITION1;
};

struct Light
{
	float4 		m_v4Ambient;
	float4 		m_v4Diffuse;
	float4 		m_v4Specular;
	float4		m_v4Position;
	int 		m_iType;
	float3		m_v3Attenuation;
	float4x4	m_mtx4Orientation;
	float		m_fExponent;
	float		m_fCutOff;
};

Light GetLight( int i )
{
	Light l_lightReturn;
	l_lightReturn.m_v4Ambient		= tex2D( LightsSampler, float2( (i * 0.1) + (0 * 0.01) + 0.005, 0.0 ) );
	l_lightReturn.m_v4Diffuse		= tex2D( LightsSampler, float2( (i * 0.1) + (1 * 0.01) + 0.005, 0.0 ) );
	l_lightReturn.m_v4Specular		= tex2D( LightsSampler, float2( (i * 0.1) + (2 * 0.01) + 0.005, 0.0 ) );
	l_lightReturn.m_v4Position		= tex2D( LightsSampler, float2( (i * 0.1) + (3 * 0.01) + 0.005, 0.0 ) );
	l_lightReturn.m_v3Attenuation	= tex2D( LightsSampler, float2( (i * 0.1) + (4 * 0.01) + 0.005, 0.0 ) ).xyz;
	float4 	l_v4A					= tex2D( LightsSampler, float2( (i * 0.1) + (5 * 0.01) + 0.005, 0.0 ) );
	float4 	l_v4B					= tex2D( LightsSampler, float2( (i * 0.1) + (6 * 0.01) + 0.005, 0.0 ) );
	float4 	l_v4C					= tex2D( LightsSampler, float2( (i * 0.1) + (7 * 0.01) + 0.005, 0.0 ) );
	float4 	l_v4D					= tex2D( LightsSampler, float2( (i * 0.1) + (8 * 0.01) + 0.005, 0.0 ) );
	float2	l_v2Spot				= tex2D( LightsSampler, float2( (i * 0.1) + (9 * 0.01) + 0.005, 0.0 ) ).xy;
	l_lightReturn.m_v4Position		= float4( l_lightReturn.m_v4Position.w, l_lightReturn.m_v4Position.z, l_lightReturn.m_v4Position.y, l_lightReturn.m_v4Position.x );
	l_lightReturn.m_iType			= int( l_lightReturn.m_v4Position.w );
	l_lightReturn.m_mtx4Orientation	= float4x4( l_v4A, l_v4B, l_v4C, l_v4D );
	l_lightReturn.m_fExponent		= l_v2Spot.x;
	l_lightReturn.m_fCutOff			= l_v2Spot.x;
	l_lightReturn.m_v4Ambient		= float4( l_lightReturn.m_v4Ambient.z, l_lightReturn.m_v4Ambient.y, l_lightReturn.m_v4Ambient.x, 1.0 );
	l_lightReturn.m_v4Diffuse		= float4( l_lightReturn.m_v4Diffuse.z, l_lightReturn.m_v4Diffuse.y, l_lightReturn.m_v4Diffuse.x, 1.0 );
	l_lightReturn.m_v4Specular		= float4( l_lightReturn.m_v4Specular.z,l_lightReturn.m_v4Specular.y,l_lightReturn.m_v4Specular.x,1.0 );
	return l_lightReturn;
}

VtxOuput mainVx( in VtxInput p_input )
{
	VtxOuput l_output;	
	l_output.Position	= mul( p_input.Position, c3d_mtxProjectionModelView );
	l_output.Normal		= mul( p_input.Normal, (float3x3)c3d_mtxModel );
	l_output.Coin		= l_output.Position.xyz;
  	return l_output;
}

float4 mainPx( in VtxOuput p_input) : COLOR0
{
	float4 	l_v4Return	= float4( 0, 0, 0, 0 );
	int 	i;
	float4 	l_v4Diffuse;
	float4 	l_v4Specular;
	float3 	l_v3LightDir;
	Light  	l_light;
	float	l_fLambert;
	float	l_fSpecular;
	float3	l_v3Eye = normalize( -p_input.Position.xyz );
	float3	l_v3Normal = normalize( p_input.Normal );

	for( i = 0 ; i < c3d_iLightsCount ; i++ )
	{
		l_light			= GetLight( i );
		l_v3LightDir	= normalize( mul( l_light.m_v4Position, c3d_mtxModelView ).xyz );
//		l_v3LightDir	= l_light.m_v4Position.xyz - vtx_vertex;
		l_fLambert		= dot( l_v3Normal, l_v3LightDir );
	
		if( l_fLambert > 0.0 )
		{
			l_fSpecular		= pow( max( dot( reflect( -l_v3LightDir, l_v3Normal ), l_v3Eye ), 0.0 ), c3d_fMatShininess );
			l_v4Diffuse		= c3d_v4MatDiffuse 	* l_fLambert;
			l_v4Specular	= c3d_v4MatSpecular	* l_fSpecular;

			l_v4Return += l_light.m_v4Ambient 	* c3d_v4MatAmbient;
			l_v4Return += l_light.m_v4Diffuse 	* l_v4Diffuse;
			l_v4Return += l_light.m_v4Specular 	* l_v4Specular;
		}
	}
	
	return l_v4Return;
}