struct VtxInput
{
	float4 Position	:	POSITION0;
	float3 Normal	:	NORMAL0;
	float3 Tangent	:	TANGENT0;
	float2 Texture	:	TEXCOORD0;
};

struct VtxOutput
{
	float4 Position			:	SV_POSITION;
	float2 Texture			:	TEXCOORD0;
	float3 PositionVertex	:	POSITION0;
	float3 EyePosition		:	POSITION1;
	float3 NormaleVertex	:	NORMAL0;
	float3 Light0			:	NORMAL1;
	float3 Light1			:	NORMAL2;
	float3 Light2			:	NORMAL3;
};

float4x4 c3d_mtxProjectionMatrix;
float4x4 c3d_mtxProjectionModelViewMatrix;
float4x4 c3d_mtxModelViewMatrix;
float4x4 c3d_mtxNormalMatrix;
float4 c3d_LightsPosition[8];

VtxOutput mainVx( in VtxInput p_input)
{
	float3x3 l_normalMatrix = (float3x3)c3d_mtxNormalMatrix;
	VtxOutput l_output;
	l_output.Texture = p_input.Texture;

	float3 binormal = cross( p_input.Tangent, p_input.Normal);

	float3x3 TBN_Matrix;
	TBN_Matrix[0] =  mul( p_input.Tangent, l_normalMatrix);
	TBN_Matrix[1] =  mul( binormal, l_normalMatrix);
	TBN_Matrix[2] =  mul( p_input.Normal, l_normalMatrix);

	// transforme le vecteur vision :
	float4 VertexModelView = mul( p_input.Position, c3d_mtxModelViewMatrix);
	l_output.EyePosition = mul( TBN_Matrix, -VertexModelView.xyz);

	// transforme le vecteur lumiere :
	// transforme le vecteur lumiere :
	l_output.Light0 = mul( c3d_LightsPosition[0], c3d_mtxModelViewMatrix).xyz;
	l_output.Light1 = mul( c3d_LightsPosition[1], c3d_mtxModelViewMatrix).xyz;
	l_output.Light2 = mul( c3d_LightsPosition[2], c3d_mtxModelViewMatrix).xyz;

	l_output.PositionVertex = mul( TBN_Matrix, mul( p_input.Position, c3d_mtxModelViewMatrix).xyz);
	l_output.NormaleVertex = normalize( mul( p_input.Normal, l_normalMatrix));

	// Vertex transformation 
	l_output.Position = mul( p_input.Position, c3d_mtxProjectionModelViewMatrix);
	
	return l_output;
}
