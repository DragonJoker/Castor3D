#version 420 core

layout(triangles, equal_spacing, ccw) in;

in vec3 tc_vertex[];
in vec3 tc_normal[];
in vec3 tc_tangent[];
in vec3 tc_bitangent[];
in vec2 tc_texture[];

out vec3 te_vertex;
out vec3 te_normal;
out vec3 te_tangent;
out vec3 te_bitangent;
out vec2 te_texture;
out mat4 te_mtxModelView;

uniform mat4 	c3d_mtxProjection;
uniform mat4 	c3d_mtxModel;
uniform mat4 	c3d_mtxView;
uniform mat3 	c3d_mtxNormal;

vec2 Interpolate2D( vec2 v0, vec2 v1, vec2 v2 )
{
	return (gl_TessCoord.x * v0 + gl_TessCoord.y * v1 + gl_TessCoord.z * v2);
}

vec3 Interpolate3D( vec3 v0, vec3 v1, vec3 v2 )
{
	return (gl_TessCoord.x * v0 + gl_TessCoord.y * v1 + gl_TessCoord.z * v2);
}
 
void main()
{
	te_mtxModelView	= c3d_mtxView * c3d_mtxModel;
	te_vertex		= mat3( te_mtxModelView ) * Interpolate3D( tc_vertex[0], tc_vertex[1], tc_vertex[2] );
	te_normal		= c3d_mtxNormal * Interpolate3D( tc_normal[0], tc_normal[1], tc_normal[2] );
	te_tangent		= c3d_mtxNormal * Interpolate3D( tc_tangent[0], tc_tangent[1], tc_tangent[2] );
	te_bitangent	= c3d_mtxNormal * Interpolate3D( tc_bitangent[0], tc_bitangent[1], tc_bitangent[2] );
	te_texture		= Interpolate2D( tc_texture[0], tc_texture[1], tc_texture[2] );
	
	te_normal		= normalize( te_normal );
	te_tangent		= normalize( te_tangent );
	te_bitangent	= normalize( te_bitangent );
	
	gl_Position = c3d_mtxProjection * vec4( te_vertex, 1.0 );
}
