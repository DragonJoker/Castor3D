diff --git a/include/fastgltf/parser.hpp b/include/fastgltf/parser.hpp
index bf78216..27edb2c 100644
--- a/include/fastgltf/parser.hpp
+++ b/include/fastgltf/parser.hpp
@@ -179,6 +179,9 @@ namespace fastgltf {
 
         // See https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Archived/KHR_materials_pbrSpecularGlossiness/README.md
         KHR_materials_pbrSpecularGlossiness = 1 << 19,
+
+        // See https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Vendor/EXT_mesh_gpu_instancing/README.md
+        EXT_mesh_gpu_instancing = 1 << 20,
     };
     // clang-format on
 
@@ -269,6 +272,7 @@ namespace fastgltf {
         constexpr std::string_view KHR_materials_volume = "KHR_materials_volume";
         constexpr std::string_view KHR_materials_pbrSpecularGlossiness = "KHR_materials_pbrSpecularGlossiness";
         constexpr std::string_view KHR_mesh_quantization = "KHR_mesh_quantization";
+        constexpr std::string_view EXT_mesh_gpu_instancing = "EXT_mesh_gpu_instancing";
         constexpr std::string_view KHR_texture_basisu = "KHR_texture_basisu";
         constexpr std::string_view KHR_texture_transform = "KHR_texture_transform";
         constexpr std::string_view MSFT_texture_dds = "MSFT_texture_dds";
@@ -278,7 +282,7 @@ namespace fastgltf {
 	// An array of pairs of string representations of extension identifiers and their respective enum
 	// value used for enabling/disabling the loading of it. This also represents all extensions that
 	// fastgltf supports and understands.
-	static constexpr std::array<std::pair<std::string_view, Extensions>, 18> extensionStrings = {{
+	static constexpr std::array<std::pair<std::string_view, Extensions>, 19> extensionStrings = {{
 		{ extensions::EXT_meshopt_compression,            Extensions::EXT_meshopt_compression },
 		{ extensions::EXT_texture_webp,                   Extensions::EXT_texture_webp },
 		{ extensions::KHR_lights_punctual,                Extensions::KHR_lights_punctual },
@@ -294,6 +298,7 @@ namespace fastgltf {
 		{ extensions::KHR_materials_volume,               Extensions::KHR_materials_volume },
 		{ extensions::KHR_materials_pbrSpecularGlossiness,Extensions::KHR_materials_pbrSpecularGlossiness },
 		{ extensions::KHR_mesh_quantization,              Extensions::KHR_mesh_quantization },
+		{ extensions::EXT_mesh_gpu_instancing,            Extensions::EXT_mesh_gpu_instancing },
 		{ extensions::KHR_texture_basisu,                 Extensions::KHR_texture_basisu },
 		{ extensions::KHR_texture_transform,              Extensions::KHR_texture_transform },
 		{ extensions::MSFT_texture_dds,                   Extensions::MSFT_texture_dds },

warning: in the working copy of 'include/fastgltf/parser.hpp', LF will be replaced by CRLF the next time Git touches it
diff --git a/include/fastgltf/types.hpp b/include/fastgltf/types.hpp
index 4e8970a..100a828 100644
--- a/include/fastgltf/types.hpp
+++ b/include/fastgltf/types.hpp
@@ -1309,6 +1309,11 @@ namespace fastgltf {
          */
         std::variant<TRS, TransformMatrix> transform;
 
+        /**
+         * Only ever non-empty when EXT_mesh_gpu_instancing is enabled and used by the asset.
+         */
+        pmr::SmallVector<std::pair<std::pmr::string, std::size_t>, 4> instancingAttributes;
+
         std::pmr::string name;
     };
 

warning: in the working copy of 'include/fastgltf/types.hpp', LF will be replaced by CRLF the next time Git touches it
diff --git a/src/fastgltf.cpp b/src/fastgltf.cpp
index b7679b3..4d788dd 100644
--- a/src/fastgltf.cpp
+++ b/src/fastgltf.cpp
@@ -2777,6 +2777,31 @@ fg::Error fg::Parser::parseNodes(simdjson::dom::array& nodes, Asset& asset) {
                     node.lightIndex = static_cast<std::size_t>(light);
                 }
             }
+
+            dom::object gpuInstancingObject;
+            if (extensionsObject[extensions::EXT_mesh_gpu_instancing].get_object().get(gpuInstancingObject) == SUCCESS) {
+                dom::object attributesObject;
+                if (gpuInstancingObject["attributes"].get_object().get(attributesObject) == SUCCESS) {
+                    auto parseAttributes = [this](dom::object& object, decltype(node.instancingAttributes)& attributes) -> auto {
+                        // We iterate through the JSON object and write each key/pair value into the
+                        // attribute map. The keys are only validated in the validate() method.
+                        attributes = decltype(node.instancingAttributes)(0, resourceAllocator.get());
+                        attributes.reserve(object.size());
+                        for (const auto& field : object) {
+                            const auto key = field.key;
+
+                            std::uint64_t attributeIndex;
+                            if (field.value.get_uint64().get(attributeIndex) != SUCCESS) {
+                                return Error::InvalidGltf;
+                            }
+                            attributes.emplace_back(
+                                std::make_pair(std::pmr::string(key, resourceAllocator.get()), static_cast<std::size_t>(attributeIndex)));
+                        }
+                        return Error::None;
+                    };
+                    parseAttributes(attributesObject, node.instancingAttributes);
+                }
+            }
         }
 
         std::string_view name;
