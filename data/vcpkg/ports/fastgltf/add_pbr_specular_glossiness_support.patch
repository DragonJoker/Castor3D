diff --git a/src/fastgltf.cpp b/src/fastgltf.cpp
index 1ed284d..b7679b3 100644
--- a/src/fastgltf.cpp
+++ b/src/fastgltf.cpp
@@ -2357,6 +2357,79 @@ fg::Error fg::Parser::parseMaterials(simdjson::dom::array& materials, Asset& ass
                 }
             }
 
+            if (hasBit(config.extensions, Extensions::KHR_materials_pbrSpecularGlossiness)) {
+                dom::object specularGlossinessObject;
+                auto specularGlossinessError = extensionsObject[extensions::KHR_materials_pbrSpecularGlossiness].get_object().get(specularGlossinessObject);
+                if (specularGlossinessError == SUCCESS) {
+                    auto specularGlossiness = std::make_unique<MaterialSpecularGlossiness>();
+
+                    dom::array diffuseFactor;
+                    if (auto error = specularGlossinessObject["diffuseFactor"].get_array().get(diffuseFactor); error == SUCCESS) {
+                        std::size_t i = 0;
+                        for (auto factor : diffuseFactor) {
+                            if (i >= specularGlossiness->diffuseFactor.size()) {
+                                return Error::InvalidGltf;
+                            }
+                            double value;
+                            if (factor.get_double().get(value) != SUCCESS) {
+                                return Error::InvalidGltf;
+                            }
+                            specularGlossiness->diffuseFactor[i++] = static_cast<float>(value);
+                        }
+                    } else if (error == NO_SUCH_FIELD) {
+                        specularGlossiness->diffuseFactor = std::array<float, 4>{{ 1.0f, 1.0f, 1.0f, 1.0f }};
+                    } else {
+                        return Error::InvalidGltf;
+                    }
+
+                    TextureInfo diffuseTexture;
+                    if (auto error = parseTextureObject(specularGlossinessObject, "diffuseTexture", &diffuseTexture, config.extensions); error == Error::None) {
+                        specularGlossiness->diffuseTexture = std::move(diffuseTexture);
+                    } else if (error != Error::MissingField) {
+                        return error;
+                    }
+
+                    dom::array specularFactor;
+                    if (auto error = specularGlossinessObject["specularFactor"].get_array().get(specularFactor); error == SUCCESS) {
+                        std::size_t i = 0;
+                        for (auto factor : specularFactor) {
+                            if (i >= specularGlossiness->specularFactor.size()) {
+                                return Error::InvalidGltf;
+                            }
+                            double value;
+                            if (factor.get_double().get(value) != SUCCESS) {
+                                return Error::InvalidGltf;
+                            }
+                            specularGlossiness->specularFactor[i++] = static_cast<float>(value);
+                        }
+                    } else if (error == NO_SUCH_FIELD) {
+                        specularGlossiness->specularFactor = std::array<float, 3>{{ 1.0f, 1.0f, 1.0f }};
+                    } else {
+                        return Error::InvalidGltf;
+                    }
+
+                    double glossinessFactor;
+                    if (auto error = specularGlossinessObject["glossinessFactor"].get_double().get(glossinessFactor); error == SUCCESS) {
+                        specularGlossiness->glossinessFactor = static_cast<float>(glossinessFactor);
+                    } else if (error == NO_SUCH_FIELD) {
+                        specularGlossiness->glossinessFactor = 1.0f;
+                    } else {
+                        return Error::InvalidGltf;
+                    }
+
+                    TextureInfo specularGlossinessTexture;
+                    if (auto error = parseTextureObject(specularGlossinessObject, "specularGlossinessTexture", &specularGlossinessTexture, config.extensions); error == Error::None) {
+                        specularGlossiness->specularGlossinessTexture = std::move(specularGlossinessTexture);
+                    } else if (error != Error::MissingField) {
+                        return error;
+                    }
+
+                    material.specularGlossiness = std::move(specularGlossiness);
+                } else if (specularGlossinessError != NO_SUCH_FIELD) {
+                    return Error::InvalidJson;
+                }
+            }
+
             if (hasBit(config.extensions, Extensions::KHR_materials_transmission)) {
                 dom::object transmissionObject;
                 auto transmissionError = extensionsObject[extensions::KHR_materials_transmission].get_object().get(transmissionObject);
diff --git a/tests/extension_tests.cpp b/tests/extension_tests.cpp
index d724d03..0ae401e 100644
--- a/tests/extension_tests.cpp
+++ b/tests/extension_tests.cpp
@@ -120,6 +120,47 @@ TEST_CASE("Test KHR_materials_specular", "[gltf-loader]") {
     REQUIRE(materials[12].specular->specularColorTexture.value().textureIndex == 2);
 }
 
+TEST_CASE("Test KHR_materials_pbrSpecularGlossiness", "[gltf-loader]") {
+    auto specularGlossinessTest = sampleModels / "2.0" / "SpecGlossVsMetalRough" / "glTF";
+    fastgltf::GltfDataBuffer jsonData;
+    REQUIRE(jsonData.loadFromFile(specularGlossinessTest / "SpecGlossVsMetalRough.gltf"));
+
+    fastgltf::Parser parser(fastgltf::Extensions::KHR_materials_pbrSpecularGlossiness | fastgltf::Extensions::KHR_materials_specular);
+    auto model = parser.loadGLTF(&jsonData, specularGlossinessTest);
+    REQUIRE(model->parse(fastgltf::Category::Materials) == fastgltf::Error::None);
+    REQUIRE(model->validate() == fastgltf::Error::None);
+
+    auto asset = model->getParsedAsset();
+    REQUIRE(asset->materials.size() >= 12);
+
+    auto& materials = asset->materials;
+    REQUIRE(materials[0].specularGlossiness != nullptr);
+    REQUIRE(materials[0].specularGlossiness->diffuseFactor[0] == 1.0f);
+    REQUIRE(materials[0].specularGlossiness->diffuseFactor[1] == 1.0f);
+    REQUIRE(materials[0].specularGlossiness->diffuseFactor[2] == 1.0f);
+    REQUIRE(materials[0].specularGlossiness->diffuseFactor[3] == 1.0f);
+    REQUIRE(materials[0].specularGlossiness->specularFactor[0] == 1.0f);
+    REQUIRE(materials[0].specularGlossiness->specularFactor[1] == 1.0f);
+    REQUIRE(materials[0].specularGlossiness->specularFactor[2] == 1.0f);
+    REQUIRE(materials[0].specularGlossiness->glossinessFactor == 1.0f);
+    REQUIRE(materials[0].specularGlossiness->diffuseTexture.has_value());
+    REQUIRE(materials[0].specularGlossiness->diffuseTexture.value().textureIndex == 5);
+    REQUIRE(materials[0].specularGlossiness->specularGlossinessTexture.has_value());
+    REQUIRE(materials[0].specularGlossiness->specularGlossinessTexture.value().textureIndex == 6);
+
+    REQUIRE(materials[3].specularGlossiness != nullptr);
+    REQUIRE(materials[3].specularGlossiness->diffuseFactor[0] == 1.0f);
+    REQUIRE(materials[3].specularGlossiness->diffuseFactor[1] == 1.0f);
+    REQUIRE(materials[3].specularGlossiness->diffuseFactor[2] == 1.0f);
+    REQUIRE(materials[3].specularGlossiness->diffuseFactor[3] == 1.0f);
+    REQUIRE(materials[3].specularGlossiness->specularFactor[0] == 0.0f);
+    REQUIRE(materials[3].specularGlossiness->specularFactor[1] == 0.0f);
+    REQUIRE(materials[3].specularGlossiness->specularFactor[2] == 0.0f);
+    REQUIRE(materials[3].specularGlossiness->glossinessFactor == 0.0f);
+    REQUIRE(materials[3].specularGlossiness->diffuseTexture.has_value());
+    REQUIRE(materials[3].specularGlossiness->diffuseTexture.value().textureIndex == 7);
+}
+
 TEST_CASE("Test KHR_materials_ior and KHR_materials_iridescence", "[gltf-loader]") {
     auto specularTest = sampleModels / "2.0" / "IridescenceDielectricSpheres" / "glTF";
     fastgltf::GltfDataBuffer jsonData;

warning: in the working copy of 'tests/extension_tests.cpp', LF will be replaced by CRLF the next time Git touches it
diff --git a/include/fastgltf/types.hpp b/include/fastgltf/types.hpp
index f6b0de0..4e8970a 100644
--- a/include/fastgltf/types.hpp
+++ b/include/fastgltf/types.hpp
@@ -1439,6 +1439,17 @@ namespace fastgltf {
         Optional<TextureInfo> specularColorTexture;
     };
 
+    /**
+     * Specular/Glossiness information from KHR_materials_pbrSpecularGlossiness.
+     */
+    struct MaterialSpecularGlossiness {
+        std::array<float, 4> diffuseFactor;
+        std::optional<TextureInfo> diffuseTexture;
+        std::array<float, 3> specularFactor;
+        float glossinessFactor;
+        std::optional<TextureInfo> specularGlossinessTexture;
+    };
+
     /**
      * Iridescence information from KHR_materials_iridescence
      */
@@ -1533,6 +1544,11 @@ namespace fastgltf {
          */
         std::unique_ptr<MaterialSpecular> specular;
 
+        /**
+         * Specular/Glossiness information from KHR_materials_pbrSpecularGlossiness.
+         */
+        std::unique_ptr<MaterialSpecularGlossiness> specularGlossiness;
+
         /**
          * Specular information from KHR_materials_transmission.
          */

warning: in the working copy of 'include/fastgltf/types.hpp', LF will be replaced by CRLF the next time Git touches it
diff --git a/include/fastgltf/parser.hpp b/include/fastgltf/parser.hpp
index 4ead69c..bf78216 100644
--- a/include/fastgltf/parser.hpp
+++ b/include/fastgltf/parser.hpp
@@ -174,8 +174,11 @@ namespace fastgltf {
         // See https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_unlit/README.md
         KHR_materials_unlit = 1 << 17,
 
-		// See https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_anisotropy/README.md
-	    KHR_materials_anisotropy = 1 << 18,
+        // See https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_anisotropy/README.md
+        KHR_materials_anisotropy = 1 << 18,
+
+        // See https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Archived/KHR_materials_pbrSpecularGlossiness/README.md
+        KHR_materials_pbrSpecularGlossiness = 1 << 19,
     };
     // clang-format on
 
@@ -264,6 +267,7 @@ namespace fastgltf {
         constexpr std::string_view KHR_materials_transmission = "KHR_materials_transmission";
         constexpr std::string_view KHR_materials_unlit = "KHR_materials_unlit";
         constexpr std::string_view KHR_materials_volume = "KHR_materials_volume";
+        constexpr std::string_view KHR_materials_pbrSpecularGlossiness = "KHR_materials_pbrSpecularGlossiness";
         constexpr std::string_view KHR_mesh_quantization = "KHR_mesh_quantization";
         constexpr std::string_view KHR_texture_basisu = "KHR_texture_basisu";
         constexpr std::string_view KHR_texture_transform = "KHR_texture_transform";
@@ -274,7 +278,7 @@ namespace fastgltf {
 	// An array of pairs of string representations of extension identifiers and their respective enum
 	// value used for enabling/disabling the loading of it. This also represents all extensions that
 	// fastgltf supports and understands.
-	static constexpr std::array<std::pair<std::string_view, Extensions>, 17> extensionStrings = {{
+	static constexpr std::array<std::pair<std::string_view, Extensions>, 18> extensionStrings = {{
 		{ extensions::EXT_meshopt_compression,            Extensions::EXT_meshopt_compression },
 		{ extensions::EXT_texture_webp,                   Extensions::EXT_texture_webp },
 		{ extensions::KHR_lights_punctual,                Extensions::KHR_lights_punctual },
@@ -288,6 +292,7 @@ namespace fastgltf {
 		{ extensions::KHR_materials_transmission,         Extensions::KHR_materials_transmission },
 		{ extensions::KHR_materials_unlit,                Extensions::KHR_materials_unlit },
 		{ extensions::KHR_materials_volume,               Extensions::KHR_materials_volume },
+		{ extensions::KHR_materials_pbrSpecularGlossiness,Extensions::KHR_materials_pbrSpecularGlossiness },
 		{ extensions::KHR_mesh_quantization,              Extensions::KHR_mesh_quantization },
 		{ extensions::KHR_texture_basisu,                 Extensions::KHR_texture_basisu },
 		{ extensions::KHR_texture_transform,              Extensions::KHR_texture_transform },

warning: in the working copy of 'include/fastgltf/parser.hpp', LF will be replaced by CRLF the next time Git touches it
